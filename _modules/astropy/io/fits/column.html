<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.io.fits.column &mdash; Astropy v1.2.dev14999</title>
    
    <link rel="stylesheet" href="../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.2.dev14999',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.2.dev14999" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">Astropy v1.2.dev14999</a>
	 &raquo;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.io.fits.column</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>

<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">char</span> <span class="k">as</span> <span class="n">chararray</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_numpy_hacks</span> <span class="k">as</span> <span class="n">nh</span>
<span class="kn">from</span> <span class="nn">.card</span> <span class="kn">import</span> <span class="n">Card</span><span class="p">,</span> <span class="n">CARD_LENGTH</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">pairwise</span><span class="p">,</span> <span class="n">_is_int</span><span class="p">,</span> <span class="n">_convert_array</span><span class="p">,</span> <span class="n">encode_ascii</span><span class="p">,</span> <span class="nb">cmp</span><span class="p">,</span>
                   <span class="n">NotifierMixin</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">.verify</span> <span class="kn">import</span> <span class="n">VerifyError</span><span class="p">,</span> <span class="n">VerifyWarning</span>

<span class="kn">from</span> <span class="nn">...extern.six</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">...utils</span> <span class="kn">import</span> <span class="n">lazyproperty</span><span class="p">,</span> <span class="n">isiterable</span><span class="p">,</span> <span class="n">indent</span>
<span class="kn">from</span> <span class="nn">...utils.compat</span> <span class="kn">import</span> <span class="n">ignored</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Column&#39;</span><span class="p">,</span> <span class="s">&#39;ColDefs&#39;</span><span class="p">,</span> <span class="s">&#39;Delayed&#39;</span><span class="p">]</span>


<span class="c"># mapping from TFORM data type to numpy data type (code)</span>
<span class="c"># L: Logical (Boolean)</span>
<span class="c"># B: Unsigned Byte</span>
<span class="c"># I: 16-bit Integer</span>
<span class="c"># J: 32-bit Integer</span>
<span class="c"># K: 64-bit Integer</span>
<span class="c"># E: Single-precision Floating Point</span>
<span class="c"># D: Double-precision Floating Point</span>
<span class="c"># C: Single-precision Complex</span>
<span class="c"># M: Double-precision Complex</span>
<span class="c"># A: Character</span>
<span class="n">FITS2NUMPY</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;L&#39;</span><span class="p">:</span> <span class="s">&#39;i1&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">:</span> <span class="s">&#39;u1&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">:</span> <span class="s">&#39;i2&#39;</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">:</span> <span class="s">&#39;i4&#39;</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">:</span> <span class="s">&#39;i8&#39;</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="s">&#39;f4&#39;</span><span class="p">,</span>
              <span class="s">&#39;D&#39;</span><span class="p">:</span> <span class="s">&#39;f8&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">:</span> <span class="s">&#39;c8&#39;</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">:</span> <span class="s">&#39;c16&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="s">&#39;a&#39;</span><span class="p">}</span>

<span class="c"># the inverse dictionary of the above</span>
<span class="n">NUMPY2FITS</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">([(</span><span class="n">val</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">FITS2NUMPY</span><span class="p">)])</span>
<span class="c"># Normally booleans are represented as ints in pyfits, but if passed in a numpy</span>
<span class="c"># boolean array, that should be supported</span>
<span class="n">NUMPY2FITS</span><span class="p">[</span><span class="s">&#39;b1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;L&#39;</span>
<span class="c"># Add unsigned types, which will be stored as signed ints with a TZERO card.</span>
<span class="n">NUMPY2FITS</span><span class="p">[</span><span class="s">&#39;u2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;I&#39;</span>
<span class="n">NUMPY2FITS</span><span class="p">[</span><span class="s">&#39;u4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;J&#39;</span>
<span class="n">NUMPY2FITS</span><span class="p">[</span><span class="s">&#39;u8&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;K&#39;</span>

<span class="c"># This is the order in which values are converted to FITS types</span>
<span class="c"># Note that only double precision floating point/complex are supported</span>
<span class="n">FORMATORDER</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">,</span> <span class="s">&#39;D&#39;</span><span class="p">,</span> <span class="s">&#39;M&#39;</span><span class="p">,</span> <span class="s">&#39;A&#39;</span><span class="p">]</span>

<span class="c"># mapping from ASCII table TFORM data type to numpy data type</span>
<span class="c"># A: Character</span>
<span class="c"># I: Integer (32-bit)</span>
<span class="c"># J: Integer (64-bit; non-standard)</span>
<span class="c"># F: Float (32-bit; fixed decimal notation)</span>
<span class="c"># E: Float (32-bit; exponential notation)</span>
<span class="c"># D: Float (64-bit; exponential notation, always 64-bit by convention)</span>
<span class="n">ASCII2NUMPY</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="s">&#39;a&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">:</span> <span class="s">&#39;i4&#39;</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">:</span> <span class="s">&#39;i8&#39;</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">:</span> <span class="s">&#39;f4&#39;</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="s">&#39;f4&#39;</span><span class="p">,</span>
               <span class="s">&#39;D&#39;</span><span class="p">:</span> <span class="s">&#39;f8&#39;</span><span class="p">}</span>

<span class="c"># Maps FITS ASCII column format codes to the appropriate Python string</span>
<span class="c"># formatting codes for that type.</span>
<span class="n">ASCII2STR</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="s">&#39;s&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">:</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">:</span> <span class="s">&#39;d&#39;</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">:</span> <span class="s">&#39;f&#39;</span><span class="p">,</span> <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="s">&#39;D&#39;</span><span class="p">:</span> <span class="s">&#39;E&#39;</span><span class="p">}</span>

<span class="c"># For each ASCII table format code, provides a default width (and decimal</span>
<span class="c"># precision) for when one isn&#39;t given explicitly in the column format</span>
<span class="n">ASCII_DEFAULT_WIDTHS</span><span class="o">=</span> <span class="p">{</span><span class="s">&#39;A&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s">&#39;I&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="s">&#39;J&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                       <span class="s">&#39;E&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="s">&#39;F&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">16</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span> <span class="s">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="mi">25</span><span class="p">,</span> <span class="mi">17</span><span class="p">)}</span>




<span class="c"># lists of column/field definition common names and keyword names, make</span>
<span class="c"># sure to preserve the one-to-one correspondence when updating the list(s).</span>
<span class="c"># Use lists, instead of dictionaries so the names can be displayed in a</span>
<span class="c"># preferred order.</span>
<span class="n">KEYWORD_NAMES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;TTYPE&#39;</span><span class="p">,</span> <span class="s">&#39;TFORM&#39;</span><span class="p">,</span> <span class="s">&#39;TUNIT&#39;</span><span class="p">,</span> <span class="s">&#39;TNULL&#39;</span><span class="p">,</span> <span class="s">&#39;TSCAL&#39;</span><span class="p">,</span> <span class="s">&#39;TZERO&#39;</span><span class="p">,</span>
                 <span class="s">&#39;TDISP&#39;</span><span class="p">,</span> <span class="s">&#39;TBCOL&#39;</span><span class="p">,</span> <span class="s">&#39;TDIM&#39;</span><span class="p">]</span>
<span class="n">KEYWORD_ATTRIBUTES</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="s">&#39;unit&#39;</span><span class="p">,</span> <span class="s">&#39;null&#39;</span><span class="p">,</span> <span class="s">&#39;bscale&#39;</span><span class="p">,</span> <span class="s">&#39;bzero&#39;</span><span class="p">,</span>
                      <span class="s">&#39;disp&#39;</span><span class="p">,</span> <span class="s">&#39;start&#39;</span><span class="p">,</span> <span class="s">&#39;dim&#39;</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;This is a list of the attributes that can be set on `Column` objects.&quot;&quot;&quot;</span>


<span class="n">KEYWORD_TO_ATTRIBUTE</span> <span class="o">=</span> \
    <span class="n">OrderedDict</span><span class="p">((</span><span class="n">keyword</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">KEYWORD_NAMES</span><span class="p">,</span> <span class="n">KEYWORD_ATTRIBUTES</span><span class="p">))</span>


<span class="n">ATTRIBUTE_TO_KEYWORD</span> <span class="o">=</span> \
    <span class="n">OrderedDict</span><span class="p">((</span><span class="n">value</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>


<span class="c"># TODO: Define a list of default comments to associate with each table keyword</span>

<span class="c"># TFORMn regular expression</span>
<span class="n">TFORMAT_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?P&lt;repeat&gt;^[0-9]*)(?P&lt;format&gt;[LXBIJKAEDCMPQ])&#39;</span>
                        <span class="s">r&#39;(?P&lt;option&gt;[!-~]*)&#39;</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>

<span class="c"># TFORMn for ASCII tables; two different versions depending on whether</span>
<span class="c"># the format is floating-point or not; allows empty values for width</span>
<span class="c"># in which case defaults are used</span>
<span class="n">TFORMAT_ASCII_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?:(?P&lt;format&gt;[AIJ])(?P&lt;width&gt;[0-9]+)?)|&#39;</span>
                              <span class="s">r&#39;(?:(?P&lt;formatf&gt;[FED])&#39;</span>
                              <span class="s">r&#39;(?:(?P&lt;widthf&gt;[0-9]+)\.&#39;</span>
                              <span class="s">r&#39;(?P&lt;precision&gt;[0-9]+))?)&#39;</span><span class="p">)</span>

<span class="n">TTYPE_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;[0-9a-zA-Z_]+&#39;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Regular expression for valid table column names.  See FITS Standard v3.0 section</span>
<span class="sd">7.2.2.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c"># table definition keyword regular expression</span>
<span class="n">TDEF_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?P&lt;label&gt;^T[A-Z]*)(?P&lt;num&gt;[1-9][0-9 ]*$)&#39;</span><span class="p">)</span>

<span class="c"># table dimension keyword regular expression (fairly flexible with whitespace)</span>
<span class="n">TDIM_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;\(\s*(?P&lt;dims&gt;(?:\d+,\s*)+\s*\d+)\s*\)\s*&#39;</span><span class="p">)</span>

<span class="c"># value for ASCII table cell with value = TNULL</span>
<span class="c"># this can be reset by user.</span>
<span class="n">ASCIITNULL</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c"># The default placeholder to use for NULL values in ASCII tables when</span>
<span class="c"># converting from binary to ASCII tables</span>
<span class="n">DEFAULT_ASCII_TNULL</span> <span class="o">=</span> <span class="s">&#39;---&#39;</span>


<span class="k">class</span> <span class="nc">Delayed</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Delayed file-reading data.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hdu</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">field</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">hdu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">field</span> <span class="o">=</span> <span class="n">field</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c"># This forces the data for the HDU to be read, which will replace</span>
        <span class="c"># the corresponding Delayed objects in the Tables Columns to be</span>
        <span class="c"># transformed into ndarrays.  It will also return the value of the</span>
        <span class="c"># requested data element.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hdu</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">field</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">_BaseColumnFormat</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for binary table column formats (just called _ColumnFormat)</span>
<span class="sd">    and ASCII table column formats (_AsciiColumnFormat).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">canonical</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">canonical</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Numpy dtype object created from the format&#39;s associated recformat.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recformat</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_column_format</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a column format object from another column format object</span>
<span class="sd">        regardless of their type.</span>

<span class="sd">        That is, this can convert a _ColumnFormat to an _AsciiColumnFormat</span>
<span class="sd">        or vice versa at least in cases where a direct translation is possible.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_recformat</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">recformat</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_ColumnFormat</span><span class="p">(</span><span class="n">_BaseColumnFormat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a FITS binary table column format.</span>

<span class="sd">    This is an enhancement over using a normal string for the format, since the</span>
<span class="sd">    repeat count, format code, and option are available as separate attributes,</span>
<span class="sd">    and smart comparison is used.  For example 1J == J.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_ColumnFormat</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span> <span class="o">=</span> <span class="n">_parse_tformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">):</span>
            <span class="c"># TODO: There should be a generic factory that returns either</span>
            <span class="c"># _FormatP or _FormatQ as appropriate for a given TFORMn</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s">&#39;P&#39;</span><span class="p">:</span>
                <span class="n">recformat</span> <span class="o">=</span> <span class="n">_FormatP</span><span class="o">.</span><span class="n">from_tform</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">recformat</span> <span class="o">=</span> <span class="n">_FormatQ</span><span class="o">.</span><span class="n">from_tform</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
            <span class="c"># Format of variable length arrays</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_format</span> <span class="o">=</span> <span class="n">recformat</span><span class="o">.</span><span class="n">format</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_format</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_recformat</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">recformat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a column format from a Numpy record dtype format.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">_convert_format</span><span class="p">(</span><span class="n">recformat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">recformat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the equivalent Numpy record format string.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_convert_format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">canonical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a &#39;canonical&#39; string representation of this format.</span>

<span class="sd">        This is in the proper form of rTa where T is the single character data</span>
<span class="sd">        type code, a is the optional part, and r is the repeat.  If repeat == 1</span>
<span class="sd">        (the default) it is left out of this representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">)</span>

        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">option</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_AsciiColumnFormat</span><span class="p">(</span><span class="n">_BaseColumnFormat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Similar to _ColumnFormat but specifically for columns in ASCII tables.</span>

<span class="sd">    The formats of ASCII table columns and binary table columns are inherently</span>
<span class="sd">    incompatible in FITS.  They don&#39;t support the same ranges and types of</span>
<span class="sd">    values, and even reuse format codes in subtly different ways.  For example</span>
<span class="sd">    the format code &#39;Iw&#39; in ASCII columns refers to any integer whose string</span>
<span class="sd">    representation is at most w characters wide, so &#39;I&#39; can represent</span>
<span class="sd">    effectively any integer that will fit in a FITS columns.  Whereas for</span>
<span class="sd">    binary tables &#39;I&#39; very explicitly refers to a 16-bit signed integer.</span>

<span class="sd">    Conversions between the two column formats can be performed using the</span>
<span class="sd">    ``to/from_binary`` methods on this class, or the ``to/from_ascii``</span>
<span class="sd">    methods on the `_ColumnFormat` class.  But again, not all conversions are</span>
<span class="sd">    possible and may result in a `~.exceptions.ValueError`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_AsciiColumnFormat</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span> <span class="o">=</span> \
            <span class="n">_parse_ascii_tformat</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">strict</span><span class="p">)</span>

        <span class="c"># This is to support handling logical (boolean) data from binary tables</span>
        <span class="c"># in an ASCII table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_logical</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_column_format</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">):</span>
        <span class="n">inst</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_recformat</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">recformat</span><span class="p">)</span>
        <span class="c"># Hack</span>
        <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s">&#39;L&#39;</span><span class="p">:</span>
            <span class="n">inst</span><span class="o">.</span><span class="n">_pseudo_logical</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">inst</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_recformat</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">recformat</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a column format from a Numpy record dtype format.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">_convert_ascii_format</span><span class="p">(</span><span class="n">recformat</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">recformat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the equivalent Numpy record format string.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_convert_ascii_format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">canonical</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a &#39;canonical&#39; string representation of this format.</span>

<span class="sd">        This is in the proper form of Tw.d where T is the single character data</span>
<span class="sd">        type code, w is the width in characters for this field, and d is the</span>
<span class="sd">        number of digits after the decimal place (for format codes &#39;E&#39;, &#39;F&#39;,</span>
<span class="sd">        and &#39;D&#39; only).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;E&#39;</span><span class="p">,</span> <span class="s">&#39;F&#39;</span><span class="p">,</span> <span class="s">&#39;D&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">.</span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">)</span>

        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_FormatX</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For X format in binary tables.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">nbytes</span> <span class="o">=</span> <span class="p">((</span><span class="n">repeat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c"># use an array, even if it is only ONE u1 (i.e. use tuple always)</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_FormatX</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">repr</span><span class="p">((</span><span class="n">nbytes</span><span class="p">,))</span> <span class="o">+</span> <span class="s">&#39;u1&#39;</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">repeat</span> <span class="o">=</span> <span class="n">repeat</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">,)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s</span><span class="s">X&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span>


<span class="c"># TODO: Table column formats need to be verified upon first reading the file;</span>
<span class="c"># as it is, an invalid P format will raise a VerifyError from some deep,</span>
<span class="c"># unexpected place</span>
<span class="k">class</span> <span class="nc">_FormatP</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For P format in variable length table.&quot;&quot;&quot;</span>

    <span class="c"># As far as I can tell from my reading of the FITS standard, a type code is</span>
    <span class="c"># *required* for P and Q formats; there is no default</span>
    <span class="n">_format_re_template</span> <span class="o">=</span> <span class="p">(</span><span class="s">r&#39;(?P&lt;repeat&gt;\d+)?</span><span class="si">%s</span><span class="s">(?P&lt;dtype&gt;[LXBIJKAEDCM])&#39;</span>
                            <span class="s">&#39;(?:\((?P&lt;max&gt;\d*)\))?&#39;</span><span class="p">)</span>
    <span class="n">_format_code</span> <span class="o">=</span> <span class="s">&#39;P&#39;</span>
    <span class="n">_format_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">_format_re_template</span> <span class="o">%</span> <span class="n">_format_code</span><span class="p">)</span>
    <span class="n">_descriptor_format</span> <span class="o">=</span> <span class="s">&#39;2i4&#39;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_FormatP</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">_descriptor_format</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="n">NUMPY2FITS</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">repeat</span> <span class="o">=</span> <span class="n">repeat</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_tform</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_format_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span> <span class="ow">or</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">FITS2NUMPY</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;Invalid column format: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">format</span><span class="p">)</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;repeat&#39;</span><span class="p">)</span>
        <span class="n">array_dtype</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;dtype&#39;</span><span class="p">)</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;max&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">max</span><span class="p">:</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">array_dtype</span><span class="p">],</span> <span class="n">repeat</span><span class="o">=</span><span class="n">repeat</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="nb">max</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">tform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat</span>
        <span class="nb">max</span> <span class="o">=</span> <span class="s">&#39;&#39;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="si">%s%s%s</span><span class="s">(</span><span class="si">%s</span><span class="s">)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_format_code</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_FormatQ</span><span class="p">(</span><span class="n">_FormatP</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Carries type description of the Q format for variable length arrays.</span>

<span class="sd">    The Q format is like the P format but uses 64-bit integers in the array</span>
<span class="sd">    descriptors, allowing for heaps stored beyond 2GB into a file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_format_code</span> <span class="o">=</span> <span class="s">&#39;Q&#39;</span>
    <span class="n">_format_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">_FormatP</span><span class="o">.</span><span class="n">_format_re_template</span> <span class="o">%</span> <span class="n">_format_code</span><span class="p">)</span>
    <span class="n">_descriptor_format</span> <span class="o">=</span> <span class="s">&#39;2i8&#39;</span>


<span class="k">class</span> <span class="nc">ColumnAttribute</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Descriptor for attributes of `Column` that are associated with keywords</span>
<span class="sd">    in the FITS header and describe properties of the column as specified in</span>
<span class="sd">    the FITS standard.</span>

<span class="sd">    Each `ColumnAttribute` may have a ``validator`` method defined on it.</span>
<span class="sd">    This validates values set on this attribute to ensure that they meet the</span>
<span class="sd">    FITS standard.  Invalid values will raise a warning and will not be used in</span>
<span class="sd">    formatting the column.  The validator should take two arguments--the</span>
<span class="sd">    `Column` it is being assigned to, and the new value for the attribute, and</span>
<span class="sd">    it must raise an `AssertionError` if the value is invalid.</span>

<span class="sd">    The `ColumnAttribute` itself is a decorator that can be used to define the</span>
<span class="sd">    ``validator`` for each column attribute.  For example::</span>

<span class="sd">        @ColumnAttribute(&#39;TTYPE&#39;)</span>
<span class="sd">        def name(col, name):</span>
<span class="sd">            assert isinstance(name, str)</span>

<span class="sd">    The actual object returned by this decorator is the `ColumnAttribute`</span>
<span class="sd">    instance though, not the ``name`` function.  As such ``name`` is not a</span>
<span class="sd">    method of the class it is defined in.</span>

<span class="sd">    The setter for `ColumnAttribute` also updates the header of any table</span>
<span class="sd">    HDU this column is attached to in order to reflect the change.  The</span>
<span class="sd">    ``validator`` should ensure that the value is valid for inclusion in a FITS</span>
<span class="sd">    header.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># The name of the attribute associated with this keyword is currently</span>
        <span class="c"># determined from the KEYWORD_NAMES/ATTRIBUTES lists.  This could be</span>
        <span class="c"># make more flexible in the future, for example, to support custom</span>
        <span class="c"># column attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span> <span class="o">=</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__set__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">old_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s">&#39;_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">_notify</span><span class="p">(</span><span class="s">&#39;column_attribute_changed&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attr</span><span class="p">,</span> <span class="n">old_value</span><span class="p">,</span>
                    <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the validator for this column attribute.</span>

<span class="sd">        Returns ``self`` so that this can be used as a decorator, as described</span>
<span class="sd">        in the docs for this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_validator</span> <span class="o">=</span> <span class="n">func</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&quot;{0}(&#39;{1}&#39;)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">)</span>


<div class="viewcode-block" id="Column"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.Column">[docs]</a><span class="k">class</span> <span class="nc">Column</span><span class="p">(</span><span class="n">NotifierMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class which contains the definition of one column, e.g.  ``ttype``,</span>
<span class="sd">    ``tform``, etc. and the array containing values for the column.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">null</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">bscale</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bzero</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">array</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ascii</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `Column` by specifying attributes.  All attributes</span>
<span class="sd">        except ``format`` can be optional; see :ref:`column_creation` and</span>
<span class="sd">        :ref:`creating_ascii_table` for more information regarding</span>
<span class="sd">        ``TFORM`` keyword.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str, optional</span>
<span class="sd">            column name, corresponding to ``TTYPE`` keyword</span>

<span class="sd">        format : str</span>
<span class="sd">            column format, corresponding to ``TFORM`` keyword</span>

<span class="sd">        unit : str, optional</span>
<span class="sd">            column unit, corresponding to ``TUNIT`` keyword</span>

<span class="sd">        null : str, optional</span>
<span class="sd">            null value, corresponding to ``TNULL`` keyword</span>

<span class="sd">        bscale : int-like, optional</span>
<span class="sd">            bscale value, corresponding to ``TSCAL`` keyword</span>

<span class="sd">        bzero : int-like, optional</span>
<span class="sd">            bzero value, corresponding to ``TZERO`` keyword</span>

<span class="sd">        disp : str, optional</span>
<span class="sd">            display format, corresponding to ``TDISP`` keyword</span>

<span class="sd">        start : int, optional</span>
<span class="sd">            column starting position (ASCII table only), corresponding</span>
<span class="sd">            to ``TBCOL`` keyword</span>

<span class="sd">        dim : str, optional</span>
<span class="sd">            column dimension corresponding to ``TDIM`` keyword</span>

<span class="sd">        array : iterable, optional</span>
<span class="sd">            a `list`, `numpy.ndarray` (or other iterable that can be used to</span>
<span class="sd">            initialize an ndarray) providing initial data for this column.</span>
<span class="sd">            The array will be automatically converted, if possible, to the data</span>
<span class="sd">            format of the column.  In the case were non-trivial ``bscale``</span>
<span class="sd">            and/or ``bzero`` arguments are given, the values in the array must</span>
<span class="sd">            be the *physical* values--that is, the values of column as if the</span>
<span class="sd">            scaling has already been applied (the array stored on the column</span>
<span class="sd">            object will then be converted back to its storage values).</span>

<span class="sd">        ascii : bool, optional</span>
<span class="sd">            set `True` if this describes a column for an ASCII table; this</span>
<span class="sd">            may be required to disambiguate the column format</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Must specify format to construct Column.&#39;</span><span class="p">)</span>

        <span class="c"># any of the input argument (except array) can be a Card or just</span>
        <span class="c"># a number/string</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;ascii&#39;</span><span class="p">:</span> <span class="n">ascii</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">KEYWORD_ATTRIBUTES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">attr</span><span class="p">]</span>  <span class="c"># get the argument&#39;s value</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>

            <span class="n">kwargs</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="n">valid_kwargs</span><span class="p">,</span> <span class="n">invalid_kwargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_verify_keywords</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">invalid_kwargs</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;The following keyword arguments to Column were invalid:&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">invalid_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">msg</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">msg</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">KEYWORD_ATTRIBUTES</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">valid_kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span>

        <span class="c"># TODO: For PyFITS 3.3 try to eliminate the following two special cases</span>
        <span class="c"># for recformat and dim:</span>
        <span class="c"># This is not actually stored as an attribute on columns for some</span>
        <span class="c"># reason</span>
        <span class="n">recformat</span> <span class="o">=</span> <span class="n">valid_kwargs</span><span class="p">[</span><span class="s">&#39;recformat&#39;</span><span class="p">]</span>

        <span class="c"># The &#39;dim&#39; keyword&#39;s original value is stored in self.dim, while</span>
        <span class="c"># *only* the tuple form is stored in self._dims.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>

        <span class="c"># Awful hack to use for now to keep track of whether the column holds</span>
        <span class="c"># pseudo-unsigned int data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_unsigned_ints</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># if the column data is not ndarray, make it to be one, i.e.</span>
        <span class="c"># input arrays can be just list or tuple, not required to be ndarray</span>
        <span class="c"># does not include Object array because there is no guarantee</span>
        <span class="c"># the elements in the object array are consistent.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span>
                          <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">chararray</span><span class="o">.</span><span class="n">chararray</span><span class="p">,</span> <span class="n">Delayed</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>  <span class="c"># try to convert to a ndarray first</span>
                <span class="k">if</span> <span class="n">array</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>  <span class="c"># then try to convert it to a strings array</span>
                    <span class="n">itemsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">recformat</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="n">array</span> <span class="o">=</span> <span class="n">chararray</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="n">itemsize</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c"># then try variable length array</span>
                    <span class="c"># Note: This includes _FormatQ by inheritance</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recformat</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
                        <span class="n">array</span> <span class="o">=</span> <span class="n">_VLF</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">recformat</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Data is inconsistent with the &#39;</span>
                                         <span class="s">&#39;format `</span><span class="si">%s</span><span class="s">`.&#39;</span> <span class="o">%</span> <span class="n">format</span><span class="p">)</span>

        <span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_to_valid_data_type</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>

        <span class="c"># We have required (through documentation) that arrays passed in to</span>
        <span class="c"># this constructor are already in their physical values, so we make</span>
        <span class="c"># note of that here</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_physical_values</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_physical_values</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_fits_rec</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">KEYWORD_ATTRIBUTES</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">text</span> <span class="o">+=</span> <span class="n">attr</span> <span class="o">+</span> <span class="s">&#39; = &#39;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;; &#39;</span>
        <span class="k">return</span> <span class="n">text</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Two columns are equal if their name and format are the same.  Other</span>
<span class="sd">        attributes aren&#39;t taken into account at this time.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># According to the FITS standard column names must be case-insensitive</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">other</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like __eq__, the hash of a column should be based on the unique column</span>
<span class="sd">        name and format, and be case-insensitive with respect to the column</span>
<span class="sd">        name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The Numpy `~numpy.ndarray` associated with this `Column`.</span>

<span class="sd">        If the column was instantiated with an array passed to the ``array``</span>
<span class="sd">        argument, this will return that array.  However, if the column is</span>
<span class="sd">        later added to a table, such as via `BinTableHDU.from_columns` as</span>
<span class="sd">        is typically the case, this attribute will be updated to reference</span>
<span class="sd">        the associated field in the table, which may no longer be the same</span>
<span class="sd">        array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Ideally the .array attribute never would have existed in the first</span>
        <span class="c"># place, or would have been internal-only.  This is a legacy of the</span>
        <span class="c"># older design from PyFITS that needs to have continued support, for</span>
        <span class="c"># now.</span>

        <span class="c"># One of the main problems with this design was that it created a</span>
        <span class="c"># reference cycle.  When the .array attribute was updated after</span>
        <span class="c"># creating a FITS_rec from the column (as explained in the docstring) a</span>
        <span class="c"># reference cycle was created.  This is because the code in BinTableHDU</span>
        <span class="c"># (and a few other places) does essentially the following:</span>
        <span class="c">#</span>
        <span class="c"># data._coldefs = columns  # The ColDefs object holding this Column</span>
        <span class="c"># for col in columns:</span>
        <span class="c">#     col.array = data.field(col.name)</span>
        <span class="c">#</span>
        <span class="c"># This way each columns .array attribute now points to the field in the</span>
        <span class="c"># table data.  It&#39;s actually a pretty confusing interface (since it</span>
        <span class="c"># replaces the array originally pointed to by .array), but it&#39;s the way</span>
        <span class="c"># things have been for a long, long time.</span>
        <span class="c">#</span>
        <span class="c"># However, this results, in *many* cases, in a reference cycle.</span>
        <span class="c"># Because the array returned by data.field(col.name), while sometimes</span>
        <span class="c"># an array that owns its own data, is usually like a slice of the</span>
        <span class="c"># original data.  It has the original FITS_rec as the array .base.</span>
        <span class="c"># This results in the following reference cycle (for the n-th column):</span>
        <span class="c">#</span>
        <span class="c">#    data -&gt; data._coldefs -&gt; data._coldefs[n] -&gt;</span>
        <span class="c">#     data._coldefs[n].array -&gt; data._coldefs[n].array.base -&gt; data</span>
        <span class="c">#</span>
        <span class="c"># Because ndarray objects do not handled by Python&#39;s garbage collector</span>
        <span class="c"># the reference cycle cannot be broken.  Therefore the FITS_rec&#39;s</span>
        <span class="c"># refcount never goes to zero, its __del__ is never called, and its</span>
        <span class="c"># memory is never freed.  This didn&#39;t occur in *all* cases, but it did</span>
        <span class="c"># occur in many cases.</span>
        <span class="c">#</span>
        <span class="c"># To get around this, Column.array is no longer a simple attribute</span>
        <span class="c"># like it was previously.  Now each Column has a ._parent_fits_rec</span>
        <span class="c"># attribute which is a weakref to a FITS_rec object.  Code that</span>
        <span class="c"># previously assigned each col.array to field in a FITS_rec (as in</span>
        <span class="c"># the example a few paragraphs above) is still used, however now</span>
        <span class="c"># array.setter checks if a reference cycle will be created.  And if</span>
        <span class="c"># so, instead of saving directly to the Column&#39;s __dict__, it creates</span>
        <span class="c"># the ._prent_fits_rec weakref, and all lookups of the column&#39;s .array</span>
        <span class="c"># go through that instead.</span>
        <span class="c">#</span>
        <span class="c"># This alone does not fully solve the problem.  Because</span>
        <span class="c"># _parent_fits_rec is a weakref, if the user ever holds a reference to</span>
        <span class="c"># the Column, but deletes all references to the underlying FITS_rec,</span>
        <span class="c"># the .array attribute would suddenly start returning None instead of</span>
        <span class="c"># the array data.  This problem is resolved on FITS_rec&#39;s end.  See the</span>
        <span class="c"># note in the FITS_rec._coldefs property for the rest of the story.</span>

        <span class="c"># If the Columns&#39;s array is not a reference to an existing FITS_rec,</span>
        <span class="c"># then it is just stored in self.__dict__; otherwise check the</span>
        <span class="c"># _parent_fits_rec reference if it &#39;s still available.</span>
        <span class="k">if</span> <span class="s">&#39;array&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_fits_rec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_fits_rec</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="nd">@array.setter</span>
    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="c"># The following looks over the bases of the given array to check if it</span>
        <span class="c"># has a ._coldefs attribute (i.e. is a FITS_rec) and that that _coldefs</span>
        <span class="c"># contains this Column itself, and would create a reference cycle if we</span>
        <span class="c"># stored the array directly in self.__dict__.</span>
        <span class="c"># In this case it instead sets up the _parent_fits_rec weakref to the</span>
        <span class="c"># underlying FITS_rec, so that array.getter can return arrays through</span>
        <span class="c"># self._parent_fits_rec().field(self.name), rather than storing a</span>
        <span class="c"># hard reference to the field like it used to.</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">array</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">&#39;_coldefs&#39;</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">base</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="bp">self</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_fits_rec</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_fits_rec</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">ref</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>

                        <span class="c"># Just in case the user already set .array to their own</span>
                        <span class="c"># array.</span>
                        <span class="k">if</span> <span class="s">&#39;array&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
                        <span class="k">return</span>

            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s">&#39;base&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">base</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>

    <span class="nd">@array.deleter</span>
    <span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;array&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parent_fits_rec</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="nd">@ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TTYPE&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Allow None to indicate deleting the name, or to just indicate an</span>
            <span class="c"># unspecified name (when creating a new Column).</span>
            <span class="k">return</span>

        <span class="c"># Check that the name meets the recommended standard--other column</span>
        <span class="c"># names are *allowed*, but will be discouraged</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">TTYPE_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s">&#39;It is strongly recommended that column names contain only &#39;</span>
                <span class="s">&#39;upper and lower-case ASCII letters, digits, or underscores &#39;</span>
                <span class="s">&#39;for maximum compatibility with other software &#39;</span>
                <span class="s">&#39;(got {0!r}).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">VerifyWarning</span><span class="p">)</span>

        <span class="c"># This ensures that the new name can fit into a single FITS card</span>
        <span class="c"># without any special extension like CONTINUE cards or the like.</span>
        <span class="k">assert</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">Card</span><span class="p">(</span><span class="s">&#39;TTYPE&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">)))</span> <span class="o">==</span> <span class="n">CARD_LENGTH</span><span class="p">),</span> \
                    <span class="p">(</span><span class="s">&#39;Column name must be a string able to fit in a single &#39;</span>
                     <span class="s">&#39;FITS card--typically this means a maximum of 68 &#39;</span>
                     <span class="s">&#39;characters, though it may be fewer if the string &#39;</span>
                     <span class="s">&#39;contains special characters like quotes.&#39;</span><span class="p">)</span>

    <span class="n">format</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TFORM&#39;</span><span class="p">)</span>
    <span class="n">unit</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TUNIT&#39;</span><span class="p">)</span>
    <span class="n">null</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TNULL&#39;</span><span class="p">)</span>
    <span class="n">bscale</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TSCAL&#39;</span><span class="p">)</span>
    <span class="n">bzero</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TZERO&#39;</span><span class="p">)</span>
    <span class="n">disp</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TDISP&#39;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TBCOL&#39;</span><span class="p">)</span>
    <span class="n">dim</span> <span class="o">=</span> <span class="n">ColumnAttribute</span><span class="p">(</span><span class="s">&#39;TDIM&#39;</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Whether this `Column` represents an column in an ASCII table.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">dtype</span>

<div class="viewcode-block" id="Column.copy"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.Column.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of this `Column`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="s">&#39;I&#39;</span><span class="p">)</span>  <span class="c"># just use a throw-away format</span>
        <span class="n">tmp</span><span class="o">.</span><span class="n">__dict__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tmp</span>
</div>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_convert_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The format argument to this class&#39;s initializer may come in many</span>
<span class="sd">        forms.  This uses the given column format class ``cls`` to convert</span>
<span class="sd">        to a format of that type.</span>

<span class="sd">        TODO: There should be an abc base class for column format classes</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Short circuit in case we&#39;re already a _BaseColumnFormat--there is at</span>
        <span class="c"># least one case in which this can happen</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_BaseColumnFormat</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">format</span><span class="p">,</span> <span class="n">format</span><span class="o">.</span><span class="n">recformat</span>

        <span class="k">if</span> <span class="n">format</span> <span class="ow">in</span> <span class="n">NUMPY2FITS</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="n">VerifyError</span><span class="p">):</span>
                <span class="c"># legit recarray format?</span>
                <span class="n">recformat</span> <span class="o">=</span> <span class="n">format</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_recformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c"># legit FITS format?</span>
            <span class="n">format</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="n">recformat</span>
        <span class="k">except</span> <span class="n">VerifyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;Illegal format `</span><span class="si">%s</span><span class="s">`.&#39;</span> <span class="o">%</span> <span class="n">format</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_verify_keywords</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">null</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">bscale</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bzero</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">dim</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ascii</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given the keyword arguments used to initialize a Column, specifically</span>
<span class="sd">        those that typically read from a FITS header (so excluding array),</span>
<span class="sd">        verify that each keyword has a valid value.</span>

<span class="sd">        Returns a 2-tuple of dicts.  The first maps valid keywords to their</span>
<span class="sd">        values.  The second maps invalid keywords to a 2-tuple of their value,</span>
<span class="sd">        and a message explaining why they were found invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">valid</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_determine_formats</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">ascii</span><span class="p">)</span>
        <span class="n">valid</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">,</span> <span class="n">recformat</span><span class="o">=</span><span class="n">recformat</span><span class="p">)</span>

        <span class="c"># Currently we don&#39;t have any validation for name, unit, bscale, or</span>
        <span class="c"># bzero so include those by default</span>
        <span class="c"># TODO: Add validation for these keywords, obviously</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;unit&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="p">),</span> <span class="p">(</span><span class="s">&#39;bscale&#39;</span><span class="p">,</span> <span class="n">bscale</span><span class="p">),</span>
                     <span class="p">(</span><span class="s">&#39;bzero&#39;</span><span class="p">,</span> <span class="n">bzero</span><span class="p">)]:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="n">valid</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c"># Validate null option</span>
        <span class="c"># Note: Enough code exists that thinks empty strings are sensible</span>
        <span class="c"># inputs for these options that we need to treat &#39;&#39; as None</span>
        <span class="k">if</span> <span class="n">null</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">null</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">):</span>
                <span class="n">null</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">null</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">null</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">format</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s">&quot;ASCII table null option (TNULLn) is longer than &quot;</span>
                        <span class="s">&quot;the column&#39;s character width and will be truncated &quot;</span>
                        <span class="s">&quot;(got </span><span class="si">%r</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="n">null</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">null</span><span class="p">):</span>
                    <span class="c"># Make this an exception instead of a warning, since any</span>
                    <span class="c"># non-int value is meaningless</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s">&#39;Column null option (TNULLn) must be an integer for &#39;</span>
                        <span class="s">&#39;binary table columns (got </span><span class="si">%r</span><span class="s">).  The invalid value &#39;</span>
                        <span class="s">&#39;will be ignored for the purpose of formatting &#39;</span>
                        <span class="s">&#39;the data in this column.&#39;</span> <span class="o">%</span> <span class="n">null</span><span class="p">)</span>

                <span class="n">tnull_formats</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">format</span> <span class="ow">in</span> <span class="n">tnull_formats</span> <span class="ow">or</span>
                        <span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">format</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;P&#39;</span><span class="p">,</span> <span class="s">&#39;Q&#39;</span><span class="p">)</span> <span class="ow">and</span>
                         <span class="n">format</span><span class="o">.</span><span class="n">p_format</span> <span class="ow">in</span> <span class="n">tnull_formats</span><span class="p">)):</span>
                    <span class="c"># TODO: We should also check that TNULLn&#39;s integer value</span>
                    <span class="c"># is in the range allowed by the column&#39;s format</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s">&#39;Column null option (TNULLn) is invalid for binary &#39;</span>
                        <span class="s">&#39;table columns of type </span><span class="si">%r</span><span class="s"> (got </span><span class="si">%r</span><span class="s">).  The invalid &#39;</span>
                        <span class="s">&#39;value will be ignored for the purpose of formatting &#39;</span>
                        <span class="s">&#39;the data in this column.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">null</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">valid</span><span class="p">[</span><span class="s">&#39;null&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">null</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalid</span><span class="p">[</span><span class="s">&#39;null&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">null</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="c"># Validate the disp option</span>
        <span class="c"># TODO: Add full parsing and validation of TDISPn keywords</span>
        <span class="k">if</span> <span class="n">disp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">disp</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">disp</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s">&#39;Column disp option (TDISPn) must be a string (got </span><span class="si">%r</span><span class="s">).&#39;</span>
                    <span class="s">&#39;The invalid value will be ignored for the purpose of &#39;</span>
                    <span class="s">&#39;formatting the data in this column.&#39;</span> <span class="o">%</span> <span class="n">disp</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">disp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;L&#39;</span><span class="p">):</span>
                <span class="c"># disp is at least one character long and has the &#39;L&#39; format</span>
                <span class="c"># which is not recognized for ASCII tables</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s">&quot;Column disp option (TDISPn) may not use the &#39;L&#39; format &quot;</span>
                    <span class="s">&quot;with ASCII table columns.  The invalid value will be &quot;</span>
                    <span class="s">&quot;ignored for the purpose of formatting the data in this &quot;</span>
                    <span class="s">&quot;column.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">valid</span><span class="p">[</span><span class="s">&#39;disp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">disp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalid</span><span class="p">[</span><span class="s">&#39;disp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">disp</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="c"># Validate the start option</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">):</span>
                <span class="c"># The &#39;start&#39; option only applies to ASCII columns</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s">&#39;Column start option (TBCOLn) is not allowed for binary &#39;</span>
                    <span class="s">&#39;table columns (got </span><span class="si">%r</span><span class="s">).  The invalid keyword will be &#39;</span>
                    <span class="s">&#39;ignored for the purpose of formatting the data in this &#39;</span>
                    <span class="s">&#39;column.&#39;</span><span class="o">%</span> <span class="n">start</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                <span class="k">pass</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s">&#39;Column start option (TBCOLn) must be a positive integer &#39;</span>
                    <span class="s">&#39;(got </span><span class="si">%r</span><span class="s">).  The invalid value will be ignored for the &#39;</span>
                    <span class="s">&#39;purpose of formatting the data in this column.&#39;</span> <span class="o">%</span> <span class="n">start</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">valid</span><span class="p">[</span><span class="s">&#39;start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">start</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalid</span><span class="p">[</span><span class="s">&#39;start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="c"># Process TDIMn options</span>
        <span class="c"># ASCII table columns can&#39;t have a TDIMn keyword associated with it;</span>
        <span class="c"># for now we just issue a warning and ignore it.</span>
        <span class="c"># TODO: This should be checked by the FITS verification code</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">dim</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="n">dims_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>
            <span class="c"># NOTE: If valid, the dim keyword&#39;s value in the the valid dict is</span>
            <span class="c"># a tuple, not the original string; if invalid just the original</span>
            <span class="c"># string is returned</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">):</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s">&#39;Column dim option (TDIMn) is not allowed for ASCII table &#39;</span>
                    <span class="s">&#39;columns (got </span><span class="si">%r</span><span class="s">).  The invalid keyword will be ignored &#39;</span>
                    <span class="s">&#39;for the purpose of formatting this column.&#39;</span> <span class="o">%</span> <span class="n">dim</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">dims_tuple</span> <span class="o">=</span> <span class="n">_parse_tdim</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">dims_tuple</span> <span class="o">=</span> <span class="n">dim</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s">&quot;`dim` argument must be a string containing a valid value &quot;</span>
                    <span class="s">&quot;for the TDIMn header keyword associated with this column, &quot;</span>
                    <span class="s">&quot;or a tuple containing the C-order dimensions for the &quot;</span>
                    <span class="s">&quot;column.  The invalid value will be ignored for the purpose &quot;</span>
                    <span class="s">&quot;of formatting this column.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dims_tuple</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="n">dims_tuple</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">format</span><span class="o">.</span><span class="n">repeat</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="s">&quot;The repeat count of the column format </span><span class="si">%r</span><span class="s"> for column </span><span class="si">%r</span><span class="s"> &quot;</span>
                        <span class="s">&quot;is fewer than the number of elements per the TDIM &quot;</span>
                        <span class="s">&quot;argument </span><span class="si">%r</span><span class="s">.  The invalid TDIMn value will be ignored &quot;</span>
                        <span class="s">&quot;for the purpose of formatting this column.&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">msg</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">valid</span><span class="p">[</span><span class="s">&#39;dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dims_tuple</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalid</span><span class="p">[</span><span class="s">&#39;dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">valid</span><span class="p">,</span> <span class="n">invalid</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_determine_formats</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">ascii</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a format string and whether or not the Column is for an</span>
<span class="sd">        ASCII table (ascii=None means unspecified, but lean toward binary table</span>
<span class="sd">        where ambiguous) create an appropriate _BaseColumnFormat instance for</span>
<span class="sd">        the column&#39;s format, and determine the appropriate recarray format.</span>

<span class="sd">        The values of the start and dim keyword arguments are also useful, as</span>
<span class="sd">        the former is only valid for ASCII tables and the latter only for</span>
<span class="sd">        BINARY tables.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># If the given format string is unambiguously a Numpy dtype or one of</span>
        <span class="c"># the Numpy record format type specifiers supported by PyFITS then that</span>
        <span class="c"># should take priority--otherwise assume it is a FITS format</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">format</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_dtype_to_recformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>

        <span class="c"># check format</span>
        <span class="k">if</span> <span class="n">ascii</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_BaseColumnFormat</span><span class="p">):</span>
            <span class="c"># We&#39;re just give a string which could be either a Numpy format</span>
            <span class="c"># code, or a format for a binary column array *or* a format for an</span>
            <span class="c"># ASCII column array--there may be many ambiguities here.  Try our</span>
            <span class="c"># best to guess what the user intended.</span>
            <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_guess_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">ascii</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_BaseColumnFormat</span><span class="p">):</span>
            <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_ColumnFormat</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ascii</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">):</span>
            <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span>
                                                    <span class="n">_AsciiColumnFormat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># The format is already acceptable and unambiguous</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="n">recformat</span>

        <span class="k">return</span> <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_guess_format</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">dim</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">dim</span><span class="p">:</span>
            <span class="c"># This is impossible; this can&#39;t be a valid FITS column</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;Columns cannot have both a start (TCOLn) and dim &#39;</span>
                <span class="s">&#39;(TDIMn) option, since the former is only applies to &#39;</span>
                <span class="s">&#39;ASCII tables, and the latter is only valid for binary &#39;</span>
                <span class="s">&#39;tables.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">start</span><span class="p">:</span>
            <span class="c"># Only ASCII table columns can have a &#39;start&#39; option</span>
            <span class="n">guess_format</span> <span class="o">=</span> <span class="n">_AsciiColumnFormat</span>
        <span class="k">elif</span> <span class="n">dim</span><span class="p">:</span>
            <span class="c"># Only binary tables can have a dim option</span>
            <span class="n">guess_format</span> <span class="o">=</span> <span class="n">_ColumnFormat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If the format is *technically* a valid binary column format</span>
            <span class="c"># (i.e. it has a valid format code followed by arbitrary</span>
            <span class="c"># &quot;optional&quot; codes), but it is also strictly a valid ASCII</span>
            <span class="c"># table format, then assume an ASCII table column was being</span>
            <span class="c"># requested (the more likely case, after all).</span>
            <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="n">VerifyError</span><span class="p">):</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">_AsciiColumnFormat</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

            <span class="c"># A safe guess which reflects the existing behavior of previous</span>
            <span class="c"># PyFITS versions</span>
            <span class="n">guess_format</span> <span class="o">=</span> <span class="n">_ColumnFormat</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">guess_format</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">VerifyError</span><span class="p">:</span>
            <span class="c"># For whatever reason our guess was wrong (for example if we got</span>
            <span class="c"># just &#39;F&#39; that&#39;s not a valid binary format, but it an ASCII format</span>
            <span class="c"># code albeit with the width/precision omitted</span>
            <span class="n">guess_format</span> <span class="o">=</span> <span class="p">(</span><span class="n">_AsciiColumnFormat</span>
                            <span class="k">if</span> <span class="n">guess_format</span> <span class="ow">is</span> <span class="n">_ColumnFormat</span>
                            <span class="k">else</span> <span class="n">_ColumnFormat</span><span class="p">)</span>
            <span class="c"># If this fails too we&#39;re out of options--it is truly an invalid</span>
            <span class="c"># format, or at least not supported</span>
            <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_convert_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">guess_format</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">format</span><span class="p">,</span> <span class="n">recformat</span>

    <span class="k">def</span> <span class="nf">_convert_to_valid_data_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="c"># Convert the format to a type we understand</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Delayed</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">array</span>
        <span class="k">elif</span> <span class="n">array</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">array</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">format</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span>

            <span class="k">if</span> <span class="n">dims</span><span class="p">:</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="s">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">format</span> <span class="k">else</span> <span class="n">dims</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">),)</span> <span class="o">+</span> <span class="n">shape</span>
                <span class="n">array</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;P&#39;</span> <span class="ow">in</span> <span class="n">format</span> <span class="ow">or</span> <span class="s">&#39;Q&#39;</span> <span class="ow">in</span> <span class="n">format</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">array</span>
            <span class="k">elif</span> <span class="s">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">format</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">in</span> <span class="s">&#39;SU&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dims</span><span class="p">:</span>
                        <span class="c"># The &#39;last&#39; dimension (first in the order given</span>
                        <span class="c"># in the TDIMn keyword itself) is the number of</span>
                        <span class="c"># characters in each string</span>
                        <span class="n">fsize</span> <span class="o">=</span> <span class="n">dims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">fsize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">recformat</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>
                    <span class="k">return</span> <span class="n">chararray</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="n">fsize</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">_convert_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">recformat</span><span class="p">))</span>
            <span class="k">elif</span> <span class="s">&#39;L&#39;</span> <span class="ow">in</span> <span class="n">format</span><span class="p">:</span>
                <span class="c"># boolean needs to be scaled back to storage values (&#39;T&#39;, &#39;F&#39;)</span>
                <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;bool&#39;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">array</span> <span class="o">==</span> <span class="bp">False</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">array</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">),</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">))</span>
            <span class="k">elif</span> <span class="s">&#39;X&#39;</span> <span class="ow">in</span> <span class="n">format</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_convert_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint8&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Preserve byte order of the original array for now; see #77</span>
                <span class="n">numpy_format</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">+</span> <span class="n">format</span><span class="o">.</span><span class="n">recformat</span>

                <span class="c"># Handle arrays passed in as unsigned ints as pseudo-unsigned</span>
                <span class="c"># int arrays; blatantly tacked in here for now--we need columns</span>
                <span class="c"># to have explicit knowledge of whether they treated as</span>
                <span class="c"># pseudo-unsigned</span>
                <span class="n">bzeros</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="mi">4</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">),</span>
                          <span class="mi">8</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="p">)}</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;u&#39;</span> <span class="ow">and</span>
                        <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span> <span class="ow">in</span> <span class="n">bzeros</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bscale</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">bzero</span> <span class="o">==</span> <span class="n">bzeros</span><span class="p">[</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">]):</span>
                    <span class="c"># Basically the array is uint, has scale == 1.0, and the</span>
                    <span class="c"># bzero is the appropriate value for a pseudo-unsigned</span>
                    <span class="c"># integer of the input dtype, then go ahead and assume that</span>
                    <span class="c"># uint is assumed</span>
                    <span class="n">numpy_format</span> <span class="o">=</span> <span class="n">numpy_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;i&#39;</span><span class="p">,</span> <span class="s">&#39;u&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_pseudo_unsigned_ints</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="c"># The .base here means we&#39;re dropping the shape information,</span>
                <span class="c"># which is only used to format recarray fields, and is not</span>
                <span class="c"># useful for converting input arrays to the correct data type</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">numpy_format</span><span class="p">)</span><span class="o">.</span><span class="n">base</span>

                <span class="k">return</span> <span class="n">_convert_array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="ColDefs"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs">[docs]</a><span class="k">class</span> <span class="nc">ColDefs</span><span class="p">(</span><span class="n">NotifierMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Column definitions class.</span>

<span class="sd">    It has attributes corresponding to the `Column` attributes</span>
<span class="sd">    (e.g. `ColDefs` has the attribute ``names`` while `Column`</span>
<span class="sd">    has ``name``). Each attribute in `ColDefs` is a list of</span>
<span class="sd">    corresponding attribute values from all `Column` objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_padding_byte</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\x00</span><span class="s">&#39;</span>
    <span class="n">_col_format_cls</span> <span class="o">=</span> <span class="n">_ColumnFormat</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">tbtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ascii</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">tbtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s">&#39;The ``tbtype`` argument to `ColDefs` is deprecated as of &#39;</span>
                <span class="s">&#39;Astropy 0.4; instead the appropriate table type should be &#39;</span>
                <span class="s">&#39;inferred from the formats of the supplied columns.  Use the &#39;</span>
                <span class="s">&#39;``ascii=True`` argument to ensure that ASCII table columns &#39;</span>
                <span class="s">&#39;are used.&#39;</span><span class="p">,</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tbtype</span> <span class="o">=</span> <span class="s">&#39;BinTableHDU&#39;</span>  <span class="c"># The old default</span>

        <span class="c"># Backwards-compat support</span>
        <span class="c"># TODO: Remove once the tbtype argument is removed entirely</span>
        <span class="k">if</span> <span class="n">tbtype</span> <span class="o">==</span> <span class="s">&#39;BinTableHDU&#39;</span><span class="p">:</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">cls</span>
        <span class="k">elif</span> <span class="n">tbtype</span> <span class="o">==</span> <span class="s">&#39;TableHDU&#39;</span><span class="p">:</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">_AsciiColDefs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Invalid table type: </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">tbtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s">&#39;_columns_type&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">)):</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">_columns_type</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s">&#39;_col_format_cls&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">issubclass</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">_col_format_cls</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">)):</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">_AsciiColDefs</span>

        <span class="k">if</span> <span class="n">ascii</span><span class="p">:</span>  <span class="c"># force ASCII if this has been explicitly requested</span>
            <span class="n">klass</span> <span class="o">=</span> <span class="n">_AsciiColDefs</span>

        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getnewargs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_arrays</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">tbtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ascii</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        input : sequence of `Column`, `ColDefs`, other</span>
<span class="sd">            An existing table HDU, an existing `ColDefs`, or any multi-field</span>
<span class="sd">            Numpy array or `numpy.recarray`.</span>

<span class="sd">        **(Deprecated)** tbtype : str, optional</span>
<span class="sd">            which table HDU, ``&quot;BinTableHDU&quot;`` (default) or</span>
<span class="sd">            ``&quot;TableHDU&quot;`` (text table).</span>
<span class="sd">            Now ColDefs for a normal (binary) table by default, but converted</span>
<span class="sd">            automatically to ASCII table ColDefs in the appropriate contexts</span>
<span class="sd">            (namely, when creating an ASCII table).</span>

<span class="sd">        ascii : bool</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.hdu.table</span> <span class="kn">import</span> <span class="n">_TableBaseHDU</span>
        <span class="kn">from</span> <span class="nn">.fitsrec</span> <span class="kn">import</span> <span class="n">FITS_rec</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_coldefs</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">FITS_rec</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="s">&#39;_coldefs&#39;</span><span class="p">)</span> <span class="ow">and</span>
                <span class="nb">input</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">):</span>
            <span class="c"># If given a FITS_rec object we can directly copy its columns, but</span>
            <span class="c"># only if its columns have already been defined, otherwise this</span>
            <span class="c"># will loop back in on itself and blow up</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_coldefs</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">input</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Construct columns from the fields of a record array</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_array</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">isiterable</span><span class="p">(</span><span class="nb">input</span><span class="p">):</span>
            <span class="c"># if the input is a list of Columns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_sequence</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">_TableBaseHDU</span><span class="p">):</span>
            <span class="c"># Construct columns from fields in an HDU header</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_table</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Input to ColDefs must be a table HDU, a list &#39;</span>
                            <span class="s">&#39;of Columns, or a record/field array.&#39;</span><span class="p">)</span>

        <span class="c"># Listen for changes on all columns</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_coldefs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coldefs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Initialize from an existing ColDefs object (just copy the</span>
<span class="sd">        columns and convert their formats if necessary).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_copy_column</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">coldefs</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_init_from_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&#39;Element </span><span class="si">%d</span><span class="s"> in the ColDefs input is not a Column.&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_from_coldefs</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)):</span>
            <span class="n">cname</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">ftype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">cname</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_format_cls</span><span class="o">.</span><span class="n">from_recformat</span><span class="p">(</span><span class="n">ftype</span><span class="p">)</span>

            <span class="c"># Determine the appropriate dimensions for items in the column</span>
            <span class="c"># (typically just 1D)</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dim</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="s">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">format</span><span class="p">):</span>
                <span class="k">if</span> <span class="s">&#39;A&#39;</span> <span class="ow">in</span> <span class="n">format</span><span class="p">:</span>
                    <span class="c"># n x m string arrays must include the max string</span>
                    <span class="c"># length in their dimensions (e.g. l x n x m)</span>
                    <span class="n">dim</span> <span class="o">=</span> <span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,)</span> <span class="o">+</span> <span class="n">dim</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="c"># Check for unsigned ints.</span>
            <span class="n">bzero</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="s">&#39;I&#39;</span> <span class="ow">in</span> <span class="n">format</span> <span class="ow">and</span> <span class="n">ftype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint16&#39;</span><span class="p">):</span>
                <span class="n">bzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s">&#39;J&#39;</span> <span class="ow">in</span> <span class="n">format</span> <span class="ow">and</span> <span class="n">ftype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint32&#39;</span><span class="p">):</span>
                <span class="n">bzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s">&#39;K&#39;</span> <span class="ow">in</span> <span class="n">format</span> <span class="ow">and</span> <span class="n">ftype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint64&#39;</span><span class="p">):</span>
                <span class="n">bzero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="p">)</span>

            <span class="n">c</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">cname</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">format</span><span class="p">,</span>
                       <span class="n">array</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)[</span><span class="n">cname</span><span class="p">],</span> <span class="n">bzero</span><span class="o">=</span><span class="n">bzero</span><span class="p">,</span>
                       <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_init_from_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">):</span>
        <span class="n">hdr</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">_header</span>
        <span class="n">nfields</span> <span class="o">=</span> <span class="n">hdr</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span>

        <span class="c"># go through header keywords to pick out column definition keywords</span>
        <span class="c"># definition dictionaries for each field</span>
        <span class="n">col_keywords</span> <span class="o">=</span> <span class="p">[{}</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfields</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">hdr</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">TDEF_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>  <span class="c"># skip if there is no match</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">KEYWORD_NAMES</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="n">nfields</span> <span class="ow">and</span> <span class="n">col</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">attr</span> <span class="o">=</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s">&#39;format&#39;</span><span class="p">:</span>
                        <span class="c"># Go ahead and convert the format value to the</span>
                        <span class="c"># appropriate ColumnFormat container now</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_format_cls</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="n">col_keywords</span><span class="p">[</span><span class="n">col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="c"># Verify the column keywords and display any warnings if necessary;</span>
        <span class="c"># we only want to pass on the valid keywords</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">kwargs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">col_keywords</span><span class="p">):</span>
            <span class="n">valid_kwargs</span><span class="p">,</span> <span class="n">invalid_kwargs</span> <span class="o">=</span> <span class="n">Column</span><span class="o">.</span><span class="n">_verify_keywords</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">invalid_kwargs</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;Invalid keyword for column </span><span class="si">%d</span><span class="s">: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">VerifyWarning</span><span class="p">)</span>
            <span class="c"># Special cases for recformat and dim</span>
            <span class="c"># TODO: Try to eliminate the need for these special cases</span>
            <span class="k">del</span> <span class="n">valid_kwargs</span><span class="p">[</span><span class="s">&#39;recformat&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="s">&#39;dim&#39;</span> <span class="ow">in</span> <span class="n">valid_kwargs</span><span class="p">:</span>
                <span class="n">valid_kwargs</span><span class="p">[</span><span class="s">&#39;dim&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s">&#39;dim&#39;</span><span class="p">]</span>
            <span class="n">col_keywords</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">valid_kwargs</span>

        <span class="c"># data reading will be delayed</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfields</span><span class="p">):</span>
            <span class="n">col_keywords</span><span class="p">[</span><span class="n">col</span><span class="p">][</span><span class="s">&#39;array&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Delayed</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c"># now build the columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">Column</span><span class="p">(</span><span class="o">**</span><span class="n">attrs</span><span class="p">)</span> <span class="k">for</span> <span class="n">attrs</span> <span class="ow">in</span> <span class="n">col_keywords</span><span class="p">]</span>

        <span class="c"># Add the table HDU is a listener to changes to the columns</span>
        <span class="c"># (either changes to individual columns, or changes to the set of</span>
        <span class="c"># columns (add/remove/etc.))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_copy_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Utility function used currently only by _init_from_coldefs</span>
<span class="sd">        to help convert columns from binary format to ASCII format or vice</span>
<span class="sd">        versa if necessary (otherwise performs a straight copy).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_format_cls</span><span class="p">):</span>
            <span class="c"># This column has a FITS format compatible with this column</span>
            <span class="c"># definitions class (that is ascii or binary)</span>
            <span class="k">return</span> <span class="n">column</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">new_column</span> <span class="o">=</span> <span class="n">column</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># Try to use the Numpy recformat as the equivalency between the</span>
        <span class="c"># two formats; if that conversion can&#39;t be made then these</span>
        <span class="c"># columns can&#39;t be transferred</span>
        <span class="c"># TODO: Catch exceptions here and raise an explicit error about</span>
        <span class="c"># column format conversion</span>
        <span class="n">new_column</span><span class="o">.</span><span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_col_format_cls</span><span class="o">.</span><span class="n">from_column_format</span><span class="p">(</span>
                <span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>

        <span class="c"># Handle a few special cases of column format options that are not</span>
        <span class="c"># compatible between ASCII an binary tables</span>
        <span class="c"># TODO: This is sort of hacked in right now; we really need</span>
        <span class="c"># separate classes for ASCII and Binary table Columns, and they</span>
        <span class="c"># should handle formatting issues like these</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_column</span><span class="o">.</span><span class="n">format</span><span class="p">,</span> <span class="n">_AsciiColumnFormat</span><span class="p">):</span>
            <span class="c"># the column is a binary table column...</span>
            <span class="n">new_column</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">if</span> <span class="n">new_column</span><span class="o">.</span><span class="n">null</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># We can&#39;t just &quot;guess&quot; a value to represent null</span>
                <span class="c"># values in the new column, so just disable this for</span>
                <span class="c"># now; users may modify it later</span>
                <span class="n">new_column</span><span class="o">.</span><span class="n">null</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># the column is an ASCII table column...</span>
            <span class="k">if</span> <span class="n">new_column</span><span class="o">.</span><span class="n">null</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">new_column</span><span class="o">.</span><span class="n">null</span> <span class="o">=</span> <span class="n">DEFAULT_ASCII_TNULL</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">new_column</span><span class="o">.</span><span class="n">disp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                    <span class="n">new_column</span><span class="o">.</span><span class="n">disp</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;L&#39;</span><span class="p">)):</span>
                <span class="c"># ASCII columns may not use the logical data display format;</span>
                <span class="c"># for now just drop the TDISPn option for this column as we</span>
                <span class="c"># don&#39;t have a systematic conversion of boolean data to ASCII</span>
                <span class="c"># tables yet</span>
                <span class="n">new_column</span><span class="o">.</span><span class="n">disp</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">return</span> <span class="n">new_column</span>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically returns the values for the given keyword attribute for</span>
<span class="sd">        all `Column`s in this list.</span>

<span class="sd">        Implements for example self.units, self.formats, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cname</span> <span class="o">=</span> <span class="n">name</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">cname</span> <span class="ow">in</span> <span class="n">KEYWORD_ATTRIBUTES</span> <span class="ow">and</span> <span class="n">name</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">cname</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">attr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">attr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">attr</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Note: This previously returned a dtype that just used the raw field</span>
        <span class="c"># widths based on the format&#39;s repeat count, and did not incorporate</span>
        <span class="c"># field *shapes* as provided by TDIMn keywords.</span>
        <span class="c"># Now this incorporates TDIMn from the start, which makes *this* method</span>
        <span class="c"># a little more complicated, but simplifies code elsewhere (for example</span>
        <span class="c"># fields will have the correct shapes even in the raw recarray).</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">format_</span><span class="p">,</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span><span class="p">):</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">format_</span><span class="o">.</span><span class="n">dtype</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">offsets</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">):</span>
                <span class="c"># Note: the size of the *original* format_ may be greater than</span>
                <span class="c"># one would expect from the number of elements determined by</span>
                <span class="c"># dim.  The FITS format allows this--the rest of the field is</span>
                <span class="c"># filled with undefined values.</span>
                <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">offsets</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">dt</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dim</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">format_</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">dt</span><span class="o">.</span><span class="n">char</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">dim</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dim</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">((</span><span class="n">dt</span><span class="o">.</span><span class="n">base</span><span class="p">,</span> <span class="n">dim</span><span class="p">))</span>

            <span class="n">fields</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">dt</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">nh</span><span class="o">.</span><span class="n">realign_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">fields</span><span class="p">),</span> <span class="n">offsets</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">_arrays</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">_recformats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">fmt</span><span class="o">.</span><span class="n">recformat</span> <span class="k">for</span> <span class="n">fmt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">formats</span><span class="p">]</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the values of the TDIMn keywords parsed into tuples.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">col</span><span class="o">.</span><span class="n">_dims</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">_get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>

        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="s">&#39;ColDefs(&#39;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;columns&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c"># The hasattr check is mostly just useful in debugging sessions</span>
            <span class="c"># where self.columns may not be defined yet</span>
            <span class="n">rep</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">    &#39;</span>
            <span class="n">rep</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">    &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">])</span>
            <span class="n">rep</span> <span class="o">+=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
        <span class="n">rep</span> <span class="o">+=</span> <span class="s">&#39;)&#39;</span>
        <span class="k">return</span> <span class="n">rep</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;left&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Column</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Wrong type of input.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="s">&#39;left&#39;</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__add__</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;right&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span>
        <span class="n">_other</span> <span class="o">=</span> <span class="p">[</span><span class="n">_get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">other</span><span class="p">]</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">_other</span><span class="p">:</span>
            <span class="n">indx</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indx</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_column_attribute_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">old_value</span><span class="p">,</span>
                                         <span class="n">new_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handle column attribute changed notifications from columns that are</span>
<span class="sd">        members of this `ColDefs`.</span>

<span class="sd">        `ColDefs` itself does not currently do anything with this, and just</span>
<span class="sd">        bubbles the notification up to any listening table HDUs that may need</span>
<span class="sd">        to update their headers, etc.  However, this also informs the table of</span>
<span class="sd">        the numerical index of the column that changed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">is</span> <span class="n">column</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_notify</span><span class="p">(</span><span class="s">&#39;column_attribute_changed&#39;</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">old_value</span><span class="p">,</span>
                     <span class="n">new_value</span><span class="p">)</span>

<div class="viewcode-block" id="ColDefs.add_col"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs.add_col">[docs]</a>    <span class="k">def</span> <span class="nf">add_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append one `Column` to the column definition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">Column</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">array</span><span class="p">)</span>
        <span class="c"># Obliterate caches of certain things</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recformats</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>

        <span class="c"># Listen for changes on the new column</span>
        <span class="n">column</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># If this ColDefs is being tracked by a Table, inform the</span>
        <span class="c"># table that its data is now invalid.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_notify</span><span class="p">(</span><span class="s">&#39;column_added&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="ColDefs.del_col"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs.del_col">[docs]</a>    <span class="k">def</span> <span class="nf">del_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete (the definition of) one `Column`.</span>

<span class="sd">        col_name : str or int</span>
<span class="sd">            The column&#39;s name or index</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">indx</span> <span class="o">=</span> <span class="n">_get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_arrays</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="c"># Obliterate caches of certain things</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recformats</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dims</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>

        <span class="n">col</span><span class="o">.</span><span class="n">_remove_listener</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c"># If this ColDefs is being tracked by a table HDU, inform the HDU (or</span>
        <span class="c"># any other listeners) that the column has been removed</span>
        <span class="c"># Just send a reference to self, and the index of the column that was</span>
        <span class="c"># removed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_notify</span><span class="p">(</span><span class="s">&#39;column_removed&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</div>
<div class="viewcode-block" id="ColDefs.change_attrib"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs.change_attrib">[docs]</a>    <span class="k">def</span> <span class="nf">change_attrib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change an attribute (in the ``KEYWORD_ATTRIBUTES`` list) of a `Column`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col_name : str or int</span>
<span class="sd">            The column name or index to change</span>

<span class="sd">        attrib : str</span>
<span class="sd">            The attribute name</span>

<span class="sd">        new_value : object</span>
<span class="sd">            The new value for the attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">col_name</span><span class="p">],</span> <span class="n">attrib</span><span class="p">,</span> <span class="n">new_value</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ColDefs.change_name"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs.change_name">[docs]</a>    <span class="k">def</span> <span class="nf">change_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change a `Column`&#39;s name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col_name : str</span>
<span class="sd">            The current name of the column</span>

<span class="sd">        new_name : str</span>
<span class="sd">            The new name of the column</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">new_name</span> <span class="o">!=</span> <span class="n">col_name</span> <span class="ow">and</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;New name </span><span class="si">%s</span><span class="s"> already exists.&#39;</span> <span class="o">%</span> <span class="n">new_name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_attrib</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ColDefs.change_unit"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs.change_unit">[docs]</a>    <span class="k">def</span> <span class="nf">change_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change a `Column`&#39;s unit.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        col_name : str or int</span>
<span class="sd">            The column name or index</span>

<span class="sd">        new_unit : str</span>
<span class="sd">            The new unit for the column</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">change_attrib</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="s">&#39;unit&#39;</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="ColDefs.info"><a class="viewcode-back" href="../../../../io/fits/api/tables.html#astropy.io.fits.ColDefs.info">[docs]</a>    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="o">=</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="n">output</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get attribute(s) information of the column definition.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        attrib : str</span>
<span class="sd">            Can be one or more of the attributes listed in</span>
<span class="sd">            ``astropy.io.fits.column.KEYWORD_ATTRIBUTES``.  The default is</span>
<span class="sd">            ``&quot;all&quot;`` which will print out all attributes.  It forgives plurals</span>
<span class="sd">            and blanks.  If there are two or more attribute names, they must be</span>
<span class="sd">            separated by comma(s).</span>

<span class="sd">        output : file, optional</span>
<span class="sd">            File-like object to output to.  Outputs to stdout by default.</span>
<span class="sd">            If `False`, returns the attributes as a `dict` instead.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function doesn&#39;t return anything by default; it just prints to</span>
<span class="sd">        stdout.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">output</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>

        <span class="k">if</span> <span class="n">attrib</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">]:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">KEYWORD_ATTRIBUTES</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">attrib</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)):</span>
                <span class="n">lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">lst</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;s&#39;</span><span class="p">:</span>
                    <span class="n">lst</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">idx</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">lst</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">output</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">attr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">KEYWORD_ATTRIBUTES</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; is not an attribute of the column &quot;</span>
                                 <span class="s">&quot;definitions.</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">attr</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">:</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">attr</span><span class="p">)</span>
                <span class="n">output</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;    </span><span class="si">%s</span><span class="se">\n</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span> <span class="o">+</span> <span class="s">&#39;s&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span> <span class="o">+</span> <span class="s">&#39;s&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">output</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>

</div></div>
<span class="k">class</span> <span class="nc">_AsciiColDefs</span><span class="p">(</span><span class="n">ColDefs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;ColDefs implementation for ASCII tables.&quot;&quot;&quot;</span>

    <span class="n">_padding_byte</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
    <span class="n">_col_format_cls</span> <span class="o">=</span> <span class="n">_AsciiColumnFormat</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">tbtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ascii</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_AsciiColDefs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span>

        <span class="c"># if the format of an ASCII column has no width, add one</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">_AsciiColDefs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_field_metrics</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">input</span><span class="o">.</span><span class="n">starts</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">s</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_spans</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">spans</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">=</span> <span class="nb">input</span><span class="o">.</span><span class="n">_width</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_itemsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            <span class="n">dtype</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">spans</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A list of the widths of each field in the table.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_spans</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">_recformats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">pairwise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">)]</span>

        <span class="c"># Widths is the width of each field *including* any space between</span>
        <span class="c"># fields; this is so that we can map the fields to string records in a</span>
        <span class="c"># Numpy recarray</span>
        <span class="n">widths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="s">&#39;a&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">add_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_AsciiColDefs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">add_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_field_metrics</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">del_col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col_name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_AsciiColDefs</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">del_col</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_field_metrics</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_field_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the list of the start columns, the list of the widths of each</span>
<span class="sd">        field, and the total width of each record in the table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">spans</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">end_col</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># Refers to the ASCII text column, not the table col</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">format</span><span class="o">.</span><span class="n">width</span>

            <span class="c"># Update the start columns and column span widths taking into</span>
            <span class="c"># account the case that the starting column of a field may not</span>
            <span class="c"># be the column immediately after the previous field</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">col</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="n">col</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">end_col</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">end_col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">width</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">spans</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">width</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_spans</span> <span class="o">=</span> <span class="n">spans</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_width</span> <span class="o">=</span> <span class="n">end_col</span>


<span class="c"># Utilities</span>


<span class="k">class</span> <span class="nc">_VLF</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Variable length field object.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;a&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        input</span>
<span class="sd">            a sequence of variable-sized elements.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># this handles [&#39;abc&#39;] and [[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;]]</span>
                <span class="c"># equally, beautiful!</span>
                <span class="nb">input</span> <span class="o">=</span> <span class="p">[</span><span class="n">chararray</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">input</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;Inconsistent input data array: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">input</span><span class="p">))</span>

        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">input</span><span class="p">),),</span> <span class="nb">buffer</span><span class="o">=</span><span class="n">a</span><span class="p">,</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">element_dtype</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">element_dtype</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        To make sure the new item has consistent data type to avoid</span>
<span class="sd">        misalignment.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">chararray</span><span class="o">.</span><span class="n">chararray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_dtype</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">chararray</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">itemsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">element_dtype</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_get_index</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the index of the ``key`` in the ``names`` list.</span>

<span class="sd">    The ``key`` can be an integer or string.  If integer, it is the index</span>
<span class="sd">    in the list.  If string,</span>

<span class="sd">        a. Field (column) names are case sensitive: you can have two</span>
<span class="sd">           different columns called &#39;abc&#39; and &#39;ABC&#39; respectively.</span>

<span class="sd">        b. When you *refer* to a field (presumably with the field</span>
<span class="sd">           method), it will try to match the exact name first, so in</span>
<span class="sd">           the example in (a), field(&#39;abc&#39;) will get the first field,</span>
<span class="sd">           and field(&#39;ABC&#39;) will get the second field.</span>

<span class="sd">        If there is no exact name matched, it will try to match the</span>
<span class="sd">        name with case insensitivity.  So, in the last example,</span>
<span class="sd">        field(&#39;Abc&#39;) will cause an exception since there is no unique</span>
<span class="sd">        mapping.  If there is a field named &quot;XYZ&quot; and no other field</span>
<span class="sd">        name is a case variant of &quot;XYZ&quot;, then field(&#39;xyz&#39;),</span>
<span class="sd">        field(&#39;Xyz&#39;), etc. will get this field.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="c"># try to find exact match first</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c"># try to match case-insentively,</span>
            <span class="n">_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">_key</span><span class="p">)</span>  <span class="c"># occurrence of _key in names</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">indx</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">_key</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Key &#39;</span><span class="si">%s</span><span class="s">&#39; does not exist.&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>              <span class="c"># multiple match</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Ambiguous key name &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Illegal key &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">indx</span>


<span class="k">def</span> <span class="nf">_unwrapx</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">repeat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unwrap the X format column into a Boolean array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input</span>
<span class="sd">        input ``Uint8`` array of shape (`s`, `nbytes`)</span>

<span class="sd">    output</span>
<span class="sd">        output Boolean array of shape (`s`, `repeat`)</span>

<span class="sd">    repeat</span>
<span class="sd">        number of bits</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">pow2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">128</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;uint8&#39;</span><span class="p">)</span>
    <span class="n">nbytes</span> <span class="o">=</span> <span class="p">((</span><span class="n">repeat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbytes</span><span class="p">):</span>
        <span class="n">_min</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="n">_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">repeat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_min</span><span class="p">,</span> <span class="n">_max</span><span class="p">):</span>
            <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="nb">input</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">pow2</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_wrapx</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">output</span><span class="p">,</span> <span class="n">repeat</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap the X format column Boolean array into an ``UInt8`` array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input</span>
<span class="sd">        input Boolean array of shape (`s`, `repeat`)</span>

<span class="sd">    output</span>
<span class="sd">        output ``Uint8`` array of shape (`s`, `nbytes`)</span>

<span class="sd">    repeat</span>
<span class="sd">        number of bits</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># reset the output</span>
    <span class="n">nbytes</span> <span class="o">=</span> <span class="p">((</span><span class="n">repeat</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">unused</span> <span class="o">=</span> <span class="n">nbytes</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">-</span> <span class="n">repeat</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbytes</span><span class="p">):</span>
        <span class="n">_min</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span>
        <span class="n">_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">,</span> <span class="n">repeat</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">_min</span><span class="p">,</span> <span class="n">_max</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">!=</span> <span class="n">_min</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="nb">input</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>

    <span class="c"># shift the unused bits</span>
    <span class="n">np</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="n">unused</span><span class="p">,</span> <span class="n">output</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">_makep</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">descr_output</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct the P (or Q) format column array, both the data descriptors and</span>
<span class="sd">    the data.  It returns the output &quot;data&quot; array of data type `dtype`.</span>

<span class="sd">    The descriptor location will have a zero offset for all columns</span>
<span class="sd">    after this call.  The final offset will be calculated when the file</span>
<span class="sd">    is written.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array</span>
<span class="sd">        input object array</span>

<span class="sd">    descr_output</span>
<span class="sd">        output &quot;descriptor&quot; array of data type int32 (for P format arrays) or</span>
<span class="sd">        int64 (for Q format arrays)--must be nrows long in its first dimension</span>

<span class="sd">    format</span>
<span class="sd">        the _FormatP object representing the format of the variable array</span>

<span class="sd">    nrows : int, optional</span>
<span class="sd">        number of rows to create in the column; defaults to the number of rows</span>
<span class="sd">        in the input array</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># TODO: A great deal of this is redundant with FITS_rec._convert_p; see if</span>
    <span class="c"># we can merge the two somehow.</span>

    <span class="n">_offset</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">nrows</span><span class="p">:</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">),</span> <span class="n">nrows</span><span class="p">)</span>

    <span class="n">data_output</span> <span class="o">=</span> <span class="n">_VLF</span><span class="p">([</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">format</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
        <span class="n">_nbytes</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_nbytes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">format</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
            <span class="n">rowval</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
                <span class="n">rowval</span> <span class="o">=</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="n">data_output</span><span class="o">.</span><span class="n">max</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rowval</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">data_output</span><span class="o">.</span><span class="n">max</span>
        <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
            <span class="n">data_output</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">chararray</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">encode_ascii</span><span class="p">(</span><span class="n">rowval</span><span class="p">),</span>
                                               <span class="n">itemsize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data_output</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rowval</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">format</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">descr_output</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_output</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="n">descr_output</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">_offset</span>
        <span class="n">_offset</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_output</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="o">*</span> <span class="n">_nbytes</span>

    <span class="k">return</span> <span class="n">data_output</span>


<span class="k">def</span> <span class="nf">_parse_tformat</span><span class="p">(</span><span class="n">tform</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse ``TFORMn`` keyword for a binary table into a</span>
<span class="sd">    ``(repeat, format, option)`` tuple.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">option</span><span class="p">)</span> <span class="o">=</span> <span class="n">TFORMAT_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="c"># TODO: Maybe catch this error use a default type (bytes, maybe?) for</span>
        <span class="c"># unrecognized column types.  As long as we can determine the correct</span>
        <span class="c"># byte width somehow..</span>
        <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;Format </span><span class="si">%r</span><span class="s"> is not recognized.&#39;</span> <span class="o">%</span> <span class="n">tform</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">repeat</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">repeat</span><span class="p">,</span> <span class="n">format</span><span class="o">.</span><span class="n">upper</span><span class="p">(),</span> <span class="n">option</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_parse_ascii_tformat</span><span class="p">(</span><span class="n">tform</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parse the ``TFORMn`` keywords for ASCII tables into a ``(format, width,</span>
<span class="sd">    precision)`` tuple (the latter is always zero unless format is one of &#39;E&#39;,</span>
<span class="sd">    &#39;F&#39;, or &#39;D&#39;).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">match</span> <span class="o">=</span> <span class="n">TFORMAT_ASCII_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tform</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;Format </span><span class="si">%r</span><span class="s"> is not recognized.&#39;</span> <span class="o">%</span> <span class="n">tform</span><span class="p">)</span>

    <span class="c"># Be flexible on case</span>
    <span class="n">format</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;format&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">format</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c"># Floating point format</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;formatf&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;widthf&#39;</span><span class="p">)</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;precision&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">precision</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;Format </span><span class="si">%r</span><span class="s"> is not unambiguously an ASCII &#39;</span>
                                  <span class="s">&#39;table format.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">width</span>
                <span class="n">precision</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">precision</span> <span class="ow">is</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">precision</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">format</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;width&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">width</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&#39;Format </span><span class="si">%r</span><span class="s"> is not unambiguously an ASCII &#39;</span>
                                  <span class="s">&#39;table format.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Just use a default width of 0 if unspecified</span>
                <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">precision</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">convert_int</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Format </span><span class="si">%r</span><span class="s"> is not valid--field width and decimal precision &#39;</span>
               <span class="s">&#39;must be integers.&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="n">tform</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">val</span>

    <span class="k">if</span> <span class="n">width</span> <span class="ow">and</span> <span class="n">precision</span><span class="p">:</span>
        <span class="c"># This should only be the case for floating-point formats</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">width</span><span class="p">),</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">precision</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">width</span><span class="p">:</span>
        <span class="c"># Just for integer/string formats; ignore precision</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">convert_int</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># For any format, if width was unspecified use the set defaults</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">ASCII_DEFAULT_WIDTHS</span><span class="p">[</span><span class="n">format</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&quot;Format </span><span class="si">%r</span><span class="s"> not valid--field width must be a &quot;</span>
                          <span class="s">&quot;positive integeter.&quot;</span> <span class="o">%</span> <span class="n">tform</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">precision</span> <span class="o">&gt;=</span> <span class="n">width</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">VerifyError</span><span class="p">(</span><span class="s">&quot;Format </span><span class="si">%r</span><span class="s"> not valid--the number of decimal digits &quot;</span>
                          <span class="s">&quot;must be less than the format&#39;s total width </span><span class="si">%s</span><span class="s">.&quot;</span> <span class="o">&amp;</span>
                          <span class="p">(</span><span class="n">tform</span><span class="p">,</span> <span class="n">width</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">format</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">precision</span>


<span class="k">def</span> <span class="nf">_parse_tdim</span><span class="p">(</span><span class="n">tdim</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Parse the ``TDIM`` value into a tuple (may return an empty tuple if</span>
<span class="sd">    the value ``TDIM`` value is empty or invalid).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">tdim</span> <span class="ow">and</span> <span class="n">TDIM_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">tdim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;dims&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dims</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c"># Ignore any dim values that don&#39;t specify a multidimensional column</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_scalar_to_format</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a scalar value or string, returns the minimum FITS column format</span>
<span class="sd">    that can represent that value.  &#39;minimum&#39; is defined by the order given in</span>
<span class="sd">    FORMATORDER.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># TODO: Numpy 1.6 and up has a min_scalar_type() function that can handle</span>
    <span class="c"># this; in the meantime we have to use our own implementation (which for</span>
    <span class="c"># now is pretty naive)</span>

    <span class="c"># First, if value is a string, try to convert to the appropriate scalar</span>
    <span class="c"># value</span>
    <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">type_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">break</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">continue</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c"># Could be a boolean</span>
        <span class="k">return</span> <span class="s">&#39;L&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;I&#39;</span><span class="p">,</span> <span class="s">&#39;J&#39;</span><span class="p">,</span> <span class="s">&#39;K&#39;</span><span class="p">):</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">char</span><span class="p">])</span><span class="o">.</span><span class="n">type</span>
            <span class="k">if</span> <span class="n">type_</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">char</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="c"># For now just assume double precision</span>
        <span class="k">return</span> <span class="s">&#39;D&#39;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;M&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">&#39;A&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_cmp_recformats</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compares two numpy recformats using the ordering given by FORMATORDER.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span> <span class="ow">and</span> <span class="n">f2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">f1</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">f2</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">NUMPY2FITS</span><span class="p">[</span><span class="n">f1</span><span class="p">],</span> <span class="n">NUMPY2FITS</span><span class="p">[</span><span class="n">f2</span><span class="p">]</span>
        <span class="k">return</span> <span class="nb">cmp</span><span class="p">(</span><span class="n">FORMATORDER</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f1</span><span class="p">),</span> <span class="n">FORMATORDER</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">f2</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_convert_fits2record</span><span class="p">(</span><span class="n">format</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert FITS format spec to record format spec.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">repeat</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">option</span> <span class="o">=</span> <span class="n">_parse_tformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">FITS2NUMPY</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span><span class="p">:</span>
            <span class="n">output_format</span> <span class="o">=</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span>
            <span class="c"># to accommodate both the ASCII table and binary table column</span>
            <span class="c"># format spec, i.e. A7 in ASCII table is the same as 7A in</span>
            <span class="c"># binary table, so both will produce &#39;a7&#39;.</span>
            <span class="c"># Technically the FITS standard does not allow this but it&#39;s a very</span>
            <span class="c"># common mistake</span>
            <span class="k">if</span> <span class="n">format</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span> <span class="ow">and</span> <span class="n">option</span> <span class="o">!=</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="c"># make sure option is integer</span>
                <span class="n">output_format</span> <span class="o">=</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">option</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">repeat_str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">if</span> <span class="n">repeat</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">repeat_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span>
            <span class="n">output_format</span> <span class="o">=</span> <span class="n">repeat_str</span> <span class="o">+</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;X&#39;</span><span class="p">:</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">_FormatX</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;P&#39;</span><span class="p">:</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">_FormatP</span><span class="o">.</span><span class="n">from_tform</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;Q&#39;</span><span class="p">:</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">_FormatQ</span><span class="o">.</span><span class="n">from_tform</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">dtype</span> <span class="o">==</span> <span class="s">&#39;F&#39;</span><span class="p">:</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="s">&#39;f8&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Illegal format </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">format</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_format</span>


<span class="k">def</span> <span class="nf">_convert_record2fits</span><span class="p">(</span><span class="n">format</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert record format spec to FITS format spec.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">recformat</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype_to_recformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">itemsize</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>
    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s">&#39;U&#39;</span><span class="p">:</span>
        <span class="c"># Unicode dtype--itemsize is 4 times actual ASCII character length,</span>
        <span class="c"># which what matters for FITS column formats</span>
        <span class="c"># Use dtype.base--dtype may be a multi-dimensional dtype</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">itemsize</span> <span class="o">//</span> <span class="mi">4</span>

    <span class="n">option</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">itemsize</span><span class="p">)</span>

    <span class="n">ndims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">repeat</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ndims</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;i8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">nel</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="n">nel</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
        <span class="c"># This is a kludge that will place string arrays into a</span>
        <span class="c"># single field, so at least we won&#39;t lose data.  Need to</span>
        <span class="c"># use a TDIM keyword to fix this, declaring as (slength,</span>
        <span class="c"># dim1, dim2, ...)  as mwrfits does</span>

        <span class="n">ntot</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">option</span><span class="p">)</span>

        <span class="n">output_format</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">ntot</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;A&#39;</span>
    <span class="k">elif</span> <span class="n">recformat</span> <span class="ow">in</span> <span class="n">NUMPY2FITS</span><span class="p">:</span>  <span class="c"># record format</span>
        <span class="k">if</span> <span class="n">repeat</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">repeat</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="n">output_format</span> <span class="o">=</span> <span class="n">repeat</span> <span class="o">+</span> <span class="n">NUMPY2FITS</span><span class="p">[</span><span class="n">recformat</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Illegal format </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">format</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">output_format</span>


<span class="k">def</span> <span class="nf">_dtype_to_recformat</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Utility function for converting a dtype object or string that instantiates</span>
<span class="sd">    a dtype (e.g. &#39;float32&#39;) into one of the two character Numpy format codes</span>
<span class="sd">    that have been traditionally used by PyFITS.</span>

<span class="sd">    In particular, use of &#39;a&#39; to refer to character data is long since</span>
<span class="sd">    deprecated in Numpy, but PyFITS remains heavily invested in its use</span>
<span class="sd">    (something to try to get away from sooner rather than later).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

    <span class="n">kind</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">kind</span>

    <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;U&#39;</span><span class="p">,</span> <span class="s">&#39;S&#39;</span><span class="p">):</span>
        <span class="n">recformat</span> <span class="o">=</span> <span class="n">kind</span> <span class="o">=</span> <span class="s">&#39;a&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">itemsize</span>
        <span class="n">recformat</span> <span class="o">=</span> <span class="n">kind</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">itemsize</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">recformat</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">dtype</span>


<span class="k">def</span> <span class="nf">_convert_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert FITS format spec to record format spec.  Do the opposite if</span>
<span class="sd">    reverse=True.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_convert_record2fits</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_convert_fits2record</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_convert_ascii_format</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Convert ASCII table format spec to record format spec.&quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">reverse</span><span class="p">:</span>
        <span class="n">recformat</span><span class="p">,</span> <span class="n">kind</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">_dtype_to_recformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span>

        <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;A&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">itemsize</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">NUMPY2FITS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">recformat</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;L&#39;</span><span class="p">:</span>
            <span class="c"># Special case for logical/boolean types--for ASCII tables we</span>
            <span class="c"># represent these as single character columns containing &#39;T&#39; or &#39;F&#39;</span>
            <span class="c"># (a la the storage format for Logical columns in binary tables)</span>
            <span class="k">return</span> <span class="s">&#39;A1&#39;</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;i&#39;</span><span class="p">:</span>
            <span class="c"># Use for the width the maximum required to represent integers</span>
            <span class="c"># of that byte size plus 1 for signs, but use a minimum of the</span>
            <span class="c"># default width (to keep with existing behavior)</span>
            <span class="n">width</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="n">itemsize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)))</span>
            <span class="n">width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">ASCII_DEFAULT_WIDTHS</span><span class="p">[</span><span class="s">&#39;I&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="s">&#39;I&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;f&#39;</span><span class="p">:</span>
            <span class="c"># This is tricky, but go ahead and use D if float-64, and E</span>
            <span class="c"># if float-32 with their default widths</span>
            <span class="k">if</span> <span class="n">itemsize</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;D&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;E&#39;</span>
            <span class="n">width</span> <span class="o">=</span> <span class="s">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ASCII_DEFAULT_WIDTHS</span><span class="p">[</span><span class="n">format</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">format</span> <span class="o">+</span> <span class="n">width</span>
        <span class="c"># TODO: There may be reasonable ways to represent other Numpy types so</span>
        <span class="c"># let&#39;s see what other possibilities there are besides just &#39;a&#39;, &#39;i&#39;,</span>
        <span class="c"># and &#39;f&#39;.  If it doesn&#39;t have a reasonable ASCII representation then</span>
        <span class="c"># raise an exception</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">format</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="n">_parse_ascii_tformat</span><span class="p">(</span><span class="n">format</span><span class="p">)</span>

        <span class="c"># This gives a sensible &quot;default&quot; dtype for a given ASCII</span>
        <span class="c"># format code</span>
        <span class="n">recformat</span> <span class="o">=</span> <span class="n">ASCII2NUMPY</span><span class="p">[</span><span class="n">format</span><span class="p">]</span>

        <span class="c"># The following logic is taken from CFITSIO:</span>
        <span class="c"># For integers, if the width &lt;= 4 we can safely use 16-bit ints for all</span>
        <span class="c"># values [for the non-standard J format code just always force 64-bit]</span>
        <span class="k">if</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;I&#39;</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="s">&#39;i2&#39;</span>
        <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;F&#39;</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">7</span><span class="p">:</span>
            <span class="c"># 32-bit floats (the default) may not be accurate enough to support</span>
            <span class="c"># all values that can fit in this field, so upgrade to 64-bit</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="s">&#39;f8&#39;</span>
        <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;E&#39;</span> <span class="ow">and</span> <span class="n">precision</span> <span class="o">&gt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="c"># Again upgrade to a 64-bit int if we require greater decimal</span>
            <span class="c"># precision</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="s">&#39;f8&#39;</span>
        <span class="k">elif</span> <span class="n">format</span> <span class="o">==</span> <span class="s">&#39;A&#39;</span><span class="p">:</span>
            <span class="n">recformat</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">width</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">recformat</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1. &nbsp;
    Last built 12 May 2016. <br/>
  </p>
</footer>
  </body>
</html>