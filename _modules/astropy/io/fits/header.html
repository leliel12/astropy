<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.io.fits.header &mdash; Astropy v1.2.dev14999</title>
    
    <link rel="stylesheet" href="../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.2.dev14999',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.2.dev14999" href="../../../../index.html" />
    <link rel="up" title="Module code" href="../../../index.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../index.html">Astropy v1.2.dev14999</a>
	 &raquo;
      </li>
      <li><a href="../../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.io.fits.header</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>

<span class="kn">import</span> <span class="nn">collections</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.card</span> <span class="kn">import</span> <span class="n">Card</span><span class="p">,</span> <span class="n">CardList</span><span class="p">,</span> <span class="n">_pad</span><span class="p">,</span> <span class="n">KEYWORD_LENGTH</span>
<span class="kn">from</span> <span class="nn">.file</span> <span class="kn">import</span> <span class="n">_File</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">encode_ascii</span><span class="p">,</span> <span class="n">decode_ascii</span><span class="p">,</span> <span class="n">fileobj_closed</span><span class="p">,</span>
                   <span class="n">fileobj_is_binary</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">...extern</span> <span class="kn">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">...extern.six</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">itervalues</span><span class="p">,</span> <span class="n">iteritems</span><span class="p">,</span> <span class="nb">next</span>
<span class="kn">from</span> <span class="nn">...extern.six.moves</span> <span class="kn">import</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="n">zip_longest</span>
<span class="kn">from</span> <span class="nn">...utils</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">isiterable</span>
<span class="kn">from</span> <span class="nn">...utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span><span class="p">,</span> <span class="n">AstropyDeprecationWarning</span>


<span class="n">BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">2880</span>  <span class="c"># the FITS block size</span>

<span class="c"># This regular expression can match a *valid* END card which just consists of</span>
<span class="c"># the string &#39;END&#39; followed by all spaces, or an *invalid* end card which</span>
<span class="c"># consists of END, followed by any character that is *not* a valid character</span>
<span class="c"># for a valid FITS keyword (that is, this is not a keyword like &#39;ENDER&#39; which</span>
<span class="c"># starts with &#39;END&#39; but is not &#39;END&#39;), followed by any arbitrary bytes.  An</span>
<span class="c"># invalid end card may also consist of just &#39;END&#39; with no trailing bytes.</span>
<span class="n">HEADER_END_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">encode_ascii</span><span class="p">(</span>
    <span class="s">r&#39;(?:(?P&lt;valid&gt;END {77}) *)|(?P&lt;invalid&gt;END$|END {0,76}[^A-Z0-9_-])&#39;</span><span class="p">))</span>


<span class="c"># According to the FITS standard the only characters that may appear in a</span>
<span class="c"># header record are the restricted ASCII chars from 0x20 through 0x7E.</span>
<span class="n">VALID_HEADER_CHARS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x7F</span><span class="p">))</span>
<span class="n">END_CARD</span> <span class="o">=</span> <span class="s">&#39;END&#39;</span> <span class="o">+</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="mi">77</span>


<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;Header&#39;</span><span class="p">,</span> <span class="s">&#39;Header.*&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="Header"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header">[docs]</a><span class="k">class</span> <span class="nc">Header</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FITS header class.  This class exposes both a dict-like interface and a</span>
<span class="sd">    list-like interface to FITS headers.</span>

<span class="sd">    The header may be indexed by keyword and, like a dict, the associated value</span>
<span class="sd">    will be returned.  When the header contains cards with duplicate keywords,</span>
<span class="sd">    only the value of the first card with the given keyword will be returned.</span>
<span class="sd">    It is also possible to use a 2-tuple as the index in the form (keyword,</span>
<span class="sd">    n)--this returns the n-th value with that keyword, in the case where there</span>
<span class="sd">    are duplicate keywords.</span>

<span class="sd">    For example::</span>

<span class="sd">        &gt;&gt;&gt; header[&#39;NAXIS&#39;]</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; header[(&#39;FOO&#39;, 1)]  # Return the value of the second FOO keyword</span>
<span class="sd">        &#39;foo&#39;</span>

<span class="sd">    The header may also be indexed by card number::</span>

<span class="sd">        &gt;&gt;&gt; header[0]  # Return the value of the first card in the header</span>
<span class="sd">        &#39;T&#39;</span>

<span class="sd">    Commentary keywords such as HISTORY and COMMENT are special cases: When</span>
<span class="sd">    indexing the Header object with either &#39;HISTORY&#39; or &#39;COMMENT&#39; a list of all</span>
<span class="sd">    the HISTORY/COMMENT values is returned::</span>

<span class="sd">        &gt;&gt;&gt; header[&#39;HISTORY&#39;]</span>
<span class="sd">        This is the first history entry in this header.</span>
<span class="sd">        This is the second history entry in this header.</span>
<span class="sd">        ...</span>

<span class="sd">    See the Astropy documentation for more details on working with headers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cards</span><span class="o">=</span><span class="p">[],</span> <span class="n">txtfile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a `Header` from an iterable and/or text file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cards : A list of `Card` objects, optional</span>
<span class="sd">            The cards to initialize the header with.</span>

<span class="sd">        txtfile : file path, file object or file-like object, optional</span>
<span class="sd">            Input ASCII header parameters file **(Deprecated)**</span>
<span class="sd">            Use the Header.fromfile classmethod instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">txtfile</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s">&#39;The txtfile argument is deprecated.  Use Header.fromfile to &#39;</span>
                <span class="s">&#39;create a new Header object from a text file.&#39;</span><span class="p">,</span>
                <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
            <span class="c"># get the cards from the input ASCII file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">txtfile</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cards</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="n">cards</span><span class="o">.</span><span class="n">cards</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span> <span class="ow">or</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">:</span>
            <span class="c"># For the most common case (single, standard form keyword lookup)</span>
            <span class="c"># this will work and is an O(1) check.  If it fails that doesn&#39;t</span>
            <span class="c"># guarantee absence, just that we have to perform the full set of</span>
            <span class="c"># checks in self._cardindex</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Header</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Header</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                           <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">key</span><span class="p">)])</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="c"># Special case for commentary cards</span>
            <span class="k">return</span> <span class="n">_HeaderCommentaryCards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span>
        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="o">==</span> <span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">:</span>
            <span class="c"># This is RVKC; if only the top-level keyword was specified return</span>
            <span class="c"># the raw value, not the parsed out float value</span>
            <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="n">rawvalue</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;A Header item may be set with either a scalar value, &#39;</span>
                    <span class="s">&#39;a 1-tuple containing a scalar value, or a 2-tuple &#39;</span>
                    <span class="s">&#39;containing a scalar value and comment string.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">None</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
                <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">comment</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">card</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">card</span><span class="p">:</span>
            <span class="n">card</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">card</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
            <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If we get an IndexError that should be raised; we don&#39;t allow</span>
            <span class="c"># assignment to non-existing indices</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c"># This is very inefficient but it&#39;s not a commonly used feature.</span>
            <span class="c"># If someone out there complains that they make heavy use of slice</span>
            <span class="c"># deletions and it&#39;s too slow, well, we can worry about it then</span>
            <span class="c"># [the solution is not too complicated--it would be wait &#39;til all</span>
            <span class="c"># the cards are deleted before updating _keyword_indices rather</span>
            <span class="c"># than updating it once for each card that gets deleted]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
                <span class="c"># If the slice step is backwards we want to reverse it, because</span>
                <span class="c"># it will be reversed in a few lines...</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="ow">and</span> <span class="n">key</span><span class="o">.</span><span class="n">step</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indices</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c"># delete ALL cards with the same keyword name</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span>

            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_is_astropy_internal</span><span class="p">():</span>
                    <span class="c"># All internal code is designed to assume that this will</span>
                    <span class="c"># raise a KeyError, so go ahead and do so</span>
                    <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Keyword &#39;</span><span class="si">%s</span><span class="s">&#39; not found.&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
                <span class="c"># Warn everyone else.</span>
                <span class="c"># TODO: Remove this warning and make KeyError the default after</span>
                <span class="c"># a couple versions (by 3.3, say)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;Deletion of non-existent keyword </span><span class="si">%r</span><span class="s">: &#39;</span>
                    <span class="s">&#39;In a future Astropy version Header.__delitem__ may be &#39;</span>
                    <span class="s">&#39;changed so that this raises a KeyError just like a dict &#39;</span>
                    <span class="s">&#39;would. Please update your code so that KeyErrors are &#39;</span>
                    <span class="s">&#39;caught and handled when deleting non-existent keywords.&#39;</span> <span class="o">%</span>
                    <span class="n">key</span><span class="p">,</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>
                <span class="c"># Have to copy the indices list since it will be modified below</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
        <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

        <span class="c"># Also update RVKC indices if necessary :/</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span>
            <span class="n">indices</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span>


        <span class="c"># We also need to update all other indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateindices</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tostring</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Two Headers are equal only if they have the exact same string</span>
<span class="sd">        representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">strip</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">temp</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">temp</span>

    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">cards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The underlying physical cards that make up this Header; it can be</span>
<span class="sd">        looked at, but it should not be modified directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_CardAccessor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">comments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        View the comments associated with each keyword, if any.</span>

<span class="sd">        For example, to see the comment on the NAXIS keyword:</span>

<span class="sd">            &gt;&gt;&gt; header.comments[&#39;NAXIS&#39;]</span>
<span class="sd">            number of data axes</span>

<span class="sd">        Comments can also be updated through this interface:</span>

<span class="sd">            &gt;&gt;&gt; header.comments[&#39;NAXIS&#39;] = &#39;Number of data axes&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">_HeaderComments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether or not the header has been modified; this is a property so that</span>
<span class="sd">        it can also check each card for modifications--cards may have been</span>
<span class="sd">        modified directly without the header containing it otherwise knowing.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">modified_cards</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">_modified</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">modified_cards</span><span class="p">:</span>
            <span class="c"># If any cards were modified then by definition the header was</span>
            <span class="c"># modified</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;_modified&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;_modified&#39;</span><span class="p">]</span>

    <span class="nd">@_modified.setter</span>
    <span class="k">def</span> <span class="nf">_modified</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;_modified&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Header.fromstring"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.fromstring">[docs]</a>    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an HDU header from a byte string containing the entire header</span>
<span class="sd">        data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str</span>
<span class="sd">           String containing the entire header.</span>

<span class="sd">        sep : str, optional</span>
<span class="sd">            The string separating cards from each other, such as a newline.  By</span>
<span class="sd">            default there is no card separator (as is the case in a raw FITS</span>
<span class="sd">            file).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        header</span>
<span class="sd">            A new `Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># If the card separator contains characters that may validly appear in</span>
        <span class="c"># a card, the only way to unambiguously distinguish between cards is to</span>
        <span class="c"># require that they be Card.length long.  However, if the separator</span>
        <span class="c"># contains non-valid characters (namely \n) the cards may be split</span>
        <span class="c"># immediately at the separator</span>
        <span class="n">require_full_cardlength</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">VALID_HEADER_CHARS</span><span class="p">)</span>

        <span class="c"># Split the header into individual cards</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">require_full_cardlength</span><span class="p">:</span>
                <span class="n">end_idx</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">end_idx</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">sep</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">end_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

            <span class="n">next_image</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">end_idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">image</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_image</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;CONTINUE&#39;</span><span class="p">:</span>
                    <span class="n">image</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_image</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image</span><span class="p">)))</span>

            <span class="k">if</span> <span class="n">require_full_cardlength</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_image</span> <span class="o">==</span> <span class="n">END_CARD</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_image</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">sep</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;END&#39;</span><span class="p">:</span>
                    <span class="n">image</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">break</span>

            <span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">next_image</span><span class="p">]</span>

        <span class="c"># Add the last image that was found before the end, if any</span>
        <span class="k">if</span> <span class="n">image</span><span class="p">:</span>
            <span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">image</span><span class="p">)))</span>

        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Header.fromfile"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.fromfile">[docs]</a>    <span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`Header.fromstring`, but reads the header string from</span>
<span class="sd">        a given file-like object or filename.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : str, file-like</span>
<span class="sd">            A filename or an open file-like object from which a FITS header is</span>
<span class="sd">            to be read.  For open file handles the file pointer must be at the</span>
<span class="sd">            beginning of the header.</span>

<span class="sd">        sep : str, optional</span>
<span class="sd">            The string separating cards from each other, such as a newline.  By</span>
<span class="sd">            default there is no card separator (as is the case in a raw FITS</span>
<span class="sd">            file).</span>

<span class="sd">        endcard : bool, optional</span>
<span class="sd">            If True (the default) the header must end with an END card in order</span>
<span class="sd">            to be considered valid.  If an END card is not found an</span>
<span class="sd">            `~.exceptions.IOError` is raised.</span>

<span class="sd">        padding : bool, optional</span>
<span class="sd">            If True (the default) the header will be required to be padded out</span>
<span class="sd">            to a multiple of 2880, the FITS header block size.  Otherwise any</span>
<span class="sd">            padding, or lack thereof, is ignored.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        header</span>
<span class="sd">            A new `Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="c"># Open in text mode by default to support newline handling; if a</span>
            <span class="c"># binary-mode file object is passed in, the user is on their own</span>
            <span class="c"># with respect to newline handling</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">is_binary</span> <span class="o">=</span> <span class="n">fileobj_is_binary</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">block_iter</span><span class="p">(</span><span class="n">nbytes</span><span class="p">):</span>
                <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">nbytes</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">data</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">data</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">break</span>

            <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_from_blocks</span><span class="p">(</span><span class="n">block_iter</span><span class="p">,</span> <span class="n">is_binary</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">endcard</span><span class="p">,</span>
                                    <span class="n">padding</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_from_blocks</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">block_iter</span><span class="p">,</span> <span class="n">is_binary</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The meat of `Header.fromfile`; in a separate method so that</span>
<span class="sd">        `Header.fromfile` itself is just responsible for wrapping file</span>
<span class="sd">        handling.  Also used by `_BaseHDU.fromstring`.</span>

<span class="sd">        ``block_iter`` should be a callable which, given a block size n</span>
<span class="sd">        (typically 2880 bytes as used by the FITS standard) returns an iterator</span>
<span class="sd">        of byte strings of that block size.</span>

<span class="sd">        ``is_binary`` specifies whether the returned blocks are bytes or text</span>

<span class="sd">        Returns both the entire header *string*, and the `Header` object</span>
<span class="sd">        returned by Header.fromstring on that string.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">actual_block_size</span> <span class="o">=</span> <span class="n">_block_size</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
        <span class="n">clen</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>

        <span class="n">blocks</span> <span class="o">=</span> <span class="n">block_iter</span><span class="p">(</span><span class="n">actual_block_size</span><span class="p">)</span>

        <span class="c"># Read the first header block.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_binary</span><span class="p">:</span>
            <span class="c"># TODO: There needs to be error handling at *this* level for</span>
            <span class="c"># non-ASCII characters; maybe at this stage decoding latin-1 might</span>
            <span class="c"># be safer</span>
            <span class="n">block</span> <span class="o">=</span> <span class="n">encode_ascii</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="n">read_blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">is_eof</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">end_found</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># continue reading header blocks until END card or EOF is reached</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="c"># find the END card</span>
            <span class="n">end_found</span><span class="p">,</span> <span class="n">block</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_find_end_card</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">clen</span><span class="p">)</span>

            <span class="n">read_blocks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decode_ascii</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">end_found</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
                <span class="n">is_eof</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">block</span><span class="p">:</span>
                <span class="n">is_eof</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_binary</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">encode_ascii</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">end_found</span> <span class="ow">and</span> <span class="n">is_eof</span> <span class="ow">and</span> <span class="n">endcard</span><span class="p">:</span>
            <span class="c"># TODO: Pass this error to validation framework as an ERROR,</span>
            <span class="c"># rather than raising an exception</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;Header missing END card.&#39;</span><span class="p">)</span>

        <span class="n">header_str</span> <span class="o">=</span> <span class="s">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">read_blocks</span><span class="p">)</span>

        <span class="c"># Strip any zero-padding (see ticket #106)</span>
        <span class="k">if</span> <span class="n">header_str</span> <span class="ow">and</span> <span class="n">header_str</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\0</span><span class="s">&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_eof</span> <span class="ow">and</span> <span class="n">header_str</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\0</span><span class="s">&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">:</span>
                <span class="c"># TODO: Pass this warning to validation framework</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;Unexpected extra padding at the end of the file.  This &#39;</span>
                    <span class="s">&#39;padding may not be preserved when saving changes.&#39;</span><span class="p">,</span>
                    <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">EOFError</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Replace the illegal null bytes with spaces as required by</span>
                <span class="c"># the FITS standard, and issue a nasty warning</span>
                <span class="c"># TODO: Pass this warning to validation framework</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;Header block contains null bytes instead of spaces for &#39;</span>
                    <span class="s">&#39;padding, and is not FITS-compliant. Nulls may be &#39;</span>
                    <span class="s">&#39;replaced with spaces upon writing.&#39;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="n">header_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\0</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39; &#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">padding</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">header_str</span><span class="p">)</span> <span class="o">%</span> <span class="n">actual_block_size</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c"># This error message ignores the length of the separator for</span>
            <span class="c"># now, but maybe it shouldn&#39;t?</span>
            <span class="n">actual_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_str</span><span class="p">)</span> <span class="o">-</span> <span class="n">actual_block_size</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span>
            <span class="c"># TODO: Pass this error to validation framework</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;Header size is not multiple of {0}: {1}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">,</span>
                                                                 <span class="n">actual_len</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">header_str</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">header_str</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_find_end_card</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">card_len</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Utility method to search a header block for the END card and handle</span>
<span class="sd">        invalid END cards.</span>

<span class="sd">        This method can also returned a modified copy of the input header block</span>
<span class="sd">        in case an invalid end card needs to be sanitized.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">HEADER_END_RE</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
            <span class="c"># Ensure the END card was found, and it started on the</span>
            <span class="c"># boundary of a new card (see ticket #142)</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="o">%</span> <span class="n">card_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c"># This must be the last header block, otherwise the</span>
            <span class="c"># file is malformatted</span>
            <span class="k">if</span> <span class="n">mo</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;invalid&#39;</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
                <span class="n">trailing</span> <span class="o">=</span> <span class="n">block</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">:</span><span class="n">offset</span> <span class="o">+</span> <span class="n">card_len</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">trailing</span><span class="p">:</span>
                    <span class="n">trailing</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">trailing</span><span class="p">)</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s">&#39;ub&#39;</span><span class="p">)</span>
                    <span class="c"># TODO: Pass this warning up to the validation framework</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s">&#39;Unexpected bytes trailing END keyword: {0}; these &#39;</span>
                        <span class="s">&#39;bytes will be replaced with spaces on write.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">trailing</span><span class="p">),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># TODO: Pass this warning up to the validation framework</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s">&#39;Missing padding to end of the FITS block after the &#39;</span>
                        <span class="s">&#39;END keyword; additional spaces will be appended to &#39;</span>
                        <span class="s">&#39;the file upon writing to pad out to {0} &#39;</span>
                        <span class="s">&#39;bytes.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>

                <span class="c"># Sanitize out invalid END card now that the appropriate</span>
                <span class="c"># warnings have been issued</span>
                <span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="n">block</span><span class="p">[:</span><span class="n">offset</span><span class="p">]</span> <span class="o">+</span> <span class="n">encode_ascii</span><span class="p">(</span><span class="n">END_CARD</span><span class="p">)</span> <span class="o">+</span>
                         <span class="n">block</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">END_CARD</span><span class="p">):])</span>

            <span class="k">return</span> <span class="bp">True</span><span class="p">,</span> <span class="n">block</span>

        <span class="k">return</span> <span class="bp">False</span><span class="p">,</span> <span class="n">block</span>

<div class="viewcode-block" id="Header.tostring"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.tostring">[docs]</a>    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Returns a string representation of the header.</span>

<span class="sd">        By default this uses no separator between cards, adds the END card, and</span>
<span class="sd">        pads the string with spaces to the next multiple of 2880 bytes.  That</span>
<span class="sd">        is, it returns the header exactly as it would appear in a FITS file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sep : str, optional</span>
<span class="sd">            The character or string with which to separate cards.  By default</span>
<span class="sd">            there is no separator, but one could use ``&#39;\\n&#39;``, for example, to</span>
<span class="sd">            separate each card with a new line</span>

<span class="sd">        endcard : bool, optional</span>
<span class="sd">            If True (default) adds the END card to the end of the header</span>
<span class="sd">            string</span>

<span class="sd">        padding : bool, optional</span>
<span class="sd">            If True (default) pads the string with spaces out to the next</span>
<span class="sd">            multiple of 2880 characters</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        s : str</span>
<span class="sd">            A string representing a FITS header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="c"># Cards with CONTINUE cards may be longer than 80 chars; so break</span>
            <span class="c"># them into multiple lines</span>
            <span class="k">while</span> <span class="n">s</span><span class="p">:</span>
                <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">])</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">:]</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">endcard</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">sep</span> <span class="o">+</span> <span class="n">_pad</span><span class="p">(</span><span class="s">&#39;END&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">padding</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s">&#39; &#39;</span> <span class="o">*</span> <span class="n">_pad_length</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">s</span>
</div>
<div class="viewcode-block" id="Header.tofile"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.tofile">[docs]</a>    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">r&quot;&quot;&quot;</span>
<span class="sd">        Writes the header to file or file-like object.</span>

<span class="sd">        By default this writes the header exactly as it would be written to a</span>
<span class="sd">        FITS file, with the END card included and padding to the next multiple</span>
<span class="sd">        of 2880 bytes.  However, aspects of this may be controlled.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : str, file, optional</span>
<span class="sd">            Either the pathname of a file, or an open file handle or file-like</span>
<span class="sd">            object</span>

<span class="sd">        sep : str, optional</span>
<span class="sd">            The character or string with which to separate cards.  By default</span>
<span class="sd">            there is no separator, but one could use ``&#39;\\n&#39;``, for example, to</span>
<span class="sd">            separate each card with a new line</span>

<span class="sd">        endcard : bool, optional</span>
<span class="sd">            If `True` (default) adds the END card to the end of the header</span>
<span class="sd">            string</span>

<span class="sd">        padding : bool, optional</span>
<span class="sd">            If `True` (default) pads the string with spaces out to the next</span>
<span class="sd">            multiple of 2880 characters</span>

<span class="sd">        clobber : bool, optional</span>
<span class="sd">            If `True`, overwrites the output file if it already exists</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="n">fileobj_closed</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">_File</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="n">_File</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s">&#39;ostream&#39;</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="n">padding</span><span class="p">)</span>
            <span class="n">actual_block_size</span> <span class="o">=</span> <span class="n">_block_size</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">padding</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">%</span> <span class="n">actual_block_size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;Header size (</span><span class="si">%d</span><span class="s">) is not a multiple of block &#39;</span>
                              <span class="s">&#39;size (</span><span class="si">%d</span><span class="s">).&#39;</span> <span class="o">%</span>
                              <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">-</span> <span class="n">actual_block_size</span> <span class="o">+</span> <span class="n">BLOCK_SIZE</span><span class="p">,</span>
                               <span class="n">BLOCK_SIZE</span><span class="p">))</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">blocks</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">))</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Header.fromtextfile"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.fromtextfile">[docs]</a>    <span class="k">def</span> <span class="nf">fromtextfile</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; Header.fromfile(fileobj, sep=&#39;\\n&#39;, endcard=False,</span>
<span class="sd">            ...                 padding=False)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.totextfile"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.totextfile">[docs]</a>    <span class="k">def</span> <span class="nf">totextfile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Equivalent to::</span>

<span class="sd">            &gt;&gt;&gt; Header.tofile(fileobj, sep=&#39;\\n&#39;, endcard=False,</span>
<span class="sd">            ...               padding=False, clobber=clobber)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="n">endcard</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.clear"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.clear">[docs]</a>    <span class="k">def</span> <span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all cards from the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span> <span class="o">=</span> <span class="n">collections</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.copy"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the :class:`Header`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        strip : bool, optional</span>
<span class="sd">           If `True`, strip any headers that are specific to one of the</span>
<span class="sd">           standard HDU types, so that this header can be used in a different</span>
<span class="sd">           HDU.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        header</span>
<span class="sd">            A new :class:`Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tmp</span> <span class="o">=</span> <span class="n">Header</span><span class="p">([</span><span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">card</span><span class="p">)</span> <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">strip</span><span class="p">:</span>
            <span class="n">tmp</span><span class="o">.</span><span class="n">_strip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">tmp</span>
</div>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Header.fromkeys"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.fromkeys">[docs]</a>    <span class="k">def</span> <span class="nf">fromkeys</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">iterable</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`dict.fromkeys`--creates a new `Header` from an</span>
<span class="sd">        iterable of keywords and an optional default value.</span>

<span class="sd">        This method is not likely to be particularly useful for creating real</span>
<span class="sd">        world FITS headers, but it is useful for testing.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iterable</span>
<span class="sd">            Any iterable that returns strings representing FITS keywords.</span>

<span class="sd">        value : optional</span>
<span class="sd">            A default value to assign to each keyword; must be a valid type for</span>
<span class="sd">            FITS keywords.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        header</span>
<span class="sd">            A new `Header` instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d</span> <span class="o">=</span> <span class="n">cls</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,)</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">iterable</span><span class="p">:</span>
            <span class="n">d</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,)</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span>
</div>
<div class="viewcode-block" id="Header.get"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to :meth:`dict.get`--returns the value associated with keyword</span>
<span class="sd">        in the header, or a default value if the keyword is not found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            A keyword that may or may not be in the header.</span>

<span class="sd">        default : optional</span>
<span class="sd">            A default value to return if the keyword is not found in the</span>
<span class="sd">            header.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        value</span>
<span class="sd">            The value associated with the given keyword, or the default value</span>
<span class="sd">            if the keyword is not in the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">default</span>
</div>
<div class="viewcode-block" id="Header.set"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value and/or comment and/or position of a specified keyword.</span>

<span class="sd">        If the keyword does not already exist in the header, a new keyword is</span>
<span class="sd">        created in the specified position, or appended to the end of the header</span>
<span class="sd">        if no position is specified.</span>

<span class="sd">        This method is similar to :meth:`Header.update` prior to PyFITS 3.1.</span>

<span class="sd">        .. note::</span>
<span class="sd">            It should be noted that ``header.set(keyword, value)`` and</span>
<span class="sd">            ``header.set(keyword, value, comment)`` are equivalent to</span>
<span class="sd">            ``header[keyword] = value`` and</span>
<span class="sd">            ``header[keyword] = (value, comment)`` respectively.</span>

<span class="sd">            New keywords can also be inserted relative to existing keywords</span>
<span class="sd">            using, for example::</span>

<span class="sd">                &gt;&gt;&gt; header.insert(&#39;NAXIS1&#39;, (&#39;NAXIS&#39;, 2, &#39;Number of axes&#39;))</span>

<span class="sd">            to insert before an existing keyword, or::</span>

<span class="sd">                &gt;&gt;&gt; header.insert(&#39;NAXIS&#39;, (&#39;NAXIS1&#39;, 4096), after=True)</span>

<span class="sd">            to insert after an existing keyword.</span>

<span class="sd">            The only advantage of using :meth:`Header.set` is that it</span>
<span class="sd">            easily replaces the old usage of :meth:`Header.update` both</span>
<span class="sd">            conceptually and in terms of function signature.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            A header keyword</span>

<span class="sd">        value : str, optional</span>
<span class="sd">            The value to set for the given keyword; if None the existing value</span>
<span class="sd">            is kept, but &#39;&#39; may be used to set a blank value</span>

<span class="sd">        comment : str, optional</span>
<span class="sd">            The comment to set for the given keyword; if None the existing</span>
<span class="sd">            comment is kept, but ``&#39;&#39;`` may be used to set a blank comment</span>

<span class="sd">        before : str, int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` before which this card</span>
<span class="sd">            should be located in the header.  The argument ``before`` takes</span>
<span class="sd">            precedence over ``after`` if both specified.</span>

<span class="sd">        after : str, int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` after which this card</span>
<span class="sd">            should be located in the header.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Create a temporary card that looks like the one being set; if the</span>
        <span class="c"># temporary card turns out to be a RVKC this will make it easier to</span>
        <span class="c"># deal with the idiosyncrasies thereof</span>
        <span class="c"># Don&#39;t try to make a temporary card though if they keyword looks like</span>
        <span class="c"># it might be a HIERARCH card or is otherwise invalid--this step is</span>
        <span class="c"># only for validating RVKCs.</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">KEYWORD_LENGTH</span> <span class="ow">and</span>
            <span class="n">Card</span><span class="o">.</span><span class="n">_keywd_FSC_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">):</span>
            <span class="n">new_card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
            <span class="n">new_keyword</span> <span class="o">=</span> <span class="n">new_card</span><span class="o">.</span><span class="n">keyword</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_keyword</span> <span class="o">=</span> <span class="n">keyword</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">new_keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">and</span>
                <span class="n">new_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

            <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">keyword</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">,</span>
                                     <span class="n">replace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">((</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">),</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.items"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.items">[docs]</a>    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`dict.items`.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
</div>
    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`dict.iteritems`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Like :meth:`dict.iterkeys`--iterating directly over the `Header`</span>
<span class="sd">        instance has the same behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">itervalues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Like :meth:`dict.itervalues`.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">v</span>

<div class="viewcode-block" id="Header.keys"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.keys">[docs]</a>    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of keywords in the header in the order they</span>
<span class="sd">        appear--like :meth:`dict.keys` but ordered.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">keyword</span> <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">]</span>
</div>
<div class="viewcode-block" id="Header.pop"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.pop">[docs]</a>    <span class="k">def</span> <span class="nf">pop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Works like :meth:`list.pop` if no arguments or an index argument are</span>
<span class="sd">        supplied; otherwise works like :meth:`dict.pop`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Header.pop expected at most 2 arguments, got &#39;</span>
                            <span class="s">&#39;</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">raise</span>

        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">value</span>
</div>
<div class="viewcode-block" id="Header.popitem"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.popitem">[docs]</a>    <span class="k">def</span> <span class="nf">popitem</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Similar to :meth:`dict.popitem`.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&#39;Header is empty&#39;</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span>
</div>
<div class="viewcode-block" id="Header.setdefault"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.setdefault">[docs]</a>    <span class="k">def</span> <span class="nf">setdefault</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Similar to :meth:`dict.setdefault`.&quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">IndexError</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">return</span> <span class="n">default</span>
</div>
<div class="viewcode-block" id="Header.update"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the Header with new keyword values, updating the values of</span>
<span class="sd">        existing keywords and appending new keywords otherwise; similar to</span>
<span class="sd">        `dict.update`.</span>

<span class="sd">        `update` accepts either a dict-like object or an iterable.  In the</span>
<span class="sd">        former case the keys must be header keywords and the values may be</span>
<span class="sd">        either scalar values or (value, comment) tuples.  In the case of an</span>
<span class="sd">        iterable the items must be (keyword, value) tuples or (keyword, value,</span>
<span class="sd">        comment) tuples.</span>

<span class="sd">        Arbitrary arguments are also accepted, in which case the update() is</span>
<span class="sd">        called again with the kwargs dict as its only argument.  That is,</span>

<span class="sd">        ::</span>

<span class="sd">            &gt;&gt;&gt; header.update(NAXIS1=100, NAXIS2=100)</span>

<span class="sd">        is equivalent to::</span>

<span class="sd">            header.update({&#39;NAXIS1&#39;: 100, &#39;NAXIS2&#39;: 100})</span>

<span class="sd">        .. warning::</span>
<span class="sd">            As this method works similarly to `dict.update` it is very</span>
<span class="sd">            different from the ``Header.update()`` method in PyFITS versions</span>
<span class="sd">            prior to 3.1.0.  However, support for the old API is also</span>
<span class="sd">            maintained for backwards compatibility.  If update() is called with</span>
<span class="sd">            at least two positional arguments then it can be assumed that the</span>
<span class="sd">            old API is being used.  Use of the old API should be considered</span>
<span class="sd">            **deprecated**.  Most uses of the old API can be replaced as</span>
<span class="sd">            follows:</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header[keyword] = value</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value, comment=comment)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header[keyword] = (value, comment)</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value, before=before_keyword)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header.insert(before_keyword, (keyword, value))</span>

<span class="sd">            * Replace ::</span>

<span class="sd">                  header.update(keyword, value, after=after_keyword)</span>

<span class="sd">              with ::</span>

<span class="sd">                  header.insert(after_keyword, (keyword, value),</span>
<span class="sd">                                after=True)</span>

<span class="sd">            See also :meth:`Header.set` which is a new method that provides an</span>
<span class="sd">            interface similar to the old ``Header.update()`` and may help make</span>
<span class="sd">            transition a little easier.</span>

<span class="sd">            For reference, the old documentation for the old</span>
<span class="sd">            ``Header.update()`` is provided below:</span>

<span class="sd">        Update one header card.</span>

<span class="sd">        If the keyword already exists, it&#39;s value and/or comment will be</span>
<span class="sd">        updated.  If it does not exist, a new card will be created and it will</span>
<span class="sd">        be placed before or after the specified location.  If no ``before`` or</span>
<span class="sd">        ``after`` is specified, it will be appended at the end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : str</span>
<span class="sd">            keyword</span>

<span class="sd">        value : str</span>
<span class="sd">            value to be used for updating</span>

<span class="sd">        comment : str, optional</span>
<span class="sd">            to be used for updating, default=None.</span>

<span class="sd">        before : str, int, optional</span>
<span class="sd">            name of the keyword, or index of the `Card` before which</span>
<span class="sd">            the new card will be placed.  The argument ``before`` takes</span>
<span class="sd">            precedence over ``after`` if both specified.</span>

<span class="sd">        after : str, int, optional</span>
<span class="sd">            name of the keyword, or index of the `Card` after which</span>
<span class="sd">            the new card will be placed.</span>

<span class="sd">        savecomment : bool, optional</span>
<span class="sd">            When `True`, preserve the current comment for an existing</span>
<span class="sd">            keyword.  The argument ``savecomment`` takes precedence over</span>
<span class="sd">            ``comment`` if both specified.  If ``comment`` is not</span>
<span class="sd">            specified then the current comment will automatically be</span>
<span class="sd">            preserved.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">legacy_args</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;key&#39;</span><span class="p">,</span> <span class="s">&#39;value&#39;</span><span class="p">,</span> <span class="s">&#39;comment&#39;</span><span class="p">,</span> <span class="s">&#39;before&#39;</span><span class="p">,</span> <span class="s">&#39;after&#39;</span><span class="p">,</span>
                       <span class="s">&#39;savecomment&#39;</span><span class="p">]</span>

        <span class="c"># This if statement covers all the cases in which this could be a</span>
        <span class="c"># legacy update(); note that it means it&#39;s impossible to do a</span>
        <span class="c"># dict-style update where *all* the keywords happen to legacy</span>
        <span class="c"># arguments, but realistically speaking that use case will not come up</span>

        <span class="c"># The fact that Python is &quot;flexible&quot; in allowing positional args to be</span>
        <span class="c"># passed in as keyword args makes this a little more complicated than</span>
        <span class="c"># it otherwise would be :/</span>
        <span class="n">issubset</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">legacy_args</span><span class="p">))</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s">&#39;value&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">issubset</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="s">&#39;key&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s">&#39;value&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span>
             <span class="n">issubset</span><span class="p">)):</span>
            <span class="c"># This must be a legacy update()</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s">&quot;The use of header.update() to add new keywords to a header &quot;</span>
                <span class="s">&quot;is deprecated.  Instead, use either header.set() or simply &quot;</span>
                <span class="s">&quot;`header[keyword] = value` or &quot;</span>
                <span class="s">&quot;`header[keyword] = (value, comment)`.  header.set() is only &quot;</span>
                <span class="s">&quot;necessary to use if you also want to use the before/after &quot;</span>
                <span class="s">&quot;keyword arguments.&quot;</span><span class="p">,</span> <span class="n">AstropyDeprecationWarning</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">legacy_args</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="s">&#39;</span><span class="si">%s</span><span class="s">.update() got multiple values for keyword &#39;</span>
                        <span class="s">&#39;argument </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">k</span><span class="p">))</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

            <span class="n">keyword</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;key&#39;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;value&#39;</span><span class="p">)</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;comment&#39;</span><span class="p">)</span>
            <span class="n">before</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;before&#39;</span><span class="p">)</span>
            <span class="n">after</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;after&#39;</span><span class="p">)</span>
            <span class="n">savecomment</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;savecomment&#39;</span><span class="p">)</span>

            <span class="c"># Handle the savecomment argument which is not currently used by</span>
            <span class="c"># Header.set()</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span> <span class="ow">and</span> <span class="n">savecomment</span><span class="p">:</span>
                <span class="n">comment</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># The rest of this should work similarly to dict.update()</span>
            <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">def</span> <span class="nf">update_from_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">elif</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">k</span><span class="p">,)</span> <span class="o">+</span> <span class="n">v</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s">&#39;Header update value for key </span><span class="si">%r</span><span class="s"> is invalid; the &#39;</span>
                        <span class="s">&#39;value must be either a scalar, a 1-tuple &#39;</span>
                        <span class="s">&#39;containing the scalar value, or a 2-tuple &#39;</span>
                        <span class="s">&#39;containing the value and a comment string.&#39;</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">other</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;iteritems&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                    <span class="n">update_from_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s">&#39;keys&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">update_from_dict</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">other</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">card</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s">&#39;Header update sequence item #</span><span class="si">%d</span><span class="s"> is invalid; &#39;</span>
                            <span class="s">&#39;the item must either be a 2-tuple containing &#39;</span>
                            <span class="s">&#39;a keyword and value, or a 3-tuple containing &#39;</span>
                            <span class="s">&#39;a keyword, value, and comment string.&#39;</span> <span class="o">%</span> <span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.values"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.values">[docs]</a>    <span class="k">def</span> <span class="nf">values</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a list of the values of all cards in the header.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span>
</div>
<div class="viewcode-block" id="Header.append"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends a new keyword+value card to the end of the Header, similar</span>
<span class="sd">        to `list.append`.</span>

<span class="sd">        By default if the last cards in the Header have commentary keywords,</span>
<span class="sd">        this will append the new keyword before the commentary (unless the new</span>
<span class="sd">        keyword is also commentary).</span>

<span class="sd">        Also differs from `list.append` in that it can be called with no</span>
<span class="sd">        arguments: In this case a blank card is appended to the end of the</span>
<span class="sd">        Header.  In the case all the keyword arguments are ignored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        card : str, tuple</span>
<span class="sd">            A keyword or a (keyword, value, [comment]) tuple representing a</span>
<span class="sd">            single header card; the comment is optional in which case a</span>
<span class="sd">            2-tuple may be used</span>

<span class="sd">        useblanks : bool, optional</span>
<span class="sd">            If there are blank cards at the end of the Header, replace the</span>
<span class="sd">            first blank card so that the total number of cards in the Header</span>
<span class="sd">            does not increase.  Otherwise preserve the number of blank cards.</span>

<span class="sd">        bottom : bool, optional</span>
<span class="sd">            If True, instead of appending after the last non-commentary card,</span>
<span class="sd">            append after the last non-blank card.</span>

<span class="sd">        end : bool, optional</span>
<span class="sd">            If True, ignore the useblanks and bottom options, and append at the</span>
<span class="sd">            very end of the Header.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">card</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;The value appended to a Header must be either a keyword or &#39;</span>
                <span class="s">&#39;(keyword, value, [comment]) tuple; got: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">card</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">end</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
            <span class="c"># Blank cards should always just be appended to the end</span>
            <span class="n">end</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">end</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">bottom</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span>
                       <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updateindices</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">end</span><span class="p">:</span>
            <span class="c"># If the appended card was a commentary card, and it was appended</span>
            <span class="c"># before existing cards with the same keyword, the indices for</span>
            <span class="c"># cards with that keyword may have changed</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">bottom</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c"># Finally, if useblanks, delete a blank cards from the end</span>
            <span class="k">if</span> <span class="n">useblanks</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">():</span>
                <span class="c"># Don&#39;t do this unless there is at least one blanks at the end</span>
                <span class="c"># of the header; we need to convert the card to its string</span>
                <span class="c"># image to see how long it is.  In the vast majority of cases</span>
                <span class="c"># this will just be 80 (Card.length) but it may be longer for</span>
                <span class="c"># CONTINUE cards</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_useblanks</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">))</span> <span class="o">//</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Header.extend"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cards</span><span class="p">,</span> <span class="n">strip</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">update</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
               <span class="n">update_first</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Appends multiple keyword+value cards to the end of the header, similar</span>
<span class="sd">        to `list.extend`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        cards : iterable</span>
<span class="sd">            An iterable of (keyword, value, [comment]) tuples; see</span>
<span class="sd">            `Header.append`.</span>

<span class="sd">        strip : bool, optional</span>
<span class="sd">            Remove any keywords that have meaning only to specific types of</span>
<span class="sd">            HDUs, so that only more general keywords are added from extension</span>
<span class="sd">            Header or Card list (default: `True`).</span>

<span class="sd">        unique : bool, optional</span>
<span class="sd">            If `True`, ensures that no duplicate keywords are appended;</span>
<span class="sd">            keywords already in this header are simply discarded.  The</span>
<span class="sd">            exception is commentary keywords (COMMENT, HISTORY, etc.): they are</span>
<span class="sd">            only treated as duplicates if their values match.</span>

<span class="sd">        update : bool, optional</span>
<span class="sd">            If `True`, update the current header with the values and comments</span>
<span class="sd">            from duplicate keywords in the input header.  This supercedes the</span>
<span class="sd">            ``unique`` argument.  Commentary keywords are treated the same as</span>
<span class="sd">            if ``unique=True``.</span>

<span class="sd">        update_first : bool, optional</span>
<span class="sd">            If the first keyword in the header is &#39;SIMPLE&#39;, and the first</span>
<span class="sd">            keyword in the input header is &#39;XTENSION&#39;, the &#39;SIMPLE&#39; keyword is</span>
<span class="sd">            replaced by the &#39;XTENSION&#39; keyword.  Likewise if the first keyword</span>
<span class="sd">            in the header is &#39;XTENSION&#39; and the first keyword in the input</span>
<span class="sd">            header is &#39;SIMPLE&#39;, the &#39;XTENSION&#39; keyword is replaced by the</span>
<span class="sd">            &#39;SIMPLE&#39; keyword.  This behavior is otherwise dumb as to whether or</span>
<span class="sd">            not the resulting header is a valid primary or extension header.</span>
<span class="sd">            This is mostly provided to support backwards compatibility with the</span>
<span class="sd">            old :meth:`Header.fromTxtFile` method, and only applies if</span>
<span class="sd">            ``update=True``.</span>

<span class="sd">        useblanks, bottom, end : bool, optional</span>
<span class="sd">            These arguments are passed to :meth:`Header.append` while appending</span>
<span class="sd">            new cards to the header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">temp</span> <span class="o">=</span> <span class="n">Header</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">strip</span><span class="p">:</span>
            <span class="n">temp</span><span class="o">.</span><span class="n">_strip</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># We don&#39;t immediately modify the header, because first we need to sift</span>
        <span class="c"># out any duplicates in the new header prior to adding them to the</span>
        <span class="c"># existing header, but while *allowing* duplicates from the header</span>
        <span class="c"># being extended from (see ticket #156)</span>
        <span class="n">extend_cards</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">temp</span><span class="o">.</span><span class="n">cards</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">unique</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">update</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">elif</span> <span class="n">update</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">update_first</span><span class="p">:</span>
                        <span class="c"># Dumbly update the first keyword to either SIMPLE or</span>
                        <span class="c"># XTENSION as the case may be, as was in the case in</span>
                        <span class="c"># Header.fromTxtFile</span>
                        <span class="k">if</span> <span class="p">((</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;SIMPLE&#39;</span> <span class="ow">and</span> <span class="n">first</span> <span class="o">==</span> <span class="s">&#39;XTENSION&#39;</span><span class="p">)</span> <span class="ow">or</span>
                                <span class="p">(</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;XTENSION&#39;</span> <span class="ow">and</span> <span class="n">first</span> <span class="o">==</span> <span class="s">&#39;SIMPLE&#39;</span><span class="p">)):</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                        <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">unique</span> <span class="ow">or</span> <span class="n">update</span><span class="p">)</span> <span class="ow">and</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                        <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                        <span class="k">continue</span>

                    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">[</span><span class="n">keyword</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extend_cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="n">extend_cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="n">useblanks</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.count"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the count of the given keyword in the header, similar to</span>
<span class="sd">        `list.count` if the Header object is treated as a list of keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword to count instances of in the header</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="c"># We have to look before we leap, since otherwise _keyword_indices,</span>
        <span class="c"># being a defaultdict, will create an entry for the nonexistent keyword</span>
        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Keyword </span><span class="si">%r</span><span class="s"> not found.&quot;</span> <span class="o">%</span> <span class="n">keyword</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">])</span>
</div>
<div class="viewcode-block" id="Header.index"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.index">[docs]</a>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index if the first instance of the given keyword in the</span>
<span class="sd">        header, similar to `list.index` if the Header object is treated as a</span>
<span class="sd">        list of keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword to look up in the list of all keywords in the header</span>

<span class="sd">        start : int, optional</span>
<span class="sd">            The lower bound for the index</span>

<span class="sd">        stop : int, optional</span>
<span class="sd">            The upper bound for the index</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stop</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">norm_keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">norm_keyword</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">idx</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;The keyword </span><span class="si">%r</span><span class="s"> is not in the header.&#39;</span> <span class="o">%</span> <span class="n">keyword</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.insert"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a new keyword+value card into the Header at a given location,</span>
<span class="sd">        similar to `list.insert`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : int, str, or tuple</span>
<span class="sd">            The index into the list of header keywords before which the</span>
<span class="sd">            new keyword should be inserted, or the name of a keyword before</span>
<span class="sd">            which the new keyword should be inserted.  Can also accept a</span>
<span class="sd">            (keyword, index) tuple for inserting around duplicate keywords.</span>

<span class="sd">        card : str, tuple</span>
<span class="sd">            A keyword or a (keyword, value, [comment]) tuple; see</span>
<span class="sd">            `Header.append`</span>

<span class="sd">        useblanks : bool, optional</span>
<span class="sd">            If there are blank cards at the end of the Header, replace the</span>
<span class="sd">            first blank card so that the total number of cards in the Header</span>
<span class="sd">            does not increase.  Otherwise preserve the number of blank cards.</span>

<span class="sd">        after : bool, optional</span>
<span class="sd">            If set to `True`, insert *after* the specified index or keyword,</span>
<span class="sd">            rather than before it.  Defaults to `False`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c"># Don&#39;t pass through ints to _cardindex because it will not take</span>
            <span class="c"># kindly to indices outside the existing number of cards in the</span>
            <span class="c"># header, which insert needs to be able to support (for example</span>
            <span class="c"># when inserting into empty headers)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">key</span>

        <span class="k">if</span> <span class="n">after</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
            <span class="c"># This is just an append (Though it must be an append absolutely to</span>
            <span class="c"># the bottom, ignoring blanks, etc.--the point of the insert method</span>
            <span class="c"># is that you get exactly what you asked for with no surprises)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;The value inserted into a Header must be either a keyword or &#39;</span>
                <span class="s">&#39;(keyword, value, [comment]) tuple; got: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">card</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span>

        <span class="c"># If idx was &lt; 0, determine the actual index according to the rules</span>
        <span class="c"># used by list.insert()</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c"># All the keyword indices above the insertion point must be updated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updateindices</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c"># There were already keywords with this same name</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;A </span><span class="si">%r</span><span class="s"> keyword already exists in this header.  Inserting &#39;</span>
                    <span class="s">&#39;duplicate keyword.&#39;</span> <span class="o">%</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">field_specifier</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Update the index of RVKC as well</span>
            <span class="n">rvkc_indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">[</span><span class="n">card</span><span class="o">.</span><span class="n">rawkeyword</span><span class="p">]</span>
            <span class="n">rvkc_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">rvkc_indices</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">useblanks</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_useblanks</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">card</span><span class="p">))</span> <span class="o">//</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="Header.remove"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the first instance of the given keyword from the header similar</span>
<span class="sd">        to `list.remove` if the Header object is treated as a list of keywords.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword of which to remove the first instance in the header</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keyword</span><span class="p">)]</span>
</div>
<div class="viewcode-block" id="Header.rename_keyword"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.rename_keyword">[docs]</a>    <span class="k">def</span> <span class="nf">rename_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldkeyword</span><span class="p">,</span> <span class="n">newkeyword</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename a card&#39;s keyword in the header.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        oldkeyword : str or int</span>
<span class="sd">            Old keyword or card index</span>

<span class="sd">        newkeyword : str</span>
<span class="sd">            New keyword</span>

<span class="sd">        force : bool, optional</span>
<span class="sd">            When `True`, if the new keyword already exists in the header, force</span>
<span class="sd">            the creation of a duplicate keyword. Otherwise a</span>
<span class="sd">            `~.exceptions.ValueError` is raised.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">oldkeyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">oldkeyword</span><span class="p">)</span>
        <span class="n">newkeyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">newkeyword</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">newkeyword</span> <span class="o">==</span> <span class="s">&#39;CONTINUE&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Can not rename to CONTINUE&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">newkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">or</span>
                <span class="n">oldkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">newkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">and</span>
                    <span class="n">oldkeyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Regular and commentary keys can not be &#39;</span>
                                 <span class="s">&#39;renamed to each other.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">force</span> <span class="ow">and</span> <span class="n">newkeyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Intended keyword </span><span class="si">%s</span><span class="s"> already exists in header.&#39;</span>
                             <span class="o">%</span> <span class="n">newkeyword</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">oldkeyword</span><span class="p">)</span>
        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">newkeyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="Header.add_history"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.add_history">[docs]</a>    <span class="k">def</span> <span class="nf">add_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a ``HISTORY`` card.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            History text to be added.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_commentary</span><span class="p">(</span><span class="s">&#39;HISTORY&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.add_comment"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.add_comment">[docs]</a>    <span class="k">def</span> <span class="nf">add_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a ``COMMENT`` card.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Text to be added.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_commentary</span><span class="p">(</span><span class="s">&#39;COMMENT&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Header.add_blank"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.add_blank">[docs]</a>    <span class="k">def</span> <span class="nf">add_blank</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a blank card.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str, optional</span>
<span class="sd">            Text to be added.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Same as in `Header.update`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_add_commentary</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The real update code.  If keyword already exists, its value and/or</span>
<span class="sd">        comment will be updated.  Otherwise a new card will be appended.</span>

<span class="sd">        This will not create a duplicate keyword except in the case of</span>
<span class="sd">        commentary cards.  The only other way to force creation of a duplicate</span>
<span class="sd">        is to use the insert(), append(), or extend() methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span> <span class="o">=</span> <span class="n">card</span>

        <span class="c"># Lookups for existing/known keywords are case-insensitive</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">keyword</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;HIERARCH &#39;</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="mi">9</span><span class="p">:]</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">keyword</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span> <span class="ow">and</span>
                <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">):</span>
            <span class="c"># Easy; just update the value/comment</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">existing_card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">existing_card</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># &#39;&#39; should be used to explicitly blank a comment</span>
                <span class="n">existing_card</span><span class="o">.</span><span class="n">comment</span> <span class="o">=</span> <span class="n">comment</span>
            <span class="k">if</span> <span class="n">existing_card</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_splitcommentary</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">:</span>
                <span class="c"># Append after the last keyword of the same type</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">stop</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">isblank</span> <span class="o">=</span> <span class="ow">not</span> <span class="p">(</span><span class="n">keyword</span> <span class="ow">or</span> <span class="n">value</span> <span class="ow">or</span> <span class="n">comment</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">cards</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="p">(</span><span class="ow">not</span> <span class="n">isblank</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># A new keyword! self.append() will handle updating _modified</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_cardindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns an index into the ._cards list given a valid lookup key.&quot;&quot;&quot;</span>

        <span class="c"># This used to just set key = (key, 0) and then go on to act as if the</span>
        <span class="c"># user passed in a tuple, but it&#39;s much more common to just be given a</span>
        <span class="c"># string as the key, so optimize more for that case</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">keyword</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c"># If &lt; 0, determine the actual index</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;Header index out of range.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s">&#39;Tuple indices must be 2-tuples consisting of a &#39;</span>
                    <span class="s">&#39;keyword string and an integer index.&#39;</span><span class="p">)</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;Header indices must be either a string, a 2-tuple, or &#39;</span>
                <span class="s">&#39;an integer.&#39;</span><span class="p">)</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">normalize_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="c"># Returns the index into _cards for the n-th card with the given</span>
        <span class="c"># keyword (where n is 0-based)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">KEYWORD_LENGTH</span> <span class="ow">or</span> <span class="s">&#39;.&#39;</span> <span class="ow">in</span> <span class="n">keyword</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Keyword </span><span class="si">%r</span><span class="s"> not found.&quot;</span> <span class="o">%</span> <span class="n">keyword</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Maybe it&#39;s a RVKC?</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">indices</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Keyword </span><span class="si">%r</span><span class="s"> not found.&quot;</span> <span class="o">%</span> <span class="n">keyword</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">indices</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s">&#39;There are only </span><span class="si">%d</span><span class="s"> </span><span class="si">%r</span><span class="s"> cards in the header.&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span> <span class="n">keyword</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_keyword_from_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given an integer index, return the (keyword, repeat) tuple that index</span>
<span class="sd">        refers to.  For most keywords the repeat will always be zero, but it</span>
<span class="sd">        may be greater than zero for keywords that are duplicated (especially</span>
<span class="sd">        commentary keywords).</span>

<span class="sd">        In a sense this is the inverse of self.index, except that it also</span>
<span class="sd">        supports duplicates.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">keyword</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">repeat</span>

    <span class="k">def</span> <span class="nf">_relativeinsert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inserts a new card before or after an existing card; used to</span>
<span class="sd">        implement support for the legacy before/after keyword arguments to</span>
<span class="sd">        Header.update().</span>

<span class="sd">        If replace=True, move an existing card with the same keyword.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">insertionkey</span> <span class="o">=</span> <span class="n">after</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">insertionkey</span> <span class="o">=</span> <span class="n">before</span>

        <span class="k">def</span> <span class="nf">get_insertion_idx</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">insertionkey</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">insertionkey</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">insertionkey</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">insertionkey</span>

            <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">idx</span>

        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="c"># The card presumably already exists somewhere in the header.</span>
            <span class="c"># Check whether or not we actually have to move it; if it does need</span>
            <span class="c"># to be moved we just delete it and then it will be reinserted</span>
            <span class="c"># below</span>
            <span class="n">old_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>
            <span class="n">insertion_idx</span> <span class="o">=</span> <span class="n">get_insertion_idx</span><span class="p">()</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">insertion_idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="ow">and</span>
                    <span class="n">old_idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c"># The card would be appended to the end, but it&#39;s already at</span>
                <span class="c"># the end</span>
                <span class="k">return</span>

            <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">old_idx</span> <span class="o">==</span> <span class="n">insertion_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="k">elif</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">old_idx</span> <span class="o">==</span> <span class="n">insertion_idx</span><span class="p">:</span>
                <span class="k">return</span>

            <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">old_idx</span><span class="p">]</span>

        <span class="c"># Even if replace=True, the insertion idx may have changed since the</span>
        <span class="c"># old card was deleted</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">get_insertion_idx</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_splitcommentary</span><span class="p">(</span><span class="n">card</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="n">card</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_updateindices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">increment</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For all cards with index above idx, increment or decrement its index</span>
<span class="sd">        value in the keyword_indices dict.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
            <span class="c"># Save us some effort</span>
            <span class="k">return</span>

        <span class="n">increment</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">increment</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">index_sets</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">itervalues</span><span class="p">(</span><span class="n">index_sets</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">jdx</span><span class="p">,</span> <span class="n">keyword_index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">keyword_index</span> <span class="o">&gt;=</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">indices</span><span class="p">[</span><span class="n">jdx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">increment</span>

    <span class="k">def</span> <span class="nf">_countblanks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the number of blank cards at the end of the Header.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="o">-</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_useblanks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">count</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">is_blank</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_haswildcard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return `True` if the input keyword contains a wildcard pattern.&quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span>
                <span class="p">(</span><span class="n">keyword</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">&#39;...&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="s">&#39;*&#39;</span> <span class="ow">in</span> <span class="n">keyword</span> <span class="ow">or</span> <span class="s">&#39;?&#39;</span> <span class="ow">in</span> <span class="n">keyword</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_wildcardmatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pattern</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a list of indices of the cards matching the given wildcard</span>
<span class="sd">        pattern.</span>

<span class="sd">         * &#39;*&#39; matches 0 or more characters</span>
<span class="sd">         * &#39;?&#39; matches a single character</span>
<span class="sd">         * &#39;...&#39; matches 0 or more of any non-whitespace character</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;*&#39;</span><span class="p">,</span> <span class="s">r&#39;.*&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;?&#39;</span><span class="p">,</span> <span class="s">r&#39;.&#39;</span><span class="p">)</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">pattern</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;...&#39;</span><span class="p">,</span> <span class="s">r&#39;\S*&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="s">&#39;$&#39;</span>
        <span class="n">pattern_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">card</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">pattern_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">_set_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to implement Header.__setitem__ and CardAccessor.__setitem__.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">target</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">target</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

            <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_splitcommentary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a commentary keyword and value, returns a list of the one or more</span>
<span class="sd">        cards needed to represent the full value.  This is primarily used to</span>
<span class="sd">        create the multiple commentary cards needed to represent a long value</span>
<span class="sd">        that won&#39;t fit into a single commentary card.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># The maximum value in each card can be the maximum card length minus</span>
        <span class="c"># the maximum key length (which can include spaces if they key length</span>
        <span class="c"># less than 8</span>
        <span class="n">maxlen</span> <span class="o">=</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="n">KEYWORD_LENGTH</span>
        <span class="n">valuestr</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">valuestr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">maxlen</span><span class="p">:</span>
            <span class="c"># The value can fit in a single card</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="n">Card</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">value</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># The value must be split across multiple consecutive commentary</span>
            <span class="c"># cards</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">valuestr</span><span class="p">):</span>
                <span class="n">cards</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Card</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">valuestr</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">maxlen</span><span class="p">]))</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="n">maxlen</span>
        <span class="k">return</span> <span class="n">cards</span>

    <span class="k">def</span> <span class="nf">_strip</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Strip cards specific to a certain kind of header.</span>

<span class="sd">        Strip cards like ``SIMPLE``, ``BITPIX``, etc. so the rest of</span>
<span class="sd">        the header can be used to reconstruct another kind of header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: Previously this only deleted some cards specific to an HDU if</span>
        <span class="c"># _hdutype matched that type.  But it seemed simple enough to just</span>
        <span class="c"># delete all desired cards anyways, and just ignore the KeyErrors if</span>
        <span class="c"># they don&#39;t exist.</span>
        <span class="c"># However, it might be desirable to make this extendable somehow--have</span>
        <span class="c"># a way for HDU classes to specify some headers that are specific only</span>
        <span class="c"># to that type, and should be removed otherwise.</span>

        <span class="k">if</span> <span class="s">&#39;NAXIS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">naxis</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="s">&#39;TFIELDS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">tfields</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tfields</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">naxis</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;TFORM&#39;</span><span class="p">,</span> <span class="s">&#39;TSCAL&#39;</span><span class="p">,</span> <span class="s">&#39;TZERO&#39;</span><span class="p">,</span> <span class="s">&#39;TNULL&#39;</span><span class="p">,</span> <span class="s">&#39;TTYPE&#39;</span><span class="p">,</span>
                     <span class="s">&#39;TUNIT&#39;</span><span class="p">,</span> <span class="s">&#39;TDISP&#39;</span><span class="p">,</span> <span class="s">&#39;TDIM&#39;</span><span class="p">,</span> <span class="s">&#39;THEAP&#39;</span><span class="p">,</span> <span class="s">&#39;TBCOL&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tfields</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="s">&#39;XTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="s">&#39;EXTEND&#39;</span><span class="p">,</span>
                     <span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="s">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="s">&#39;GROUPS&#39;</span><span class="p">,</span> <span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="s">&#39;BZERO&#39;</span><span class="p">,</span>
                     <span class="s">&#39;TFIELDS&#39;</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_add_commentary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a commentary card.</span>

<span class="sd">        If ``before`` and ``after`` are `None`, add to the last occurrence</span>
<span class="sd">        of cards of the same name (except blank card).  If there is no</span>
<span class="sd">        card (or blank card), append at the end.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">after</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c"># Some fixes for compatibility with the Python 3 dict interface, where</span>
    <span class="c"># iteritems -&gt; items, etc.</span>
    <span class="k">if</span> <span class="n">six</span><span class="o">.</span><span class="n">PY3</span><span class="p">:</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="n">iterkeys</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">itervalues</span>
        <span class="n">items</span> <span class="o">=</span> <span class="n">iteritems</span>
        <span class="k">del</span> <span class="n">iterkeys</span>
        <span class="k">del</span> <span class="n">itervalues</span>
        <span class="k">del</span> <span class="n">iteritems</span>

    <span class="c"># The following properties/methods are for legacy API backwards</span>
    <span class="c"># compatibility</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `.cards` attribute&#39;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ascard</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a ``CardList`` object wrapping this Header; provided for</span>
<span class="sd">        backwards compatibility for the old API (where Headers had an</span>
<span class="sd">        underlying ``CardList``).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">CardList</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;:meth:`Header.rename_keyword`&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Header.rename_key"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.rename_key">[docs]</a>    <span class="k">def</span> <span class="nf">rename_key</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">,</span> <span class="n">force</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rename_keyword</span><span class="p">(</span><span class="n">oldkey</span><span class="p">,</span> <span class="n">newkey</span><span class="p">,</span> <span class="n">force</span><span class="p">)</span>
</div>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&quot;``header[&#39;HISTORY&#39;]``&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="Header.get_history"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.get_history">[docs]</a>    <span class="k">def</span> <span class="nf">get_history</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all history cards as a list of string texts.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;HISTORY&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;HISTORY&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</div>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&quot;``header[&#39;COMMENT&#39;]``&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="Header.get_comment"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.get_comment">[docs]</a>    <span class="k">def</span> <span class="nf">get_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all comment cards as a list of string texts.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;COMMENT&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="s">&#39;COMMENT&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>
</div>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;:meth:`Header.totextfile`&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Header.toTxtFile"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.toTxtFile">[docs]</a>    <span class="k">def</span> <span class="nf">toTxtFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output the header parameters to a file in ASCII format.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : file path, file object or file-like object</span>
<span class="sd">            Output header parameters file.</span>

<span class="sd">        clobber : bool</span>
<span class="sd">            When `True`, overwrite the output file if it exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                    <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">)</span>
</div>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span>
                <span class="n">message</span><span class="o">=</span><span class="s">&#39;This is equivalent to &#39;</span>
                        <span class="s">&#39;``self.extend(Header.fromtextfile(fileobj), &#39;</span>
                        <span class="s">&#39;update=True, update_first=True)``.  Note that there &#39;</span>
                        <span class="s">&#39;there is no direct equivalent to the &#39;</span>
                        <span class="s">&#39;``replace=True`` option since &#39;</span>
                        <span class="s">&#39;:meth:`Header.fromtextfile` returns a new &#39;</span>
                        <span class="s">&#39;:class:`Header` instance.&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="Header.fromTxtFile"><a class="viewcode-back" href="../../../../io/fits/api/headers.html#astropy.io.fits.Header.fromTxtFile">[docs]</a>    <span class="k">def</span> <span class="nf">fromTxtFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Input the header parameters from an ASCII file.</span>

<span class="sd">        The input header cards will be used to update the current</span>
<span class="sd">        header.  Therefore, when an input card key matches a card key</span>
<span class="sd">        that already exists in the header, that card will be updated</span>
<span class="sd">        in place.  Any input cards that do not already exist in the</span>
<span class="sd">        header will be added.  Cards will not be deleted from the</span>
<span class="sd">        header.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : file path, file object or file-like object</span>
<span class="sd">            Input header parameters file.</span>

<span class="sd">        replace : bool, optional</span>
<span class="sd">            When `True`, indicates that the entire header should be</span>
<span class="sd">            replaced with the contents of the ASCII file instead of</span>
<span class="sd">            just updating the current header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">input_header</span> <span class="o">=</span> <span class="n">Header</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                                       <span class="n">padding</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">prev_key</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="n">input_header</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
            <span class="n">card</span><span class="o">.</span><span class="n">verify</span><span class="p">(</span><span class="s">&#39;silentfix&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;SIMPLE&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;XTENSION&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">ascard</span><span class="p">[</span><span class="s">&#39;XTENSION&#39;</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">prev_key</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;XTENSION&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">):</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">ascard</span><span class="p">[</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">prev_key</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">replace</span> <span class="ow">and</span>
                        <span class="ow">not</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;&#39;</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="s">&#39;&#39;</span><span class="p">)):</span>
                    <span class="c"># Don&#39;t add duplicate commentary cards (though completely</span>
                    <span class="c"># blank cards are allowed to be duplicated)</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">prev_key</span><span class="p">)</span>
                        <span class="n">prev_key</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">prev_key</span><span class="p">)</span>
                    <span class="n">prev_key</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">,</span>
                         <span class="n">after</span><span class="o">=</span><span class="n">prev_key</span><span class="p">)</span>
                <span class="n">prev_key</span> <span class="o">+=</span> <span class="mi">1</span>

</div></div>
<span class="n">collections</span><span class="o">.</span><span class="n">MutableSequence</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Header</span><span class="p">)</span>
<span class="n">collections</span><span class="o">.</span><span class="n">MutableMapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Header</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_CardAccessor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is a generic class for wrapping a Header in such a way that you can</span>
<span class="sd">    use the header&#39;s slice/filtering capabilities to return a subset of cards</span>
<span class="sd">    and do something with them.</span>

<span class="sd">    This is sort of the opposite notion of the old CardList class--whereas</span>
<span class="sd">    Header used to use CardList to get lists of cards, this uses Header to get</span>
<span class="sd">    lists of cards.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># TODO: Consider giving this dict/list methods like Header itself</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">header</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c"># If the `other` item is a scalar we will still treat it as equal if</span>
        <span class="c"># this _CardAccessor only contains one item</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">other</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">zip_longest</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">item</span><span class="p">])</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_setslice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper for implementing __setitem__ on _CardAccessor subclasses; slices</span>
<span class="sd">        should always be handled in this same way.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_wildcardmatch</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">isiterable</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>


<span class="n">collections</span><span class="o">.</span><span class="n">Mapping</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">_CardAccessor</span><span class="p">)</span>
<span class="n">collections</span><span class="o">.</span><span class="n">Sequence</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">_CardAccessor</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_HeaderComments</span><span class="p">(</span><span class="n">_CardAccessor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class used internally by the Header class for the Header.comments</span>
<span class="sd">    attribute access.</span>

<span class="sd">    This object can be used to display all the keyword comments in the Header,</span>
<span class="sd">    or look up the comments on specific keywords.  It allows all the same forms</span>
<span class="sd">    of keyword lookup as the Header class itself, but returns comments instead</span>
<span class="sd">    of values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a simple list of all keywords and their comments.&quot;&quot;&quot;</span>

        <span class="n">keyword_length</span> <span class="o">=</span> <span class="n">KEYWORD_LENGTH</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">:</span>
            <span class="n">keyword_length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">keyword_length</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">))</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%*s</span><span class="s">  </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">keyword_length</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">keyword</span><span class="p">,</span> <span class="n">c</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slices and filter strings return a new _HeaderComments containing the</span>
<span class="sd">        returned cards.  Otherwise the comment of a single card is returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">item</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_HeaderComments</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">_HeaderComments</span><span class="p">):</span>
            <span class="c"># The item key was a slice</span>
            <span class="k">return</span> <span class="n">item</span>
        <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">comment</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">comment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set/update the comment on specified card or cards.</span>

<span class="sd">        Slice/filter updates work similarly to how Header.__setitem__ works.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c"># In this case, key/index errors should be raised; don&#39;t update</span>
        <span class="c"># comments of nonexistent cards</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_HeaderCommentaryCards</span><span class="p">(</span><span class="n">_CardAccessor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is used to return a list-like sequence over all the values in the</span>
<span class="sd">    header for a given commentary keyword, such as HISTORY.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="s">&#39;&#39;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_HeaderCommentaryCards</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>

    <span class="c"># __len__ and __iter__ need to be overridden from the base class due to the</span>
    <span class="c"># different approach this class has to take for slicing</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">)</span>
            <span class="n">n</span><span class="o">.</span><span class="n">_indices</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%s</span><span class="s"> index must be an integer&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">)</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_indices</span><span class="p">))[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">,</span> <span class="n">idx</span><span class="p">)]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the value of a specified commentary card or cards.</span>

<span class="sd">        Slice/filter updates work similarly to how Header.__setitem__ works.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c"># In this case, key/index errors should be raised; don&#39;t update</span>
        <span class="c"># comments of nonexistent cards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">_keyword</span><span class="p">,</span> <span class="n">item</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">_is_astropy_internal</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if the stack frame this is called from is in code internal to</span>
<span class="sd">    the astropy package.</span>

<span class="sd">    This is used in a few places where hacks are employed for backwards</span>
<span class="sd">    compatibility with the old header API, but where we want to avoid using</span>
<span class="sd">    those hacks internally.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">calling_mod</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">getmodule</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">_getframe</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">calling_mod</span> <span class="ow">and</span> <span class="n">calling_mod</span><span class="o">.</span><span class="n">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;astropy.&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_block_size</span><span class="p">(</span><span class="n">sep</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the size of a FITS header block if a non-blank separator is used</span>
<span class="sd">    between cards.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="n">BLOCK_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sep</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">BLOCK_SIZE</span> <span class="o">//</span> <span class="n">Card</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_pad_length</span><span class="p">(</span><span class="n">stringlen</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Bytes needed to pad the input stringlen to the next FITS block.&quot;&quot;&quot;</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">BLOCK_SIZE</span> <span class="o">-</span> <span class="p">(</span><span class="n">stringlen</span> <span class="o">%</span> <span class="n">BLOCK_SIZE</span><span class="p">))</span> <span class="o">%</span> <span class="n">BLOCK_SIZE</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1. &nbsp;
    Last built 12 May 2016. <br/>
  </p>
</footer>
  </body>
</html>