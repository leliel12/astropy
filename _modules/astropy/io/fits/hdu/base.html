<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.io.fits.hdu.base &mdash; Astropy v1.2.dev14996</title>
    
    <link rel="stylesheet" href="../../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '1.2.dev14996',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.2.dev14996" href="../../../../../index.html" />
    <link rel="up" title="Module code" href="../../../../index.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">Astropy v1.2.dev14996</a>
	 &raquo;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.io.fits.hdu.base</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>


<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">conf</span>
<span class="kn">from</span> <span class="nn">..file</span> <span class="kn">import</span> <span class="n">_File</span>
<span class="kn">from</span> <span class="nn">..header</span> <span class="kn">import</span> <span class="n">Header</span><span class="p">,</span> <span class="n">_pad_length</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">,</span> <span class="n">_is_pseudo_unsigned</span><span class="p">,</span> <span class="n">_unsigned_zero</span><span class="p">,</span>
                    <span class="n">itersubclasses</span><span class="p">,</span> <span class="n">decode_ascii</span><span class="p">,</span> <span class="n">_get_array_mmap</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..verify</span> <span class="kn">import</span> <span class="n">_Verify</span><span class="p">,</span> <span class="n">_ErrList</span>

<span class="kn">from</span> <span class="nn">....extern.six</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">add_metaclass</span>
<span class="kn">from</span> <span class="nn">....utils</span> <span class="kn">import</span> <span class="n">lazyproperty</span><span class="p">,</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">....utils.compat</span> <span class="kn">import</span> <span class="n">ignored</span>
<span class="kn">from</span> <span class="nn">....utils.compat.funcsigs</span> <span class="kn">import</span> <span class="n">signature</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">....utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>


<span class="k">class</span> <span class="nc">_Delayed</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">pass</span>
<span class="n">DELAYED</span> <span class="o">=</span> <span class="n">_Delayed</span><span class="p">()</span>


<span class="n">BITPIX2DTYPE</span> <span class="o">=</span> <span class="p">{</span><span class="mi">8</span><span class="p">:</span> <span class="s">&#39;uint8&#39;</span><span class="p">,</span> <span class="mi">16</span><span class="p">:</span> <span class="s">&#39;int16&#39;</span><span class="p">,</span> <span class="mi">32</span><span class="p">:</span> <span class="s">&#39;int32&#39;</span><span class="p">,</span> <span class="mi">64</span><span class="p">:</span> <span class="s">&#39;int64&#39;</span><span class="p">,</span>
                <span class="o">-</span><span class="mi">32</span><span class="p">:</span> <span class="s">&#39;float32&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">64</span><span class="p">:</span> <span class="s">&#39;float64&#39;</span><span class="p">}</span>
<span class="sd">&quot;&quot;&quot;Maps FITS BITPIX values to Numpy dtype names.&quot;&quot;&quot;</span>

<span class="n">DTYPE2BITPIX</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;uint8&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s">&#39;int16&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&#39;uint16&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s">&#39;int32&#39;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span>
                <span class="s">&#39;uint32&#39;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&#39;int64&#39;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&#39;uint64&#39;</span><span class="p">:</span> <span class="mi">64</span><span class="p">,</span> <span class="s">&#39;float32&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">32</span><span class="p">,</span>
                <span class="s">&#39;float64&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">64</span><span class="p">}</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Maps Numpy dtype names to FITS BITPIX values (this includes unsigned</span>
<span class="sd">integers, with the assumption that the pseudo-unsigned integer convention</span>
<span class="sd">will be used in this case.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">InvalidHDUException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A custom exception class used mainly to signal to _BaseHDU.__new__ that</span>
<span class="sd">    an HDU cannot possibly be considered valid, and must be assumed to be</span>
<span class="sd">    corrupted.</span>
<span class="sd">    &quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">_hdu_class_from_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Used primarily by _BaseHDU.__new__ to find an appropriate HDU class to use</span>
<span class="sd">    based on values in the header.  See the _BaseHDU.__new__ docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">klass</span> <span class="o">=</span> <span class="n">cls</span>  <span class="c"># By default, if no subclasses are defined</span>
    <span class="k">if</span> <span class="n">header</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itersubclasses</span><span class="p">(</span><span class="n">cls</span><span class="p">))):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># HDU classes built into astropy.io.fits are always considered,</span>
                <span class="c"># but extension HDUs must be explicitly registered</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">__module__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;astropy.io.fits.&#39;</span><span class="p">)</span> <span class="ow">or</span>
                        <span class="n">c</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_hdu_registry</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">match_header</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
                    <span class="n">klass</span> <span class="o">=</span> <span class="n">c</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">NotImplementedError</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;An exception occurred matching an HDU header to the &#39;</span>
                    <span class="s">&#39;appropriate HDU type: {0}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">exc</span><span class="p">),</span>
                    <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;The HDU will be treated as corrupted.&#39;</span><span class="p">,</span>
                              <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="n">klass</span> <span class="o">=</span> <span class="n">_CorruptedHDU</span>
                <span class="k">del</span> <span class="n">exc</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">klass</span>

<span class="k">class</span> <span class="nc">_BaseHDUMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">members</span><span class="p">):</span>
        <span class="c"># The sole purpose of this metaclass right now is to add the same</span>
        <span class="c"># data.deleter to all HDUs with a data property.</span>
        <span class="c"># It&#39;s unfortunate, but there&#39;s otherwise no straightforward way</span>
        <span class="c"># that a property can inherit setters/deleters of the property of the</span>
        <span class="c"># same name on base classes</span>
        <span class="k">if</span> <span class="s">&#39;data&#39;</span> <span class="ow">in</span> <span class="n">members</span><span class="p">:</span>
            <span class="n">data_prop</span> <span class="o">=</span> <span class="n">members</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">data_prop</span><span class="p">,</span> <span class="p">(</span><span class="n">lazyproperty</span><span class="p">,</span> <span class="nb">property</span><span class="p">))</span> <span class="ow">and</span>
                    <span class="n">data_prop</span><span class="o">.</span><span class="n">fdel</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                <span class="c"># Don&#39;t do anything if the class has already explicitly</span>
                <span class="c"># set the deleter for its data property</span>
                <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                    <span class="c"># The deleter</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
                        <span class="n">data_refcount</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                        <span class="c"># Manually delete *now* so that FITS_rec.__del__</span>
                        <span class="c"># cleanup can happen if applicable</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
                        <span class="c"># Don&#39;t even do this unless the *only* reference to the</span>
                        <span class="c"># .data array was the one we&#39;re deleting by deleting</span>
                        <span class="c"># this attribute; if any other references to the array</span>
                        <span class="c"># are hanging around (perhaps the user ran ``data =</span>
                        <span class="c"># hdu.data``) don&#39;t even consider this:</span>
                        <span class="k">if</span> <span class="n">data_refcount</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">_maybe_close_mmap</span><span class="p">()</span>

                <span class="nb">setattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="s">&#39;data&#39;</span><span class="p">,</span> <span class="n">data_prop</span><span class="o">.</span><span class="n">deleter</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>


<span class="c"># TODO: Come up with a better __repr__ for HDUs (and for HDULists, for that</span>
<span class="c"># matter)</span>
<span class="nd">@add_metaclass</span><span class="p">(</span><span class="n">_BaseHDUMeta</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_BaseHDU</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base class for all HDU (header data unit) classes.&quot;&quot;&quot;</span>

    <span class="n">_hdu_registry</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="c"># This HDU type is part of the FITS standard</span>
    <span class="n">_standard</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="c"># Byte to use for padding out blocks</span>
    <span class="n">_padding_byte</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\x00</span><span class="s">&#39;</span>

    <span class="n">_default_name</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterates through the subclasses of _BaseHDU and uses that class&#39;s</span>
<span class="sd">        match_header() method to determine which subclass to instantiate.</span>

<span class="sd">        It&#39;s important to be aware that the class hierarchy is traversed in a</span>
<span class="sd">        depth-last order.  Each match_header() should identify an HDU type as</span>
<span class="sd">        uniquely as possible.  Abstract types may choose to simply return False</span>
<span class="sd">        or raise NotImplementedError to be skipped.</span>

<span class="sd">        If any unexpected exceptions are raised while evaluating</span>
<span class="sd">        match_header(), the type is taken to be _CorruptedHDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">klass</span> <span class="o">=</span> <span class="n">_hdu_class_from_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_BaseHDU</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">klass</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="c"># This internal variable is used to track whether the data attribute</span>
        <span class="c"># still points to the same data array as when the HDU was originally</span>
        <span class="c"># created (this does not track whether the data is actually the same</span>
        <span class="c"># content-wise)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_needs_rescale</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_output_checksum</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="s">&#39;DATASUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">and</span> <span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_output_checksum</span> <span class="o">=</span> <span class="s">&#39;datasum&#39;</span>
        <span class="k">elif</span> <span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_output_checksum</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span>

    <span class="nd">@header.setter</span>
    <span class="k">def</span> <span class="nf">header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Convert the value to a string to be flexible in some pathological</span>
        <span class="c"># cases (see ticket #96)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_name</span><span class="p">))</span>

    <span class="nd">@name.setter</span>
    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;&#39;name&#39; attribute must be a string&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">conf</span><span class="o">.</span><span class="n">extension_name_case_sensitive</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
        <span class="k">if</span> <span class="s">&#39;EXTNAME&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;extension name&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ver</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;EXTVER&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@ver.setter</span>
    <span class="k">def</span> <span class="nf">ver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;&#39;ver&#39; attribute must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;EXTVER&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTVER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTVER&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;extension value&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;EXTLEVEL&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@level.setter</span>
    <span class="k">def</span> <span class="nf">level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;&#39;level&#39; attribute must be an integer&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">&#39;EXTLEVEL&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTLEVEL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTLEVEL&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s">&#39;extension level&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">is_image</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s">&#39;PRIMARY&#39;</span> <span class="ow">or</span>
            <span class="p">(</span><span class="s">&#39;XTENSION&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">and</span>
             <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;XTENSION&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;IMAGE&#39;</span> <span class="ow">or</span>
              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;XTENSION&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;BINTABLE&#39;</span> <span class="ow">and</span>
               <span class="s">&#39;ZIMAGE&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZIMAGE&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="bp">True</span><span class="p">))))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_data_loaded</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="s">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">DELAYED</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_has_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._header_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_hdrLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The byte offset of this HDU&#39;s header in the file it came from;</span>
<span class="sd">        available for backwards compatibility--use ._header_offset instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span>

    <span class="nd">@_hdrLoc.setter</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._header_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_hdrLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The byte offset of this HDU&#39;s data portion in the file it came from;</span>
<span class="sd">        available for backwards compatibility--use ._data_offset instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>

    <span class="nd">@_datLoc.setter</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_size` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datSpan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The byte size of this HDU&#39;s data portion in the file it came from;</span>
<span class="sd">        available for backwards compatibility--use ._data_size instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span>

    <span class="nd">@_datSpan.setter</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_size` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datSpan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._header_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_hdrLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The byte offset of this HDU&#39;s header in the file it came from;</span>
<span class="sd">        available for backwards compatibility--use ._header_offset instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span>

    <span class="nd">@_hdrLoc.setter</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._header_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_hdrLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The byte offset of this HDU&#39;s data portion in the file it came from;</span>
<span class="sd">        available for backwards compatibility--use ._data_offset instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>

    <span class="nd">@_datLoc.setter</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_offset` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datLoc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_size` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datSpan</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The byte size of this HDU&#39;s data portion in the file it came from;</span>
<span class="sd">        available for backwards compatibility--use ._data_size instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span>

    <span class="nd">@_datSpan.setter</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the `._data_size` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_datSpan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">register_hdu</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">hducls</span><span class="p">):</span>
        <span class="n">cls</span><span class="o">.</span><span class="n">_hdu_registry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">hducls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">unregister_hdu</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">hducls</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">hducls</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_hdu_registry</span><span class="p">:</span>
            <span class="n">cls</span><span class="o">.</span><span class="n">_hdu_registry</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">hducls</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">fromstring</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ignore_missing_end</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new HDU object of the appropriate type from a string</span>
<span class="sd">        containing the HDU&#39;s entire header and, optionally, its data.</span>

<span class="sd">        Note: When creating a new HDU from a string without a backing file</span>
<span class="sd">        object, the data of that HDU may be read-only.  It depends on whether</span>
<span class="sd">        the underlying string was an immutable Python str/bytes object, or some</span>
<span class="sd">        kind of read-write memory buffer such as a `memoryview`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : str, bytearray, memoryview, ndarray</span>
<span class="sd">           A byte string containing the HDU&#39;s header and data.</span>

<span class="sd">        checksum : bool, optional</span>
<span class="sd">           Check the HDU&#39;s checksum and/or datasum.</span>

<span class="sd">        ignore_missing_end : bool, optional</span>
<span class="sd">           Ignore a missing end card in the header data.  Note that without the</span>
<span class="sd">           end card the end of the header may be ambiguous and resulted in a</span>
<span class="sd">           corrupt HDU.  In this case the assumption is that the first 2880</span>
<span class="sd">           block that does not begin with valid FITS header data is the</span>
<span class="sd">           beginning of the data.</span>

<span class="sd">        kwargs : optional</span>
<span class="sd">           May consist of additional keyword arguments specific to an HDU</span>
<span class="sd">           type--these correspond to keywords recognized by the constructors of</span>
<span class="sd">           different HDU classes such as `PrimaryHDU`, `ImageHDU`, or</span>
<span class="sd">           `BinTableHDU`.  Any unrecognized keyword arguments are simply</span>
<span class="sd">           ignored.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_readfrom_internal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">,</span>
                                      <span class="n">ignore_missing_end</span><span class="o">=</span><span class="n">ignore_missing_end</span><span class="p">,</span>
                                      <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">readfrom</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ignore_missing_end</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the HDU from a file.  Normally an HDU should be opened with</span>
<span class="sd">        :func:`open` which reads the entire HDU list in a FITS file.  But this</span>
<span class="sd">        method is still provided for symmetry with :func:`writeto`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fileobj : file object or file-like object</span>
<span class="sd">            Input FITS file.  The file&#39;s seek pointer is assumed to be at the</span>
<span class="sd">            beginning of the HDU.</span>

<span class="sd">        checksum : bool</span>
<span class="sd">            If `True`, verifies that both ``DATASUM`` and ``CHECKSUM`` card</span>
<span class="sd">            values (when present in the HDU header) match the header and data</span>
<span class="sd">            of all HDU&#39;s in the file.</span>

<span class="sd">        ignore_missing_end : bool</span>
<span class="sd">            Do not issue an exception when opening a file that is missing an</span>
<span class="sd">            ``END`` card in the last header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: Figure out a way to make it possible for the _File</span>
        <span class="c"># constructor to be a noop if the argument is already a _File</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">_File</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="n">_File</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>


        <span class="n">hdu</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_readfrom_internal</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">,</span>
                                     <span class="n">ignore_missing_end</span><span class="o">=</span><span class="n">ignore_missing_end</span><span class="p">,</span>
                                     <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c"># If the checksum had to be checked the data may have already been read</span>
        <span class="c"># from the file, in which case we don&#39;t want to seek relative</span>
        <span class="n">fileobj</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">hdu</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">+</span> <span class="n">hdu</span><span class="o">.</span><span class="n">_data_size</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdu</span>

    <span class="k">def</span> <span class="nf">writeto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">output_verify</span><span class="o">=</span><span class="s">&#39;exception&#39;</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the HDU to a new file.  This is a convenience method to</span>
<span class="sd">        provide a user easier output interface if only one HDU needs</span>
<span class="sd">        to be written to a file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : file path, file object or file-like object</span>
<span class="sd">            Output FITS file.  If the file object is already opened, it must</span>
<span class="sd">            be opened in a writeable mode.</span>

<span class="sd">        output_verify : str</span>
<span class="sd">            Output verification option.  Must be one of ``&quot;fix&quot;``,</span>
<span class="sd">            ``&quot;silentfix&quot;``, ``&quot;ignore&quot;``, ``&quot;warn&quot;``, or</span>
<span class="sd">            ``&quot;exception&quot;``.  May also be any combination of ``&quot;fix&quot;`` or</span>
<span class="sd">            ``&quot;silentfix&quot;`` with ``&quot;+ignore&quot;``, ``+warn``, or ``+exception&quot;</span>
<span class="sd">            (e.g. ``&quot;fix+warn&quot;``).  See :ref:`verify` for more info.</span>

<span class="sd">        clobber : bool</span>
<span class="sd">            Overwrite the output file if exists.</span>

<span class="sd">        checksum : bool</span>
<span class="sd">            When `True` adds both ``DATASUM`` and ``CHECKSUM`` cards</span>
<span class="sd">            to the header of the HDU when written to the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.hdulist</span> <span class="kn">import</span> <span class="n">HDUList</span>

        <span class="n">hdulist</span> <span class="o">=</span> <span class="n">HDUList</span><span class="p">([</span><span class="bp">self</span><span class="p">])</span>
        <span class="n">hdulist</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output_verify</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span>
                        <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_readfrom_internal</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                           <span class="n">ignore_missing_end</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Provides the bulk of the internal implementation for readfrom and</span>
<span class="sd">        fromstring.</span>

<span class="sd">        For some special cases, supports using a header that was already</span>
<span class="sd">        created, and just using the input data for the actual array data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">hdu_buffer</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">hdu_fileobj</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">header_offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">_File</span><span class="p">):</span>
            <span class="n">from_file</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">header_offset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="ow">not</span> <span class="n">ignore_missing_end</span><span class="p">)</span>
            <span class="n">hdu_fileobj</span> <span class="o">=</span> <span class="n">data</span>
            <span class="n">data_offset</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>  <span class="c"># *after* reading the header</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">from_file</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c"># Test that the given object supports the buffer interface by</span>
                <span class="c"># ensuring an ndarray can be created from it</span>
                <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">((),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;ubyte&#39;</span><span class="p">,</span> <span class="nb">buffer</span><span class="o">=</span><span class="n">data</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="s">&#39;The provided object </span><span class="si">%r</span><span class="s"> does not contain an underlying &#39;</span>
                    <span class="s">&#39;memory buffer.  fromstring() requires an object that &#39;</span>
                    <span class="s">&#39;supports the buffer interface such as bytes, str &#39;</span>
                    <span class="s">&#39;(in Python 2.x but not in 3.x), buffer, memoryview, &#39;</span>
                    <span class="s">&#39;ndarray, etc.  This restriction is to ensure that &#39;</span>
                    <span class="s">&#39;efficient access to the array/table data is possible.&#39;</span>
                    <span class="o">%</span> <span class="n">data</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">block_iter</span><span class="p">(</span><span class="n">nbytes</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">nbytes</span><span class="p">]</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="n">nbytes</span>

                <span class="n">header_str</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="o">.</span><span class="n">_from_blocks</span><span class="p">(</span>
                    <span class="n">block_iter</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="ow">not</span> <span class="n">ignore_missing_end</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_str</span><span class="p">):</span>
                    <span class="n">hdu_buffer</span> <span class="o">=</span> <span class="n">data</span>
            <span class="k">elif</span> <span class="n">data</span><span class="p">:</span>
                <span class="n">hdu_buffer</span> <span class="o">=</span> <span class="n">data</span>

            <span class="n">header_offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">data_offset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_str</span><span class="p">)</span>

        <span class="c"># Determine the appropriate arguments to pass to the constructor from</span>
        <span class="c"># self._kwargs.  self._kwargs contains any number of optional arguments</span>
        <span class="c"># that may or may not be valid depending on the HDU type</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">_hdu_class_from_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">signature</span><span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">__init__</span><span class="p">)</span>
        <span class="n">new_kwargs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="c"># If __init__ accepts arbitrary keyword arguments, then we can go</span>
            <span class="c"># ahead and pass all keyword arguments; otherwise we need to delete</span>
            <span class="c"># any that are invalid</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">new_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">hdu</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">DELAYED</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="o">**</span><span class="n">new_kwargs</span><span class="p">)</span>

        <span class="c"># One of these may be None, depending on whether the data came from a</span>
        <span class="c"># file or a string buffer--later this will be further abstracted</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">_file</span> <span class="o">=</span> <span class="n">hdu_fileobj</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">hdu_buffer</span>

        <span class="n">hdu</span><span class="o">.</span><span class="n">_header_offset</span> <span class="o">=</span> <span class="n">header_offset</span>     <span class="c"># beginning of the header area</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">=</span> <span class="n">data_offset</span>         <span class="c"># beginning of the data area</span>

        <span class="c"># data area size, including padding</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">size</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">_pad_length</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="c"># Checksums are not checked on invalid HDU types</span>
        <span class="k">if</span> <span class="n">checksum</span> <span class="ow">and</span> <span class="n">checksum</span> <span class="o">!=</span> <span class="s">&#39;remove&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">hdu</span><span class="p">,</span> <span class="n">_ValidHDU</span><span class="p">):</span>
            <span class="n">hdu</span><span class="o">.</span><span class="n">_verify_checksum_datasum</span><span class="p">(</span><span class="n">checksum</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">hdu</span>


    <span class="k">def</span> <span class="nf">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return raw array from either the HDU&#39;s memory buffer or underlying</span>
<span class="sd">        file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">code</span><span class="p">,</span> <span class="nb">buffer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">,</span>
                              <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">readarray</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">code</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="c"># TODO: Rework checksum handling so that it&#39;s not necessary to add a</span>
    <span class="c"># checksum argument here</span>
    <span class="c"># TODO: The BaseHDU class shouldn&#39;t even handle checksums since they&#39;re</span>
    <span class="c"># only implemented on _ValidHDU...</span>
    <span class="k">def</span> <span class="nf">_prewriteto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_uint_scale_keywords</span><span class="p">()</span>

        <span class="c"># Handle checksum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_checksum</span><span class="p">(</span><span class="n">checksum</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_update_uint_scale_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If the data is unsigned int 16, 32, or 64 add BSCALE/BZERO cards to</span>
<span class="sd">        header.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standard</span> <span class="ow">and</span>
                <span class="n">_is_pseudo_unsigned</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)):</span>
            <span class="k">if</span> <span class="s">&#39;GCOUNT&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BZERO&#39;</span><span class="p">,</span> <span class="n">_unsigned_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;BSCALE&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="p">,</span> <span class="n">checksum_keyword</span><span class="o">=</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">,</span>
                         <span class="n">datasum_keyword</span><span class="o">=</span><span class="s">&#39;DATASUM&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Update the &#39;CHECKSUM&#39; and &#39;DATASUM&#39; keywords in the header (or</span>
<span class="sd">        keywords with equivalent semantics given by the ``checksum_keyword``</span>
<span class="sd">        and ``datasum_keyword`` arguments--see for example ``CompImageHDU``</span>
<span class="sd">        for an example of why this might need to be overridden).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># If the data is loaded it isn&#39;t necessarily &#39;modified&#39;, but we have no</span>
        <span class="c"># way of knowing for sure</span>
        <span class="n">modified</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_modified</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span>

        <span class="k">if</span> <span class="n">checksum</span> <span class="o">==</span> <span class="s">&#39;remove&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">checksum_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">checksum_keyword</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">datasum_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">datasum_keyword</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">modified</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">checksum</span> <span class="ow">and</span> <span class="p">(</span><span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">or</span>
                               <span class="s">&#39;DATASUM&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">))):</span>
            <span class="k">if</span> <span class="n">checksum</span> <span class="o">==</span> <span class="s">&#39;datasum&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_datasum</span><span class="p">(</span><span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">checksum</span> <span class="o">==</span> <span class="s">&#39;nonstandard_datasum&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="s">&#39;nonstandard&#39;</span><span class="p">,</span>
                                 <span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">checksum</span> <span class="o">==</span> <span class="s">&#39;test&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_datasum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_datasum_comment</span><span class="p">,</span>
                                 <span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_checksum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_checksum_comment</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span>
                                  <span class="n">checksum_keyword</span><span class="o">=</span><span class="n">checksum_keyword</span><span class="p">,</span>
                                  <span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">checksum</span> <span class="o">==</span> <span class="s">&#39;nonstandard&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_checksum</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="s">&#39;nonstandard&#39;</span><span class="p">,</span>
                                  <span class="n">checksum_keyword</span><span class="o">=</span><span class="n">checksum_keyword</span><span class="p">,</span>
                                  <span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">checksum</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_checksum</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="s">&#39;standard&#39;</span><span class="p">,</span>
                                  <span class="n">checksum_keyword</span><span class="o">=</span><span class="n">checksum_keyword</span><span class="p">,</span>
                                  <span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_postwriteto</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># If data is unsigned integer 16, 32 or 64, remove the</span>
        <span class="c"># BSCALE/BZERO cards</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_standard</span> <span class="ow">and</span>
                <span class="n">_is_pseudo_unsigned</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="s">&#39;BZERO&#39;</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_writeheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">-</span> <span class="n">offset</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">IOError</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_writedata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="c"># TODO: A lot of the simulateonly stuff should be moved back into the</span>
        <span class="c"># _File class--basically it should turn write and flush into a noop</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_needs_rescale</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writedata_internal</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
            <span class="c"># pad the FITS data block</span>
            <span class="k">if</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">padding</span> <span class="o">=</span> <span class="n">_pad_length</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_padding_byte</span>
                <span class="c"># TODO: Not that this is ever likely, but if for some odd</span>
                <span class="c"># reason _padding_byte is &gt; 0x80 this will fail; but really if</span>
                <span class="c"># somebody&#39;s custom fits format is doing that, they&#39;re doing it</span>
                <span class="c"># wrong and should be reprimanded harshly.</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">padding</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">))</span>
                <span class="n">size</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># The data has not been modified or does not need need to be</span>
            <span class="c"># rescaled, so it can be copied, unmodified, directly from an</span>
            <span class="c"># existing file or buffer</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writedata_direct_copy</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>


        <span class="c"># flush, to make sure the content is written</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c"># return both the location and the size of the data area</span>
        <span class="k">return</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_writedata_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The beginning and end of most _writedata() implementations are the</span>
<span class="sd">        same, but the details of writing the data array itself can vary between</span>
<span class="sd">        HDU types, so that should be implemented in this method.</span>

<span class="sd">        Should return the size in bytes of the data written.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">itemsize</span>

    <span class="k">def</span> <span class="nf">_writedata_direct_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Copies the data directly from one file/buffer to the new file.</span>

<span class="sd">        For now this is handled by loading the raw data from the existing data</span>
<span class="sd">        (including any padding) via a memory map or from an already in-memory</span>
<span class="sd">        buffer and using Numpy&#39;s existing file-writing facilities to write to</span>
<span class="sd">        the new file.</span>

<span class="sd">        If this proves too slow a more direct approach may be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">raw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span><span class="p">,</span> <span class="s">&#39;ubyte&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">raw</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">raw</span><span class="o">.</span><span class="n">nbytes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="c"># TODO: This is the start of moving HDU writing out of the _File class;</span>
    <span class="c"># Though right now this is an internal private method (though still used by</span>
    <span class="c"># HDUList, eventually the plan is to have this be moved into writeto()</span>
    <span class="c"># somehow...</span>
    <span class="k">def</span> <span class="nf">_writeto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c"># For now fileobj is assumed to be a _File object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inplace</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
            <span class="n">header_offset</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writeheader</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
            <span class="n">data_offset</span><span class="p">,</span> <span class="n">data_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writedata</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

            <span class="c"># Set the various data location attributes on newly-written HDUs</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_new</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span> <span class="o">=</span> <span class="n">header_offset</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">=</span> <span class="n">data_offset</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">=</span> <span class="n">data_size</span>
            <span class="k">return</span>

        <span class="n">hdrloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span>
        <span class="n">hdrsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span>
        <span class="n">datloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>
        <span class="n">datsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_modified</span><span class="p">:</span>
            <span class="c"># Seek to the original header location in the file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">hdrloc</span><span class="p">)</span>
            <span class="c"># This should update hdrloc with he header location in the new file</span>
            <span class="n">hdrloc</span><span class="p">,</span> <span class="n">hdrsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writeheader</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

            <span class="c"># If the data is to be written below with self._writedata, that</span>
            <span class="c"># will also properly update the data location; but it should be</span>
            <span class="c"># updated here too</span>
            <span class="n">datloc</span> <span class="o">=</span> <span class="n">hdrloc</span> <span class="o">+</span> <span class="n">hdrsize</span>
        <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
            <span class="c"># Seek to the original header location in the file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">hdrloc</span><span class="p">)</span>
            <span class="c"># Before writing, update the hdrloc with the current file position,</span>
            <span class="c"># which is the hdrloc for the new file</span>
            <span class="n">hdrloc</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">hdrsize</span><span class="p">))</span>
            <span class="c"># The header size is unchanged, but the data location may be</span>
            <span class="c"># different from before depending on if previous HDUs were resized</span>
            <span class="n">datloc</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># Seek through the array&#39;s bases for an memmap&#39;d array; we</span>
                <span class="c"># can&#39;t rely on the _File object to give us this info since the</span>
                <span class="c"># user may have replaced the previous mmap&#39;d array</span>
                <span class="k">if</span> <span class="n">copy</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span><span class="p">:</span>
                    <span class="c"># Of course, if we&#39;re copying the data to a new file we</span>
                    <span class="c"># don&#39;t care about flushing the original mmap; instead just</span>
                    <span class="c"># read it into the new file</span>
                    <span class="n">array_mmap</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">array_mmap</span> <span class="o">=</span> <span class="n">_get_array_mmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">array_mmap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">array_mmap</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
                    <span class="n">datloc</span><span class="p">,</span> <span class="n">datsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writedata</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">copy</span><span class="p">:</span>
            <span class="n">datsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writedata_direct_copy</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span> <span class="o">=</span> <span class="n">hdrloc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span> <span class="o">=</span> <span class="n">datloc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">=</span> <span class="n">datsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="c"># If the data was mmap&#39;d, close the underlying mmap (this will</span>
        <span class="c"># prevent any future access to the .data attribute if there are</span>
        <span class="c"># not other references to it; if there are other references then</span>
        <span class="c"># it is up to the user to clean those up</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">closed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span> <span class="ow">and</span>
                <span class="n">_get_array_mmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

<span class="c"># For backwards-compatibility, though nobody should have</span>
<span class="c"># been using this directly:</span>
<span class="n">_AllHDU</span> <span class="o">=</span> <span class="n">_BaseHDU</span>

<span class="c"># For convenience...</span>
<span class="c"># TODO: register_hdu could be made into a class decorator which would be pretty</span>
<span class="c"># cool, but only once 2.6 support is dropped.</span>
<span class="n">register_hdu</span> <span class="o">=</span> <span class="n">_BaseHDU</span><span class="o">.</span><span class="n">register_hdu</span>
<span class="n">unregister_hdu</span> <span class="o">=</span> <span class="n">_BaseHDU</span><span class="o">.</span><span class="n">unregister_hdu</span>


<span class="k">class</span> <span class="nc">_CorruptedHDU</span><span class="p">(</span><span class="n">_BaseHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Corrupted HDU class.</span>

<span class="sd">    This class is used when one or more mandatory `Card`s are</span>
<span class="sd">    corrupted (unparsable), such as the ``BITPIX``, ``NAXIS``, or</span>
<span class="sd">    ``END`` cards.  A corrupted HDU usually means that the data size</span>
<span class="sd">    cannot be calculated or the ``END`` card is not found.  In the case</span>
<span class="sd">    of a missing ``END`` card, the `Header` may also contain the binary</span>
<span class="sd">    data</span>

<span class="sd">    .. note::</span>
<span class="sd">       In future, it may be possible to decipher where the last block</span>
<span class="sd">       of the `Header` ends, but this task may be difficult when the</span>
<span class="sd">       extension is a `TableHDU` containing ASCII data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size (in bytes) of the HDU&#39;s data part.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Note: On compressed files this might report a negative size; but the</span>
        <span class="c"># file is corrupt anyways so I&#39;m not too worried about it.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;CorruptedHDU&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">verify</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>


<span class="k">class</span> <span class="nc">_NonstandardHDU</span><span class="p">(</span><span class="n">_BaseHDU</span><span class="p">,</span> <span class="n">_Verify</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Non-standard HDU class.</span>

<span class="sd">    This class is used for a Primary HDU when the ``SIMPLE`` Card has</span>
<span class="sd">    a value of `False`.  A non-standard HDU comes from a file that</span>
<span class="sd">    resembles a FITS file but departs from the standards in some</span>
<span class="sd">    significant way.  One example would be files where the numbers are</span>
<span class="sd">    in the DEC VAX internal storage format rather than the standard</span>
<span class="sd">    FITS most significant byte first.  The header for this HDU should</span>
<span class="sd">    be valid.  The data for this HDU is read from the file as a byte</span>
<span class="sd">    stream that begins at the first byte after the header ``END`` card</span>
<span class="sd">    and continues until the end of the file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_standard</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matches any HDU that has the &#39;SIMPLE&#39; keyword but is not a standard</span>
<span class="sd">        Primary or Groups HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># The SIMPLE keyword must be in the first card</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c"># The check that &#39;GROUPS&#39; is missing is a bit redundant, since the</span>
        <span class="c"># match_header for GroupsHDU will always be called before this one.</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;SIMPLE&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&#39;GROUPS&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header</span> <span class="ow">and</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="bp">False</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidHDUException</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size (in bytes) of the HDU&#39;s data part.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span>

    <span class="k">def</span> <span class="nf">_writedata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Differs from the base class :class:`_writedata` in that it doesn&#39;t</span>
<span class="sd">        automatically add padding, and treats the data as a string of raw bytes</span>
<span class="sd">        instead of an array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
                <span class="c"># flush, to make sure the content is written</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
                <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="c"># return both the location and the size of the data area</span>
        <span class="k">return</span> <span class="n">offset</span><span class="p">,</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;NonstandardHDU&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the file data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s">&#39;ubyte&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">):</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="n">_ErrList</span><span class="p">([],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Card&#39;</span><span class="p">)</span>

        <span class="c"># verify each card</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
            <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">errs</span>


<span class="k">class</span> <span class="nc">_ValidHDU</span><span class="p">(</span><span class="n">_BaseHDU</span><span class="p">,</span> <span class="n">_Verify</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class for all HDUs which are not corrupted.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_ValidHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matches any HDU that is not recognized as having either the SIMPLE or</span>
<span class="sd">        XTENSION keyword in its header&#39;s first card, but is nonetheless not</span>
<span class="sd">        corrupted.</span>

<span class="sd">        TODO: Maybe it would make more sense to use _NonstandardHDU in this</span>
<span class="sd">        case?  Not sure...</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">first</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="s">&#39;XTENSION&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Size (in bytes) of the data portion of the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">naxis</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">naxis</span><span class="p">):</span>
                <span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="n">bitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span>
            <span class="n">gcount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">pcount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">size</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bitpix</span><span class="p">)</span> <span class="o">*</span> <span class="n">gcount</span> <span class="o">*</span> <span class="p">(</span><span class="n">pcount</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">8</span>
        <span class="k">return</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">filebytes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates and returns the number of bytes that this HDU will write to</span>
<span class="sd">        a file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">f</span> <span class="o">=</span> <span class="n">_File</span><span class="p">()</span>
        <span class="c"># TODO: Fix this once new HDU writing API is settled on</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writeheader</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">_writedata</span><span class="p">(</span><span class="n">f</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">fileinfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dictionary detailing information about the locations</span>
<span class="sd">        of this HDU within any associated file.  The values are only</span>
<span class="sd">        valid after a read or write of the associated file with no</span>
<span class="sd">        intervening changes to the `HDUList`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict or None</span>

<span class="sd">           The dictionary details information about the locations of</span>
<span class="sd">           this HDU within an associated file.  Returns `None` when</span>
<span class="sd">           the HDU is not associated with a file.</span>

<span class="sd">           Dictionary contents:</span>

<span class="sd">           ========== ================================================</span>
<span class="sd">           Key        Value</span>
<span class="sd">           ========== ================================================</span>
<span class="sd">           file       File object associated with the HDU</span>
<span class="sd">           filemode   Mode in which the file was opened (readonly, copyonwrite,</span>
<span class="sd">                      update, append, ostream)</span>
<span class="sd">           hdrLoc     Starting byte location of header in file</span>
<span class="sd">           datLoc     Starting byte location of data block in file</span>
<span class="sd">           datSpan    Data size including padding</span>
<span class="sd">           ========== ================================================</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_file&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s">&#39;file&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">,</span> <span class="s">&#39;filemode&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span>
                    <span class="s">&#39;hdrLoc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_offset</span><span class="p">,</span> <span class="s">&#39;datLoc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">,</span>
                    <span class="s">&#39;datSpan&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the HDU, both header and data are copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the ``.name`` attribute or `Header.set`&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_ext_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                        <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">savecomment</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the extension name associated with the HDU.</span>

<span class="sd">        If the keyword already exists in the Header, it&#39;s value and/or comment</span>
<span class="sd">        will be updated.  If it does not exist, a new card will be created</span>
<span class="sd">        and it will be placed before or after the specified location.</span>
<span class="sd">        If no ``before`` or ``after`` is specified, it will be appended at</span>
<span class="sd">        the end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Value to be used for the new extension name</span>

<span class="sd">        comment : str, optional</span>
<span class="sd">            To be used for updating, default=None.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` before which the new</span>
<span class="sd">            card will be placed in the Header.  The argument ``before`` takes</span>
<span class="sd">            precedence over ``after`` if both are specified.</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` after which</span>
<span class="sd">            the new card will be placed in the Header</span>

<span class="sd">        savecomment : bool, optional</span>
<span class="sd">            When `True`, preserve the current comment for an existing</span>
<span class="sd">            keyword.  The argument ``savecomment`` takes precedence over</span>
<span class="sd">            ``comment`` if both specified.  If ``comment`` is not</span>
<span class="sd">            specified then the current comment will automatically be</span>
<span class="sd">            preserved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;EXTNAME&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">and</span> <span class="n">savecomment</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>
        <span class="c"># This may seem redundant, but the previous header.set call just</span>
        <span class="c"># handles anyone who might use the before/after keywords to set the</span>
        <span class="c"># position of the EXTNAME keyword.  Setting self.name = name does some</span>
        <span class="c"># additional processing on the value such as handling</span>
        <span class="c"># conf.extension_name_case_sensitive</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the ``.ver`` attribute or `Header.set`&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">update_ext_version</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                           <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">savecomment</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the extension version associated with the HDU.</span>

<span class="sd">        If the keyword already exists in the Header, it&#39;s value and/or comment</span>
<span class="sd">        will be updated.  If it does not exist, a new card will be created</span>
<span class="sd">        and it will be placed before or after the specified location.</span>
<span class="sd">        If no ``before`` or ``after`` is specified, it will be appended at</span>
<span class="sd">        the end.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : str</span>
<span class="sd">            Value to be used for the new extension version</span>

<span class="sd">        comment : str, optional</span>
<span class="sd">            To be used for updating; default=None.</span>

<span class="sd">        before : str or int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` before which the new</span>
<span class="sd">            card will be placed in the Header.  The argument ``before`` takes</span>
<span class="sd">            precedence over ``after`` if both are specified.</span>

<span class="sd">        after : str or int, optional</span>
<span class="sd">            Name of the keyword, or index of the `Card` after which</span>
<span class="sd">            the new card will be placed in the Header.</span>

<span class="sd">        savecomment : bool, optional</span>
<span class="sd">            When `True`, preserve the current comment for an existing</span>
<span class="sd">            keyword.  The argument ``savecomment`` takes precedence over</span>
<span class="sd">            ``comment`` if both specified.  If ``comment`` is not</span>
<span class="sd">            specified then the current comment will automatically be</span>
<span class="sd">            preserved.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;EXTVER&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">and</span> <span class="n">savecomment</span><span class="p">:</span>
            <span class="n">comment</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;EXTVER&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">comment</span><span class="p">,</span> <span class="n">before</span><span class="p">,</span> <span class="n">after</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">):</span>
        <span class="n">errs</span> <span class="o">=</span> <span class="n">_ErrList</span><span class="p">([],</span> <span class="n">unit</span><span class="o">=</span><span class="s">&#39;Card&#39;</span><span class="p">)</span>

        <span class="n">is_valid</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="o">-</span><span class="mi">32</span><span class="p">,</span> <span class="o">-</span><span class="mi">64</span><span class="p">]</span>

        <span class="c"># Verify location and value of mandatory keywords.</span>
        <span class="c"># Do the first card here, instead of in the respective HDU classes, so</span>
        <span class="c"># the checking is in order, in case of required cards in wrong order.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ExtensionHDU</span><span class="p">):</span>
            <span class="n">firstkey</span> <span class="o">=</span> <span class="s">&#39;XTENSION&#39;</span>
            <span class="n">firstval</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">firstkey</span> <span class="o">=</span> <span class="s">&#39;SIMPLE&#39;</span>
            <span class="n">firstval</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="n">firstkey</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">firstval</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span> <span class="mi">8</span><span class="p">,</span>
                       <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                       <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">999</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                       <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>

        <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">naxis</span> <span class="o">&lt;</span> <span class="mi">1000</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">naxis</span> <span class="o">+</span> <span class="mi">3</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ax</span> <span class="o">-</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ax</span><span class="p">,</span>
                               <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
                               <span class="n">errs</span><span class="p">)</span>

            <span class="c"># Remove NAXISj cards where j is not in range 1, naxis inclusive.</span>
            <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">keyword</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">number</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>
                        <span class="k">if</span> <span class="n">number</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">number</span> <span class="o">&gt;</span> <span class="n">naxis</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">ValueError</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">err_text</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;NAXISj keyword out of range (&#39;</span><span class="si">%s</span><span class="s">&#39; when &quot;</span>
                                    <span class="s">&quot;NAXIS == </span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">naxis</span><span class="p">))</span>

                        <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="n">keyword</span><span class="p">):</span>
                            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

                        <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">run_option</span><span class="p">(</span><span class="n">option</span><span class="o">=</span><span class="n">option</span><span class="p">,</span> <span class="n">err_text</span><span class="o">=</span><span class="n">err_text</span><span class="p">,</span>
                                            <span class="n">fix</span><span class="o">=</span><span class="n">fix</span><span class="p">,</span> <span class="n">fix_text</span><span class="o">=</span><span class="s">&quot;Deleted.&quot;</span><span class="p">))</span>

        <span class="c"># Verify that the EXTNAME keyword exists and is a string</span>
        <span class="k">if</span> <span class="s">&#39;EXTNAME&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">],</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="n">err_text</span> <span class="o">=</span> <span class="s">&#39;The EXTNAME keyword must have a string value.&#39;</span>
                <span class="n">fix_text</span> <span class="o">=</span> <span class="s">&#39;Converted the EXTNAME keyword to a string value.&#39;</span>

                <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">):</span>
                    <span class="n">header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">])</span>

                <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_option</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">err_text</span><span class="o">=</span><span class="n">err_text</span><span class="p">,</span>
                                            <span class="n">fix_text</span><span class="o">=</span><span class="n">fix_text</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="n">fix</span><span class="p">))</span>

        <span class="c"># verify each card</span>
        <span class="k">for</span> <span class="n">card</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">cards</span><span class="p">:</span>
            <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">errs</span>

    <span class="c"># TODO: Improve this API a little bit--for one, most of these arguments</span>
    <span class="c"># could be optional</span>
    <span class="k">def</span> <span class="nf">req_cards</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">fix_value</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check the existence, location, and value of a required `Card`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keyword : str</span>
<span class="sd">            The keyword to validate</span>

<span class="sd">        pos : int, callable</span>
<span class="sd">            If an ``int``, this specifies the exact location this card should</span>
<span class="sd">            have in the header.  Remember that Python is zero-indexed, so this</span>
<span class="sd">            means ``pos=0`` requires the card to be the first card in the</span>
<span class="sd">            header.  If given a callable, it should take one argument--the</span>
<span class="sd">            actual position of the keyword--and return `True` or `False`.  This</span>
<span class="sd">            can be used for custom evaluation.  For example if</span>
<span class="sd">            ``pos=lambda idx: idx &gt; 10`` this will check that the keyword&#39;s</span>
<span class="sd">            index is greater than 10.</span>

<span class="sd">        test : callable</span>
<span class="sd">            This should be a callable (generally a function) that is passed the</span>
<span class="sd">            value of the given keyword and returns `True` or `False`.  This can</span>
<span class="sd">            be used to validate the value associated with the given keyword.</span>

<span class="sd">        fix_value : str, int, float, complex, bool, None</span>
<span class="sd">            A valid value for a FITS keyword to to use if the given ``test``</span>
<span class="sd">            fails to replace an invalid value.  In other words, this provides</span>
<span class="sd">            a default value to use as a replacement if the keyword&#39;s current</span>
<span class="sd">            value is invalid.  If `None`, there is no replacement value and the</span>
<span class="sd">            keyword is unfixable.</span>

<span class="sd">        option : str</span>
<span class="sd">            Output verification option.  Must be one of ``&quot;fix&quot;``,</span>
<span class="sd">            ``&quot;silentfix&quot;``, ``&quot;ignore&quot;``, ``&quot;warn&quot;``, or</span>
<span class="sd">            ``&quot;exception&quot;``.  May also be any combination of ``&quot;fix&quot;`` or</span>
<span class="sd">            ``&quot;silentfix&quot;`` with ``&quot;+ignore&quot;``, ``+warn``, or ``+exception&quot;</span>
<span class="sd">            (e.g. ``&quot;fix+warn&quot;``).  See :ref:`verify` for more info.</span>

<span class="sd">        errlist : list</span>
<span class="sd">            A list of validation errors already found in the FITS file; this is</span>
<span class="sd">            used primarily for the validation system to collect errors across</span>
<span class="sd">            multiple HDUs and multiple calls to `req_cards`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``pos=None``, the card can be anywhere in the header.  If the card</span>
<span class="sd">        does not exist, the new card will have the ``fix_value`` as its value</span>
<span class="sd">        when created.  Also check the card&#39;s value by using the ``test``</span>
<span class="sd">        argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">errs</span> <span class="o">=</span> <span class="n">errlist</span>
        <span class="n">fix</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="n">fixable</span> <span class="o">=</span> <span class="n">fix_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span>

        <span class="n">insert_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c"># If pos is an int, insert at the given position (and convert it to a</span>
        <span class="c"># lambda)</span>
        <span class="k">if</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">pos</span><span class="p">):</span>
            <span class="n">insert_pos</span> <span class="o">=</span> <span class="n">pos</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">==</span> <span class="n">insert_pos</span>

        <span class="c"># if the card does not exist</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">err_text</span> <span class="o">=</span> <span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; card does not exist.&quot;</span> <span class="o">%</span> <span class="n">keyword</span>
            <span class="n">fix_text</span> <span class="o">=</span> <span class="s">&quot;Fixed by inserting a new &#39;</span><span class="si">%s</span><span class="s">&#39; card.&quot;</span> <span class="o">%</span> <span class="n">keyword</span>
            <span class="k">if</span> <span class="n">fixable</span><span class="p">:</span>
                <span class="c"># use repr to accommodate both string and non-string types</span>
                <span class="c"># Boolean is also OK in this constructor</span>
                <span class="n">card</span> <span class="o">=</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">fix_value</span><span class="p">)</span>

                <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">insert_pos</span><span class="o">=</span><span class="n">insert_pos</span><span class="p">,</span> <span class="n">card</span><span class="o">=</span><span class="n">card</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">insert_pos</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>

            <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_option</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">err_text</span><span class="o">=</span><span class="n">err_text</span><span class="p">,</span>
                        <span class="n">fix_text</span><span class="o">=</span><span class="n">fix_text</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="n">fix</span><span class="p">,</span> <span class="n">fixable</span><span class="o">=</span><span class="n">fixable</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># if the supposed location is specified</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">pos</span><span class="p">(</span><span class="n">index</span><span class="p">):</span>
                    <span class="n">err_text</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; card at the wrong place (card </span><span class="si">%d</span><span class="s">).&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">index</span><span class="p">))</span>

                    <span class="n">fix_text</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;Fixed by moving it to the right place &quot;</span>
                                <span class="s">&quot;(card </span><span class="si">%d</span><span class="s">).&quot;</span> <span class="o">%</span> <span class="n">insert_pos</span><span class="p">)</span>

                    <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">index</span><span class="p">,</span> <span class="n">insert_pos</span><span class="o">=</span><span class="n">insert_pos</span><span class="p">):</span>
                        <span class="n">card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">insert_pos</span><span class="p">,</span> <span class="n">card</span><span class="p">)</span>

                    <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_option</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">err_text</span><span class="o">=</span><span class="n">err_text</span><span class="p">,</span>
                                <span class="n">fix_text</span><span class="o">=</span><span class="n">fix_text</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="n">fix</span><span class="p">))</span>

            <span class="c"># if value checking is specified</span>
            <span class="k">if</span> <span class="n">test</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
                    <span class="n">err_text</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;&#39;</span><span class="si">%s</span><span class="s">&#39; card has invalid value &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
                    <span class="n">fix_text</span> <span class="o">=</span> <span class="s">&quot;Fixed by setting a new value &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">fix_value</span>

                    <span class="k">if</span> <span class="n">fixable</span><span class="p">:</span>
                        <span class="k">def</span> <span class="nf">fix</span><span class="p">(</span><span class="bp">self</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">keyword</span><span class="o">=</span><span class="n">keyword</span><span class="p">,</span> <span class="n">val</span><span class="o">=</span><span class="n">fix_value</span><span class="p">):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">fix_value</span>

                    <span class="n">errs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_option</span><span class="p">(</span><span class="n">option</span><span class="p">,</span> <span class="n">err_text</span><span class="o">=</span><span class="n">err_text</span><span class="p">,</span>
                                <span class="n">fix_text</span><span class="o">=</span><span class="n">fix_text</span><span class="p">,</span> <span class="n">fix</span><span class="o">=</span><span class="n">fix</span><span class="p">,</span> <span class="n">fixable</span><span class="o">=</span><span class="n">fixable</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">errs</span>

    <span class="k">def</span> <span class="nf">add_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">when</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="s">&#39;standard&#39;</span><span class="p">,</span>
                    <span class="n">datasum_keyword</span><span class="o">=</span><span class="s">&#39;DATASUM&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the ``DATASUM`` card to this HDU with the value set to the</span>
<span class="sd">        checksum calculated for the data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        when : str, optional</span>
<span class="sd">            Comment string for the card that by default represents the</span>
<span class="sd">            time when the checksum was calculated</span>

<span class="sd">        blocking : str, optional</span>
<span class="sd">            &quot;standard&quot; or &quot;nonstandard&quot;, compute sum 2880 bytes at a time, or</span>
<span class="sd">            not</span>

<span class="sd">        datasum_keyword : str, optional</span>
<span class="sd">            The name of the header keyword to store the datasum value in;</span>
<span class="sd">            this is typically &#39;DATASUM&#39; per convention, but there exist</span>
<span class="sd">            use cases in which a different keyword should be used</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        checksum : int</span>
<span class="sd">            The calculated datasum</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For testing purposes, provide a ``when`` argument to enable the comment</span>
<span class="sd">        value in the card to remain consistent.  This will enable the</span>
<span class="sd">        generation of a ``CHECKSUM`` card with a consistent value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">when</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">when</span> <span class="o">=</span> <span class="s">&#39;data unit checksum updated </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_timestamp</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">datasum_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">when</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cs</span>

    <span class="k">def</span> <span class="nf">add_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">when</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">override_datasum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                     <span class="n">blocking</span><span class="o">=</span><span class="s">&#39;standard&#39;</span><span class="p">,</span> <span class="n">checksum_keyword</span><span class="o">=</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">,</span>
                     <span class="n">datasum_keyword</span><span class="o">=</span><span class="s">&#39;DATASUM&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add the ``CHECKSUM`` and ``DATASUM`` cards to this HDU with</span>
<span class="sd">        the values set to the checksum calculated for the HDU and the</span>
<span class="sd">        data respectively.  The addition of the ``DATASUM`` card may</span>
<span class="sd">        be overridden.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        when : str, optional</span>
<span class="sd">           comment string for the cards; by default the comments</span>
<span class="sd">           will represent the time when the checksum was calculated</span>

<span class="sd">        override_datasum : bool, optional</span>
<span class="sd">           add the ``CHECKSUM`` card only</span>

<span class="sd">        blocking : str, optional</span>
<span class="sd">            &quot;standard&quot; or &quot;nonstandard&quot;, compute sum 2880 bytes at a time, or</span>
<span class="sd">            not</span>

<span class="sd">        checksum_keyword : str, optional</span>
<span class="sd">            The name of the header keyword to store the checksum value in; this</span>
<span class="sd">            is typically &#39;CHECKSUM&#39; per convention, but there exist use cases</span>
<span class="sd">            in which a different keyword should be used</span>

<span class="sd">        datasum_keyword : str, optional</span>
<span class="sd">            See ``checksum_keyword``</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For testing purposes, first call `add_datasum` with a ``when``</span>
<span class="sd">        argument, then call `add_checksum` with a ``when`` argument and</span>
<span class="sd">        ``override_datasum`` set to `True`.  This will provide consistent</span>
<span class="sd">        comments for both cards and enable the generation of a ``CHECKSUM``</span>
<span class="sd">        card with a consistent value.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">override_datasum</span><span class="p">:</span>
            <span class="c"># Calculate and add the data checksum to the header.</span>
            <span class="n">data_cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_datasum</span><span class="p">(</span><span class="n">when</span><span class="p">,</span> <span class="n">blocking</span><span class="p">,</span>
                                       <span class="n">datasum_keyword</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Just calculate the data checksum</span>
            <span class="n">data_cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">when</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">when</span> <span class="o">=</span> <span class="s">&#39;HDU checksum updated </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_timestamp</span><span class="p">()</span>

        <span class="c"># Add the CHECKSUM card to the header with a value of all zeros.</span>
        <span class="k">if</span> <span class="n">datasum_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">checksum_keyword</span><span class="p">,</span> <span class="s">&#39;0&#39;</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="n">when</span><span class="p">,</span>
                             <span class="n">before</span><span class="o">=</span><span class="n">datasum_keyword</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">checksum_keyword</span><span class="p">,</span> <span class="s">&#39;0&#39;</span> <span class="o">*</span> <span class="mi">16</span><span class="p">,</span> <span class="n">when</span><span class="p">)</span>

        <span class="n">csum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_checksum</span><span class="p">(</span><span class="n">data_cs</span><span class="p">,</span> <span class="n">blocking</span><span class="p">,</span>
                                        <span class="n">checksum_keyword</span><span class="o">=</span><span class="n">checksum_keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">checksum_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">csum</span>

    <span class="k">def</span> <span class="nf">verify_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="s">&#39;standard&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the value in the ``DATASUM`` keyword matches the value</span>
<span class="sd">        calculated for the ``DATASUM`` of the current HDU data.</span>

<span class="sd">        blocking : str, optional</span>
<span class="sd">            &quot;standard&quot; or &quot;nonstandard&quot;, compute sum 2880 bytes at a time, or</span>
<span class="sd">            not</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valid : int</span>
<span class="sd">           - 0 - failure</span>
<span class="sd">           - 1 - success</span>
<span class="sd">           - 2 - no ``DATASUM`` keyword present</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;DATASUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">datasum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">datasum</span> <span class="o">==</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">]):</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">blocking</span> <span class="o">==</span> <span class="s">&#39;either&#39;</span><span class="p">:</span>
                <span class="c"># i.e. standard failed,  try nonstandard</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="s">&#39;nonstandard&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Failed with all permitted blocking kinds</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">verify_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="s">&#39;standard&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify that the value in the ``CHECKSUM`` keyword matches the</span>
<span class="sd">        value calculated for the current HDU CHECKSUM.</span>

<span class="sd">        blocking : str, optional</span>
<span class="sd">            &quot;standard&quot; or &quot;nonstandard&quot;, compute sum 2880 bytes at a time, or</span>
<span class="sd">            not</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        valid : int</span>
<span class="sd">           - 0 - failure</span>
<span class="sd">           - 1 - success</span>
<span class="sd">           - 2 - no ``CHECKSUM`` keyword present</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="k">if</span> <span class="s">&#39;DATASUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="n">datasum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">datasum</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">checksum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_checksum</span><span class="p">(</span><span class="n">datasum</span><span class="p">,</span> <span class="n">blocking</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">checksum</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">blocking</span> <span class="o">==</span> <span class="s">&#39;either&#39;</span><span class="p">:</span>
                <span class="c"># i.e. standard failed,  try nonstandard</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_checksum</span><span class="p">(</span><span class="n">blocking</span><span class="o">=</span><span class="s">&#39;nonstandard&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Failed with all permitted blocking kinds</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>

    <span class="k">def</span> <span class="nf">_verify_checksum_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Verify the checksum/datasum values if the cards exist in the header.</span>
<span class="sd">        Simply displays warnings if either the checksum or datasum don&#39;t match.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># NOTE:  private data members _checksum and _datasum are</span>
        <span class="c"># used by the utility script &quot;fitscheck&quot; to detect missing</span>
        <span class="c"># checksums.</span>

        <span class="k">if</span> <span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checksum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checksum_comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_checksum</span><span class="p">(</span><span class="n">blocking</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;Checksum verification failed for HDU {0}.</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ver</span><span class="p">)),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checksum</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checksum_comment</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="s">&#39;DATASUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datasum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datasum_comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">]</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">verify_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s">&#39;Datasum verification failed for HDU {0}.</span><span class="se">\n</span><span class="s">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ver</span><span class="p">)),</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checksum</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_checksum_comment</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datasum</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_datasum_comment</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">_get_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the current timestamp in ISO 8601 format, with microseconds</span>
<span class="sd">        stripped off.</span>

<span class="sd">        Ex.: 2007-05-30T19:05:11</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">isoformat</span><span class="p">()[:</span><span class="mi">19</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_calculate_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card in the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="c"># This is the case where the data has not been read from the file</span>
            <span class="c"># yet.  We find the data in the file, read it, and calculate the</span>
            <span class="c"># datasum.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span><span class="p">,</span> <span class="s">&#39;ubyte&#39;</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">raw_data</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="n">blocking</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;ubyte&#39;</span><span class="p">),</span>
                                          <span class="n">blocking</span><span class="o">=</span><span class="n">blocking</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_calculate_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datasum</span><span class="p">,</span> <span class="n">blocking</span><span class="p">,</span>
                            <span class="n">checksum_keyword</span><span class="o">=</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value of the ``CHECKSUM`` card in the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">old_checksum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">checksum_keyword</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">checksum_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;0&#39;</span> <span class="o">*</span> <span class="mi">16</span>

        <span class="c"># Convert the header to a string.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>

        <span class="c"># Calculate the checksum of the Header and data.</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;ubyte&#39;</span><span class="p">),</span> <span class="n">datasum</span><span class="p">,</span>
                                    <span class="n">blocking</span><span class="o">=</span><span class="n">blocking</span><span class="p">)</span>

        <span class="c"># Encode the checksum into a string.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_char_encode</span><span class="p">(</span><span class="o">~</span><span class="n">cs</span><span class="p">)</span>

        <span class="c"># Return the header card value.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">checksum_keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_checksum</span>

        <span class="k">return</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">_compute_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sum32</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="s">&quot;standard&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the ones-complement checksum of a sequence of bytes.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data</span>
<span class="sd">            a memory region to checksum</span>

<span class="sd">        sum32</span>
<span class="sd">            incremental checksum value from another region</span>

<span class="sd">        blocking</span>
<span class="sd">            &quot;standard&quot;, &quot;nonstandard&quot;, or &quot;either&quot;</span>
<span class="sd">            selects the block size on which to perform checksumming,</span>
<span class="sd">            originally the blocksize was chosen incorrectly.  &quot;nonstandard&quot;</span>
<span class="sd">            selects the original approach,  &quot;standard&quot; selects the</span>
<span class="sd">            interoperable blocking size of 2880 bytes.  In the context of</span>
<span class="sd">            _compute_checksum, &quot;either&quot; is synonymous with &quot;standard&quot;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ones complement checksum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">blocklen</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;standard&#39;</span><span class="p">:</span> <span class="mi">2880</span><span class="p">,</span>
                    <span class="s">&#39;nonstandard&#39;</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                    <span class="s">&#39;either&#39;</span><span class="p">:</span> <span class="mi">2880</span><span class="p">,</span>  <span class="c"># do standard first</span>
                    <span class="bp">True</span><span class="p">:</span> <span class="mi">2880</span><span class="p">}[</span><span class="n">blocking</span><span class="p">]</span>

        <span class="n">sum32</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">sum32</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">blocklen</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">blocklen</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>   <span class="c"># ????</span>
            <span class="n">sum32</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_hdu_checksum</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="n">length</span><span class="p">],</span> <span class="n">sum32</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sum32</span>

    <span class="k">def</span> <span class="nf">_compute_hdu_checksum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sum32</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Translated from FITS Checksum Proposal by Seaman, Pence, and Rots.</span>
<span class="sd">        Use uint32 literals as a hedge against type promotion to int64.</span>

<span class="sd">        This code should only be called with blocks of 2880 bytes</span>
<span class="sd">        Longer blocks result in non-standard checksums with carry overflow</span>
<span class="sd">        Historically,  this code *was* called with larger blocks and for that</span>
<span class="sd">        reason still needs to be for backward compatibility.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">u8</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
        <span class="n">u16</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>
        <span class="n">uFFFF</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mh">0xFFFF</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="s">&#39;&gt;u2&#39;</span><span class="p">)</span>

        <span class="n">hi</span> <span class="o">=</span> <span class="n">sum32</span> <span class="o">&gt;&gt;</span> <span class="n">u16</span>
        <span class="n">lo</span> <span class="o">=</span> <span class="n">sum32</span> <span class="o">&amp;</span> <span class="n">uFFFF</span>
        <span class="n">hi</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>
        <span class="n">lo</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">lo</span> <span class="o">+=</span> <span class="n">last</span> <span class="o">&lt;&lt;</span> <span class="n">u8</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">+=</span> <span class="n">last</span> <span class="o">&lt;&lt;</span> <span class="n">u8</span>

        <span class="n">hicarry</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">&gt;&gt;</span> <span class="n">u16</span>
        <span class="n">locarry</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">&gt;&gt;</span> <span class="n">u16</span>

        <span class="k">while</span> <span class="n">hicarry</span> <span class="ow">or</span> <span class="n">locarry</span><span class="p">:</span>
            <span class="n">hi</span> <span class="o">=</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&amp;</span> <span class="n">uFFFF</span><span class="p">)</span> <span class="o">+</span> <span class="n">locarry</span>
            <span class="n">lo</span> <span class="o">=</span> <span class="p">(</span><span class="n">lo</span> <span class="o">&amp;</span> <span class="n">uFFFF</span><span class="p">)</span> <span class="o">+</span> <span class="n">hicarry</span>
            <span class="n">hicarry</span> <span class="o">=</span> <span class="n">hi</span> <span class="o">&gt;&gt;</span> <span class="n">u16</span>
            <span class="n">locarry</span> <span class="o">=</span> <span class="n">lo</span> <span class="o">&gt;&gt;</span> <span class="n">u16</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">hi</span> <span class="o">&lt;&lt;</span> <span class="n">u16</span><span class="p">)</span> <span class="o">+</span> <span class="n">lo</span>

    <span class="c"># _MASK and _EXCLUDE used for encoding the checksum value into a character</span>
    <span class="c"># string.</span>
    <span class="n">_MASK</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0xFF000000</span><span class="p">,</span>
             <span class="mh">0x00FF0000</span><span class="p">,</span>
             <span class="mh">0x0000FF00</span><span class="p">,</span>
             <span class="mh">0x000000FF</span><span class="p">]</span>

    <span class="n">_EXCLUDE</span> <span class="o">=</span> <span class="p">[</span><span class="mh">0x3a</span><span class="p">,</span> <span class="mh">0x3b</span><span class="p">,</span> <span class="mh">0x3c</span><span class="p">,</span> <span class="mh">0x3d</span><span class="p">,</span> <span class="mh">0x3e</span><span class="p">,</span> <span class="mh">0x3f</span><span class="p">,</span> <span class="mh">0x40</span><span class="p">,</span>
                <span class="mh">0x5b</span><span class="p">,</span> <span class="mh">0x5c</span><span class="p">,</span> <span class="mh">0x5d</span><span class="p">,</span> <span class="mh">0x5e</span><span class="p">,</span> <span class="mh">0x5f</span><span class="p">,</span> <span class="mh">0x60</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_encode_byte</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">byte</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode a single byte.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">quotient</span> <span class="o">=</span> <span class="n">byte</span> <span class="o">//</span> <span class="mi">4</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s">&#39;0&#39;</span><span class="p">)</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">byte</span> <span class="o">%</span> <span class="mi">4</span>

        <span class="n">ch</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
            <span class="p">[(</span><span class="n">quotient</span> <span class="o">+</span> <span class="n">remainder</span><span class="p">),</span> <span class="n">quotient</span><span class="p">,</span> <span class="n">quotient</span><span class="p">,</span> <span class="n">quotient</span><span class="p">],</span>
            <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>

        <span class="n">check</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">check</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EXCLUDE</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="ow">or</span> <span class="n">ch</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span><span class="p">:</span>
                        <span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">ch</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">check</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">ch</span>

    <span class="k">def</span> <span class="nf">_char_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encodes the checksum ``value`` using the algorithm described</span>
<span class="sd">        in SPR section A.7.2 and returns it as a 16 character string.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value</span>
<span class="sd">            a checksum</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ascii encoded checksum</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">asc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;byte&#39;</span><span class="p">)</span>
        <span class="n">ascii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">16</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;byte&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="n">byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_MASK</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="p">((</span><span class="mi">3</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">)</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_encode_byte</span><span class="p">(</span><span class="n">byte</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">asc</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">j</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ch</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">):</span>
            <span class="n">ascii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">asc</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">)</span> <span class="o">%</span> <span class="mi">16</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">decode_ascii</span><span class="p">(</span><span class="n">ascii</span><span class="o">.</span><span class="n">tostring</span><span class="p">())</span>


<span class="k">class</span> <span class="nc">ExtensionHDU</span><span class="p">(</span><span class="n">_ValidHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An extension HDU class.</span>

<span class="sd">    This class is the base class for the `TableHDU`, `ImageHDU`, and</span>
<span class="sd">    `BinTableHDU` classes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_extension</span> <span class="o">=</span> <span class="s">&#39;&#39;</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This class should never be instantiated directly.  Either a standard</span>
<span class="sd">        extension HDU type should be used for a specific extension, or</span>
<span class="sd">        NonstandardExtHDU should be used.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">writeto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">output_verify</span><span class="o">=</span><span class="s">&#39;exception&#39;</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Works similarly to the normal writeto(), but prepends a default</span>
<span class="sd">        `PrimaryHDU` are required by extension HDUs (which cannot stand on</span>
<span class="sd">        their own).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="kn">from</span> <span class="nn">.hdulist</span> <span class="kn">import</span> <span class="n">HDUList</span>
        <span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">PrimaryHDU</span>

        <span class="n">hdulist</span> <span class="o">=</span> <span class="n">HDUList</span><span class="p">([</span><span class="n">PrimaryHDU</span><span class="p">(),</span> <span class="bp">self</span><span class="p">])</span>
        <span class="n">hdulist</span><span class="o">.</span><span class="n">writeto</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">output_verify</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="n">clobber</span><span class="p">,</span>
                        <span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">):</span>

        <span class="n">errs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">ExtensionHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="o">=</span><span class="n">option</span><span class="p">)</span>

        <span class="c"># Verify location and value of mandatory keywords.</span>
        <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="n">naxis</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">),</span>
                       <span class="mi">0</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="n">naxis</span> <span class="o">+</span> <span class="mi">4</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
                       <span class="mi">1</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">errs</span>
<span class="c"># For backwards compatibility, though this needs to be deprecated</span>
<span class="c"># TODO: Mark this as deprecated</span>
<span class="n">_ExtensionHDU</span> <span class="o">=</span> <span class="n">ExtensionHDU</span>


<span class="k">class</span> <span class="nc">NonstandardExtHDU</span><span class="p">(</span><span class="n">ExtensionHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Non-standard Extension HDU class.</span>

<span class="sd">    This class is used for an Extension HDU when the ``XTENSION``</span>
<span class="sd">    `Card` has a non-standard value.  In this case, Astropy can figure</span>
<span class="sd">    out how big the data is but not what it is.  The data for this HDU</span>
<span class="sd">    is read from the file as a byte stream that begins at the first</span>
<span class="sd">    byte after the header ``END`` card and continues until the</span>
<span class="sd">    beginning of the next header or the end of the file.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_standard</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Matches any extension HDU that is not one of the standard extension HDU</span>
<span class="sd">        types.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xtension</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xtension</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">xtension</span> <span class="o">=</span> <span class="n">xtension</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="c"># A3DTABLE is not really considered a &#39;standard&#39; extension, as it was</span>
        <span class="c"># sort of the prototype for BINTABLE; however, since our BINTABLE</span>
        <span class="c"># implementation handles A3DTABLE HDUs it is listed here.</span>
        <span class="n">standard_xtensions</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;IMAGE&#39;</span><span class="p">,</span> <span class="s">&#39;TABLE&#39;</span><span class="p">,</span> <span class="s">&#39;BINTABLE&#39;</span><span class="p">,</span> <span class="s">&#39;A3DTABLE&#39;</span><span class="p">)</span>
        <span class="c"># The check that xtension is not one of the standard types should be</span>
        <span class="c"># redundant.</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;XTENSION&#39;</span> <span class="ow">and</span>
                <span class="n">xtension</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">standard_xtensions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="s">&#39;NonstandardExtHDU&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the file data.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="s">&#39;ubyte&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>

<span class="c"># TODO: Mark this as deprecated</span>
<span class="n">_NonstandardExtHDU</span> <span class="o">=</span> <span class="n">NonstandardExtHDU</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1. &nbsp;
    Last built 12 May 2016. <br/>
  </p>
</footer>
  </body>
</html>