<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.io.fits.hdu.table &mdash; Astropy v1.2.dev15003</title>
    
    <link rel="stylesheet" href="../../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '1.2.dev15003',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.2.dev15003" href="../../../../../index.html" />
    <link rel="up" title="Module code" href="../../../../index.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">Astropy v1.2.dev15003</a>
	 &raquo;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.io.fits.hdu.table</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>  <span class="c"># confidence high</span>

<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">textwrap</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">char</span> <span class="k">as</span> <span class="n">chararray</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">DELAYED</span><span class="p">,</span> <span class="n">_ValidHDU</span><span class="p">,</span> <span class="n">ExtensionHDU</span>
<span class="c"># This module may have many dependencies on pyfits.column, but pyfits.column</span>
<span class="c"># has fewer dependencies overall, so it&#39;s easier to keep table/column-related</span>
<span class="c"># utilities in pyfits.column</span>
<span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">_numpy_hacks</span> <span class="k">as</span> <span class="n">nh</span>
<span class="kn">from</span> <span class="nn">..column</span> <span class="kn">import</span> <span class="p">(</span><span class="n">FITS2NUMPY</span><span class="p">,</span> <span class="n">KEYWORD_NAMES</span><span class="p">,</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">,</span>
                      <span class="n">ATTRIBUTE_TO_KEYWORD</span><span class="p">,</span> <span class="n">TDEF_RE</span><span class="p">,</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">,</span>
                      <span class="n">_AsciiColDefs</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">,</span> <span class="n">_FormatQ</span><span class="p">,</span> <span class="n">_makep</span><span class="p">,</span>
                      <span class="n">_parse_tformat</span><span class="p">,</span> <span class="n">_scalar_to_format</span><span class="p">,</span> <span class="n">_convert_format</span><span class="p">,</span>
                      <span class="n">_cmp_recformats</span><span class="p">,</span> <span class="n">_get_index</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..fitsrec</span> <span class="kn">import</span> <span class="n">FITS_rec</span><span class="p">,</span> <span class="n">_get_recarray_field</span><span class="p">,</span> <span class="n">_has_unicode_fields</span>
<span class="kn">from</span> <span class="nn">..header</span> <span class="kn">import</span> <span class="n">Header</span><span class="p">,</span> <span class="n">_pad_length</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="n">_is_int</span><span class="p">,</span> <span class="n">_str_to_num</span>

<span class="kn">from</span> <span class="nn">....extern</span> <span class="kn">import</span> <span class="n">six</span>
<span class="kn">from</span> <span class="nn">....extern.six</span> <span class="kn">import</span> <span class="n">string_types</span>
<span class="kn">from</span> <span class="nn">....extern.six.moves</span> <span class="kn">import</span> <span class="nb">xrange</span> <span class="k">as</span> <span class="nb">range</span>
<span class="kn">from</span> <span class="nn">....utils</span> <span class="kn">import</span> <span class="n">deprecated</span><span class="p">,</span> <span class="n">lazyproperty</span>
<span class="kn">from</span> <span class="nn">....utils.compat</span> <span class="kn">import</span> <span class="n">ignored</span>
<span class="kn">from</span> <span class="nn">....utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>


<span class="k">class</span> <span class="nc">FITSTableDumpDialect</span><span class="p">(</span><span class="n">csv</span><span class="o">.</span><span class="n">excel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A CSV dialect for the PyFITS format of ASCII dumps of FITS tables.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">delimiter</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
    <span class="n">lineterminator</span> <span class="o">=</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span>
    <span class="n">quotechar</span> <span class="o">=</span> <span class="s">&#39;&quot;&#39;</span>
    <span class="n">quoting</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">QUOTE_ALL</span>
    <span class="n">skipinitialspace</span> <span class="o">=</span> <span class="bp">True</span>


<span class="k">class</span> <span class="nc">_TableLikeHDU</span><span class="p">(</span><span class="n">_ValidHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class for HDUs that have table-like data.  This is used for both</span>
<span class="sd">    Binary/ASCII tables as well as Random Access Group HDUs (which are</span>
<span class="sd">    otherwise too dissimilar for tables to use _TableBaseHDU directly).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_data_type</span> <span class="o">=</span> <span class="n">FITS_rec</span>
    <span class="n">_columns_type</span> <span class="o">=</span> <span class="n">ColDefs</span>

    <span class="c"># TODO: Temporary flag representing whether uints are enabled; remove this</span>
    <span class="c"># after restructuring to support uints by default on a per-column basis</span>
    <span class="n">_uint</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an abstract HDU type for HDUs that contain table-like data.</span>
<span class="sd">        This is even more abstract than _TableBaseHDU which is specifically for</span>
<span class="sd">        the standard ASCII and Binary Table types.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_columns</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                     <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given either a `ColDefs` object, a sequence of `Column` objects,</span>
<span class="sd">        or another table HDU or table data (a `FITS_rec` or multi-field</span>
<span class="sd">        `numpy.ndarray` or `numpy.recarray` object, return a new table HDU of</span>
<span class="sd">        the class this method was called on using the column definition from</span>
<span class="sd">        the input.</span>

<span class="sd">        This is an alternative to the now deprecated `new_table` function,</span>
<span class="sd">        and otherwise accepts the same arguments.  See also</span>
<span class="sd">        `FITS_rec.from_columns`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        columns : sequence of `Column`, `ColDefs`, or other</span>
<span class="sd">            The columns from which to create the table data, or an object with</span>
<span class="sd">            a column-like structure from which a `ColDefs` can be instantiated.</span>
<span class="sd">            This includes an existing `BinTableHDU` or `TableHDU`, or a</span>
<span class="sd">            `numpy.recarray` to give some examples.</span>

<span class="sd">            If these columns have data arrays attached that data may be used in</span>
<span class="sd">            initializing the new table.  Otherwise the input columns will be</span>
<span class="sd">            used as a template for a new table with the requested number of</span>
<span class="sd">            rows.</span>

<span class="sd">        header : `Header`</span>
<span class="sd">            An optional `Header` object to instantiate the new HDU yet.  Header</span>
<span class="sd">            keywords specifically related to defining the table structure (such</span>
<span class="sd">            as the &quot;TXXXn&quot; keywords like TTYPEn) will be overridden by the</span>
<span class="sd">            supplied column definitions, but all other informational and data</span>
<span class="sd">            model-specific keywords are kept.</span>

<span class="sd">        nrows : int</span>
<span class="sd">            Number of rows in the new table.  If the input columns have data</span>
<span class="sd">            associated with them, the size of the largest input column is used.</span>
<span class="sd">            Otherwise the default is 0.</span>

<span class="sd">        fill : bool</span>
<span class="sd">            If `True`, will fill all cells with zeros or blanks.  If `False`,</span>
<span class="sd">            copy the data from input, undefined cells will still be filled with</span>
<span class="sd">            zeros/blanks.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        Any additional keyword arguments accepted by the HDU class&#39;s</span>
<span class="sd">        ``__init__`` may also be passed in as keyword arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">coldefs</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">FITS_rec</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">coldefs</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">coldefs</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="n">hdu</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hdu</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`ColDefs` objects describing the columns in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># The base class doesn&#39;t make any assumptions about where the column</span>
        <span class="c"># definitions come from, so just return an empty ColDefs</span>
        <span class="k">return</span> <span class="n">ColDefs</span><span class="p">([])</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_nrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Table-like HDUs must provide an attribute that specifies the number of</span>
<span class="sd">        rows in the HDU&#39;s table.</span>

<span class="sd">        For now this is an internal-only attribute.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_get_tbdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Get the table data from an input HDU object.&quot;&quot;&quot;</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

        <span class="c"># TODO: Details related to variable length arrays need to be dealt with</span>
        <span class="c"># specifically in the BinTableHDU class, since they&#39;re a detail</span>
        <span class="c"># specific to FITS binary tables</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">any</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_FormatP</span><span class="p">,</span> <span class="n">_FormatQ</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span><span class="p">):</span>
            <span class="c"># We have a heap; include it in the raw_data</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_theap</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                               <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrows</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">raw_data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># This can happen when a brand new table HDU is being created</span>
                <span class="c"># and no data has been assigned to the columns, which case just</span>
                <span class="c"># return an empty array</span>
                <span class="n">raw_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_tbdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>
        <span class="n">columns</span><span class="o">.</span><span class="n">_add_listener</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">_init_tbdata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>

        <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s">&#39;&gt;&#39;</span><span class="p">)</span>

        <span class="c"># hack to enable pseudo-uint support</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span>

        <span class="c"># pass datLoc, for P format</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_heapoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">]</span>
        <span class="n">tbsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span> <span class="o">-</span> <span class="n">tbsize</span>

        <span class="c"># pass the attributes</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="c"># get the data for each column object from the rec.recarray</span>
            <span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="c"># delete the _arrays attribute so that it is recreated to point to the</span>
        <span class="c"># new data placed in the column object above</span>
        <span class="k">del</span> <span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span>

    <span class="k">def</span> <span class="nf">_update_column_added</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the data upon addition of a new column through the `ColDefs`</span>
<span class="sd">        interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># TODO: It&#39;s not clear that this actually works--it probably does not.</span>
        <span class="c"># This is what the code used to do before introduction of the</span>
        <span class="c"># notifier interface, but I don&#39;t believe it actually worked (there are</span>
        <span class="c"># several bug reports related to this...)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">_update_column_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the data upon removal of a column through the `ColDefs`</span>
<span class="sd">        interface.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># For now this doesn&#39;t do anything fancy--it just deletes the data</span>
        <span class="c"># attribute so that it is forced to be recreated again.  It doesn&#39;t</span>
        <span class="c"># change anything on the existing data recarray (this is also how this</span>
        <span class="c"># worked before introducing the notifier interface)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>


<span class="k">class</span> <span class="nc">_TableBaseHDU</span><span class="p">(</span><span class="n">ExtensionHDU</span><span class="p">,</span> <span class="n">_TableLikeHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FITS table extension base HDU class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_manages_own_heap</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This flag implies that when writing VLA tables (P/Q format) the heap</span>
<span class="sd">    pointers that go into P/Q table columns should not be reordered or</span>
<span class="sd">    rearranged in any way by the default heap management code.</span>

<span class="sd">    This is included primarily as an optimization for compressed image HDUs</span>
<span class="sd">    which perform their own heap maintenance.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">uint</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        header : Header instance</span>
<span class="sd">            header to be used</span>

<span class="sd">        data : array</span>
<span class="sd">            data to be used</span>

<span class="sd">        name : str</span>
<span class="sd">            name to be populated in ``EXTNAME`` keyword</span>

<span class="sd">        uint : bool, optional</span>
<span class="sd">            set to `True` if the table contains unsigned integer columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
                                            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">Header</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;header must be a Header object.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="n">uint</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">DELAYED</span><span class="p">:</span>
            <span class="c"># this should never happen</span>
            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;No header to setup HDU.&#39;</span><span class="p">)</span>

            <span class="c"># if the file is read the first time, no need to copy, and keep it</span>
            <span class="c"># unchanged</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># construct a list of cards of minimal header</span>
            <span class="n">cards</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">(</span><span class="s">&#39;XTENSION&#39;</span><span class="p">,</span>      <span class="s">&#39;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;BITPIX&#39;</span><span class="p">,</span>         <span class="mi">8</span><span class="p">,</span> <span class="s">&#39;array data type&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span>          <span class="mi">2</span><span class="p">,</span> <span class="s">&#39;number of array dimensions&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;length of dimension 1&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;length of dimension 2&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of group parameters&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">,</span>         <span class="mi">1</span><span class="p">,</span> <span class="s">&#39;number of groups&#39;</span><span class="p">),</span>
                <span class="p">(</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span> <span class="s">&#39;number of table fields&#39;</span><span class="p">)]</span>

            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># Make a &quot;copy&quot; (not just a view) of the input header, since it</span>
                <span class="c"># may get modified.  the data is still a &quot;view&quot; (for now)</span>
                <span class="n">hcopy</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">strip</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">cards</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">hcopy</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">(</span><span class="n">cards</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># self._data_type is FITS_rec.</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Just doing a view on the input data screws up unsigned</span>
                    <span class="c"># columns, so treat those more carefully.</span>
                    <span class="c"># TODO: I need to read this code a little more closely</span>
                    <span class="c"># again, but I think it can be simplified quite a bit with</span>
                    <span class="c"># the use of some appropriate utility functions</span>
                    <span class="n">update_coldefs</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">if</span> <span class="s">&#39;u&#39;</span> <span class="ow">in</span> <span class="p">[</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="n">bzeros</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="mi">4</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">31</span><span class="p">),</span>
                                  <span class="mi">8</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">63</span><span class="p">)}</span>

                        <span class="n">new_dtype</span> <span class="o">=</span> <span class="p">[</span>
                            <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;u&#39;</span><span class="p">,</span> <span class="s">&#39;i&#39;</span><span class="p">)</span> <span class="o">+</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">itemsize</span><span class="p">))</span>
                            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>

                        <span class="n">new_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dtype</span><span class="p">)</span>

                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">:</span>
                            <span class="n">dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                            <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;u&#39;</span><span class="p">:</span>
                                <span class="n">new_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">bzeros</span><span class="p">[</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">]</span>
                                <span class="n">update_coldefs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">bzeros</span><span class="p">[</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">]</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">new_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>
                        <span class="c"># Uck...</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">update_coldefs</span><span class="p">:</span>
                        <span class="n">indx</span> <span class="o">=</span> <span class="n">_get_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">names</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">bzero</span> <span class="o">=</span> <span class="n">update_coldefs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="c"># This is so bad that we have to update this in</span>
                        <span class="c"># duplicate...</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="o">.</span><span class="n">bzeros</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">update_coldefs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="c"># More uck...</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">_physical_values</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span><span class="o">.</span><span class="n">_pseudo_unsigned_ints</span> <span class="o">=</span> <span class="bp">True</span>

                <span class="c"># TODO: Too much of the code in this class uses header keywords</span>
                <span class="c"># in making calculations related to the data size.  This is</span>
                <span class="c"># unreliable, however, in cases when users mess with the header</span>
                <span class="c"># unintentionally--code that does this should be cleaned up.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_raw_itemsize</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

                <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                    <span class="c"># Make the ndarrays in the Column objects of the ColDefs</span>
                    <span class="c"># object of the HDU reference the same ndarray as the HDU&#39;s</span>
                    <span class="c"># FITS_rec object.</span>
                    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                        <span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                    <span class="c"># Delete the _arrays attribute so that it is recreated to</span>
                    <span class="c"># point to the new data placed in the column objects above</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span>
            <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Table data has incorrect type.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">string_types</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_extension</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ext_comment</span><span class="p">)</span>

        <span class="c"># Ensure that the correct EXTNAME is set on the new header if one was</span>
        <span class="c"># created, or that it overrides the existing EXTNAME if different</span>
        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is an abstract type that implements the shared functionality of</span>
<span class="sd">        the ASCII and Binary Table HDU types, which should be used instead of</span>
<span class="sd">        this.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The :class:`ColDefs` objects describing the columns in this table.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s">&#39;_coldefs&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_tbdata</span><span class="p">()</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="c"># Columns should now just return a reference to the data._coldefs</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="s">&#39;data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data_replaced</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c"># Create a new table with the same columns, but empty rows</span>
            <span class="n">formats</span> <span class="o">=</span> <span class="s">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">formats</span><span class="o">=</span><span class="n">formats</span><span class="p">,</span>
                                <span class="n">names</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">,</span>
                                <span class="n">shape</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Go ahead and always make a view, even if the data is already the</span>
            <span class="c"># correct class (self._data_type) so we can update things like the</span>
            <span class="c"># column defs, if necessary</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">):</span>
                <span class="c"># This would be the place, if the input data was for an ASCII</span>
                <span class="c"># table and this is binary table, or vice versa, to convert the</span>
                <span class="c"># data to the appropriate format for the table type</span>
                <span class="n">new_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_columns_type</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">FITS_rec</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">new_columns</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span>

            <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="c"># Make the ndarrays in the Column objects of the ColDefs</span>
                <span class="c"># object of the HDU reference the same ndarray as the HDU&#39;s</span>
                <span class="c"># FITS_rec object.</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

                <span class="c"># Delete the _arrays attribute so that it is recreated to</span>
                <span class="c"># point to the new data placed in the column objects above</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span>
        <span class="k">elif</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;Table data has incorrect type.&#39;</span><span class="p">)</span>

        <span class="c"># returning the data signals to lazyproperty that we&#39;ve already handled</span>
        <span class="c"># setting self.__dict__[&#39;data&#39;]</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_nrows</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">_theap</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;THEAP&#39;</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="c"># TODO: Need to either rename this to update_header, for symmetry with the</span>
    <span class="c"># Image HDUs, or just at some point deprecate it and remove it altogether,</span>
    <span class="c"># since header updates should occur automatically when necessary...</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update header keywords to reflect recent changes of columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_raw_itemsize</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;NAXIS&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">),</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_table_keywords</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_populate_table_keywords</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a copy of the table HDU, both header and data are copied.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># touch the data, so it&#39;s defined (in the case of reading from a</span>
        <span class="c"># FITS file)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                              <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_prewriteto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_scale_back</span><span class="p">(</span>
                <span class="n">update_heap_pointers</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manages_own_heap</span><span class="p">)</span>
            <span class="c"># check TFIELDS and NAXIS2</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c"># calculate PCOUNT, for variable length tables</span>
            <span class="n">tbsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="n">heapstart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;THEAP&#39;</span><span class="p">,</span> <span class="n">tbsize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">=</span> <span class="n">heapstart</span> <span class="o">-</span> <span class="n">tbsize</span>
            <span class="n">pcount</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_gap</span>
            <span class="k">if</span> <span class="n">pcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcount</span>

            <span class="c"># update the other T****n keywords</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_populate_table_keywords</span><span class="p">()</span>

            <span class="c"># update TFORM for variable length columns</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
                <span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_coldefs</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
                    <span class="n">_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
                    <span class="c"># May be either _FormatP or _FormatQ</span>
                    <span class="n">format_cls</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="n">__class__</span>
                    <span class="n">format</span> <span class="o">=</span> <span class="n">format_cls</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="n">format</span><span class="o">.</span><span class="n">repeat</span><span class="p">,</span>
                                        <span class="nb">max</span><span class="o">=</span><span class="n">_max</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFORM&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">format</span><span class="o">.</span><span class="n">tform</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_prewriteto</span><span class="p">(</span><span class="n">checksum</span><span class="p">,</span> <span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        _TableBaseHDU verify method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">errs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="o">=</span><span class="n">option</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">2</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">8</span><span class="p">),</span> <span class="mi">8</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span>
                       <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">_is_int</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">999</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
                       <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="n">tfields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tfields</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;TFORM&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
                           <span class="n">errs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errs</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the HDU: name, dimensions, and formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>

        <span class="c"># if data is touched, use data info.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">shape</span><span class="p">,</span> <span class="n">format</span> <span class="o">=</span> <span class="p">(),</span> <span class="s">&#39;&#39;</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">formats</span>

        <span class="c"># if data is not touched yet, use header info.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="p">()</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span>
            <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFORM&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncols</span><span class="p">)])</span>
            <span class="n">format</span> <span class="o">=</span> <span class="s">&#39;[</span><span class="si">%s</span><span class="s">]&#39;</span> <span class="o">%</span> <span class="n">format</span>
        <span class="n">dims</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%d</span><span class="s">R x </span><span class="si">%d</span><span class="s">C&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">)</span>
        <span class="n">ncards</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">class_name</span><span class="p">,</span> <span class="n">ncards</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_column_removed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_update_column_removed</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="c"># Fix the header to reflect the column removal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_clear_table_keywords</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_column_attribute_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span>
                                         <span class="n">old_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the header when one of the column objects is updated.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># base_keyword is the keyword without the index such as TDIM</span>
        <span class="c"># while keyword is like TDIM1</span>
        <span class="n">base_keyword</span> <span class="o">=</span> <span class="n">ATTRIBUTE_TO_KEYWORD</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">base_keyword</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c"># If the new value is None, i.e. None was assigned to the</span>
                <span class="c"># column attribute, then treat this as equivalent to deleting</span>
                <span class="c"># that attribute</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyword_idx</span> <span class="o">=</span> <span class="n">KEYWORD_NAMES</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">base_keyword</span><span class="p">)</span>
            <span class="c"># Determine the appropriate keyword to insert this one before/after</span>
            <span class="c"># if it did not already exist in the header</span>
            <span class="k">for</span> <span class="n">before_keyword</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">KEYWORD_NAMES</span><span class="p">[:</span><span class="n">keyword_idx</span><span class="p">]):</span>
                <span class="n">before_keyword</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">before_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">before_keyword</span><span class="p">,</span> <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">new_value</span><span class="p">),</span>
                                        <span class="n">after</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">after_keyword</span> <span class="ow">in</span> <span class="n">KEYWORD_NAMES</span><span class="p">[</span><span class="n">keyword_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                    <span class="n">after_keyword</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">after_keyword</span> <span class="ow">in</span> <span class="n">header</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">after_keyword</span><span class="p">,</span>
                                            <span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">new_value</span><span class="p">))</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># Just append</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_value</span>

    <span class="k">def</span> <span class="nf">_clear_table_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wipe out any existing table definition keywords from the header.</span>

<span class="sd">        If specified, only clear keywords for the given table index (shifting</span>
<span class="sd">        up keywords for any other columns).  The index is zero-based.</span>
<span class="sd">        Otherwise keywords for all columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># First collect all the table structure related keyword in the header</span>
        <span class="c"># into a single list so we can then sort them by index, which will be</span>
        <span class="c"># useful later for updating the header in a sensible order (since the</span>
        <span class="c"># header *might* not already be written in a reasonable order)</span>
        <span class="n">table_keywords</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">TDEF_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">base_keyword</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>                <span class="c"># skip if there is no match</span>

            <span class="k">if</span> <span class="n">base_keyword</span> <span class="ow">in</span> <span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">:</span>
                <span class="n">num</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c"># convert to zero-base</span>
                <span class="n">table_keywords</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">base_keyword</span><span class="p">,</span>
                                       <span class="n">num</span><span class="p">))</span>

        <span class="c"># First delete</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">table_keywords</span><span class="p">,</span>
                                           <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">index</span> <span class="o">==</span> <span class="n">num</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c"># Now shift up remaining column keywords if only one column was cleared</span>
        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">base_keyword</span><span class="p">,</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">table_keywords</span><span class="p">,</span>
                                                        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="n">k</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">num</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">old_card</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
                <span class="n">new_card</span> <span class="o">=</span> <span class="p">(</span><span class="n">base_keyword</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">),</span> <span class="n">old_card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                            <span class="n">old_card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">new_card</span><span class="p">)</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

            <span class="c"># Also decrement TFIELDS</span>
            <span class="k">if</span> <span class="s">&#39;TFIELDS&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_populate_table_keywords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Populate the new table definition keywords from the header.&quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">six</span><span class="o">.</span><span class="n">iteritems</span><span class="p">(</span><span class="n">KEYWORD_TO_ATTRIBUTE</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">keyword</span> <span class="o">=</span> <span class="n">keyword</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>


<div class="viewcode-block" id="TableHDU"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.TableHDU">[docs]</a><span class="k">class</span> <span class="nc">TableHDU</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    FITS ASCII table extension HDU class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_extension</span> <span class="o">=</span> <span class="s">&#39;TABLE&#39;</span>
    <span class="n">_ext_comment</span> <span class="o">=</span> <span class="s">&#39;ASCII table extension&#39;</span>

    <span class="n">_padding_byte</span> <span class="o">=</span> <span class="s">&#39; &#39;</span>
    <span class="n">_columns_type</span> <span class="o">=</span> <span class="n">_AsciiColDefs</span>

    <span class="n">__format_RE</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span>
        <span class="s">r&#39;(?P&lt;code&gt;[ADEFIJ])(?P&lt;width&gt;\d+)(?:\.(?P&lt;prec&gt;\d+))?&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">TableHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xtension</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xtension</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">xtension</span> <span class="o">=</span> <span class="n">xtension</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;XTENSION&#39;</span> <span class="ow">and</span> <span class="n">xtension</span> <span class="o">==</span> <span class="n">cls</span><span class="o">.</span><span class="n">_extension</span>

    <span class="k">def</span> <span class="nf">_get_tbdata</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">)]</span>

        <span class="c"># determine if there are duplicate field names and if there</span>
        <span class="c"># are throw an exception</span>
        <span class="n">dup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">find_duplicate</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dup</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Duplicate field names: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">dup</span><span class="p">)</span>

        <span class="c"># TODO: Determine if this extra logic is necessary--I feel like the</span>
        <span class="c"># _AsciiColDefs class should be responsible for telling the table what</span>
        <span class="c"># its dtype should be...</span>
        <span class="n">itemsize</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">columns</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">data_type</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c"># The last column is padded out to the value of NAXIS1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">itemsize</span><span class="p">:</span>
                    <span class="n">data_type</span> <span class="o">=</span> <span class="s">&#39;S&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">columns</span><span class="o">.</span><span class="n">spans</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">itemsize</span><span class="p">)</span>
            <span class="n">dtype</span><span class="p">[</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">columns</span><span class="o">.</span><span class="n">starts</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">raw_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_raw_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nrows</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_offset</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">raw_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_tbdata</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_calculate_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card in the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="c"># We have the data to be used.</span>
            <span class="c"># We need to pad the data to a block length before calculating</span>
            <span class="c"># the datasum.</span>
            <span class="n">bytes_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">_pad_length</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="s">&#39; &#39;</span><span class="p">,</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>

            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bytes_array</span><span class="p">,</span> <span class="n">padding</span><span class="p">)</span>

            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="n">blocking</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">cs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># This is the case where the data has not been read from the file</span>
            <span class="c"># yet.  We can handle that in a generic manner so we do it in the</span>
            <span class="c"># base class.  The other possibility is that there is no data at</span>
            <span class="c"># all.  This can also be handled in a generic manner.</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">TableHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_verify</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;warn&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        `TableHDU` verify method.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">errs</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">TableHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_verify</span><span class="p">(</span><span class="n">option</span><span class="o">=</span><span class="n">option</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">v</span><span class="p">:</span> <span class="p">(</span><span class="n">v</span> <span class="o">==</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span> <span class="n">errs</span><span class="p">)</span>
        <span class="n">tfields</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tfields</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">req_cards</span><span class="p">(</span><span class="s">&#39;TBCOL&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="bp">None</span><span class="p">,</span> <span class="n">_is_int</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
                           <span class="n">errs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">errs</span>

</div>
<div class="viewcode-block" id="BinTableHDU"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU">[docs]</a><span class="k">class</span> <span class="nc">BinTableHDU</span><span class="p">(</span><span class="n">_TableBaseHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Binary table HDU class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_extension</span> <span class="o">=</span> <span class="s">&#39;BINTABLE&#39;</span>
    <span class="n">_ext_comment</span> <span class="o">=</span> <span class="s">&#39;binary table extension&#39;</span>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xtension</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xtension</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">xtension</span> <span class="o">=</span> <span class="n">xtension</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;XTENSION&#39;</span> <span class="ow">and</span>
                <span class="n">xtension</span> <span class="ow">in</span> <span class="p">(</span><span class="n">cls</span><span class="o">.</span><span class="n">_extension</span><span class="p">,</span> <span class="s">&#39;A3DTABLE&#39;</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_calculate_datasum_with_heap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card given the input data</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">with</span> <span class="n">_binary_table_byte_swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">dout</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ubyte</span><span class="p">)</span>
            <span class="n">csum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">blocking</span><span class="o">=</span><span class="n">blocking</span><span class="p">)</span>

            <span class="c"># Now add in the heap data to the checksum (we can skip any gap</span>
            <span class="c"># between the table and the heap since it&#39;s all zeros and doesn&#39;t</span>
            <span class="c"># contribute to the checksum</span>
            <span class="c"># TODO: The following code may no longer be necessary since it is</span>
            <span class="c"># now possible to get a pointer directly to the heap data as a</span>
            <span class="c"># whole.  That said, it is possible for the heap section to contain</span>
            <span class="c"># data that is not actually pointed to by the table (i.e. garbage;</span>
            <span class="c"># this *shouldn&#39;t* happen but it is not disallowed either)--need to</span>
            <span class="c"># double check whether or not the checksum should include such</span>
            <span class="c"># garbage</span>
            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">_FormatP</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">coldata</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
                        <span class="c"># coldata should already be byteswapped from the call</span>
                        <span class="c"># to _binary_table_byte_swap</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">coldata</span><span class="p">):</span>
                            <span class="k">continue</span>

                        <span class="n">csum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compute_checksum</span><span class="p">(</span><span class="n">coldata</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span>
                                                      <span class="n">blocking</span><span class="o">=</span><span class="n">blocking</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">csum</span>

    <span class="k">def</span> <span class="nf">_calculate_datasum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">blocking</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the value for the ``DATASUM`` card in the HDU.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="c"># This method calculates the datasum while incorporating any</span>
            <span class="c"># heap data, which is obviously not handled from the base</span>
            <span class="c"># _calculate_datasum</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_datasum_with_heap</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># This is the case where the data has not been read from the file</span>
            <span class="c"># yet.  We can handle that in a generic manner so we do it in the</span>
            <span class="c"># base class.  The other possibility is that there is no data at</span>
            <span class="c"># all.  This can also be handled in a generic manner.</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinTableHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_calculate_datasum</span><span class="p">(</span><span class="n">blocking</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writedata_internal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">size</span>

        <span class="k">with</span> <span class="n">_binary_table_byte_swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)</span> <span class="k">as</span> <span class="n">data</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_has_unicode_fields</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
                <span class="c"># If the raw data was a user-supplied recarray, we can&#39;t write</span>
                <span class="c"># unicode columns directly to the file, so we have to switch</span>
                <span class="c"># to a slower row-by-row write</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_writedata_by_row</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="c"># write out the heap of variable length array columns this has</span>
                <span class="c"># to be done after the &quot;regular&quot; data is written (above)</span>
                <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">((</span><span class="n">data</span><span class="o">.</span><span class="n">_gap</span> <span class="o">*</span> <span class="s">&#39;</span><span class="se">\0</span><span class="s">&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s">&#39;ascii&#39;</span><span class="p">))</span>

            <span class="n">nbytes</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_gap</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_manages_own_heap</span><span class="p">:</span>
                <span class="c"># Write the heap data one column at a time, in the order</span>
                <span class="c"># that the data pointers appear in the column (regardless</span>
                <span class="c"># if that data pointer has a different, previous heap</span>
                <span class="c"># offset listed)</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">_nfields</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
                                      <span class="n">_FormatP</span><span class="p">):</span>
                        <span class="k">continue</span>

                    <span class="n">field</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">nbytes</span> <span class="o">+=</span> <span class="n">row</span><span class="o">.</span><span class="n">nbytes</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
                                <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">heap_data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_get_heap_data</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">nbytes</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap_data</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">simulateonly</span><span class="p">:</span>
                        <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">heap_data</span><span class="p">)</span>

            <span class="n">data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">=</span> <span class="n">nbytes</span> <span class="o">-</span> <span class="n">data</span><span class="o">.</span><span class="n">_gap</span>
            <span class="n">size</span> <span class="o">+=</span> <span class="n">nbytes</span>

        <span class="n">size</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_raw_itemsize</span>

        <span class="k">return</span> <span class="n">size</span>

    <span class="k">def</span> <span class="nf">_writedata_by_row</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                  <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="p">))]</span>

        <span class="c"># Creating Record objects is expensive (as in</span>
        <span class="c"># `for row in self.data:` so instead we just iterate over the row</span>
        <span class="c"># indicies and get one field at a time:</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">field</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;U&#39;</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="s">&#39;ascii&#39;</span><span class="p">)</span>

                <span class="n">fileobj</span><span class="o">.</span><span class="n">writearray</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

    <span class="n">_tdump_file_format</span> <span class="o">=</span> <span class="n">textwrap</span><span class="o">.</span><span class="n">dedent</span><span class="p">(</span><span class="s">&quot;&quot;&quot;</span>

<span class="s">        - **datafile:** Each line of the data file represents one row of table</span>
<span class="s">          data.  The data is output one column at a time in column order.  If</span>
<span class="s">          a column contains an array, each element of the column array in the</span>
<span class="s">          current row is output before moving on to the next column.  Each row</span>
<span class="s">          ends with a new line.</span>

<span class="s">          Integer data is output right-justified in a 21-character field</span>
<span class="s">          followed by a blank.  Floating point data is output right justified</span>
<span class="s">          using &#39;g&#39; format in a 21-character field with 15 digits of</span>
<span class="s">          precision, followed by a blank.  String data that does not contain</span>
<span class="s">          whitespace is output left-justified in a field whose width matches</span>
<span class="s">          the width specified in the ``TFORM`` header parameter for the</span>
<span class="s">          column, followed by a blank.  When the string data contains</span>
<span class="s">          whitespace characters, the string is enclosed in quotation marks</span>
<span class="s">          (``&quot;&quot;``).  For the last data element in a row, the trailing blank in</span>
<span class="s">          the field is replaced by a new line character.</span>

<span class="s">          For column data containing variable length arrays (&#39;P&#39; format), the</span>
<span class="s">          array data is preceded by the string ``&#39;VLA_Length= &#39;`` and the</span>
<span class="s">          integer length of the array for that row, left-justified in a</span>
<span class="s">          21-character field, followed by a blank.</span>

<span class="s">          .. note::</span>

<span class="s">              This format does *not* support variable length arrays using the</span>
<span class="s">              (&#39;Q&#39; format) due to difficult to overcome ambiguities. What this</span>
<span class="s">              means is that this file format cannot support VLA columns in</span>
<span class="s">              tables stored in files that are over 2 GB in size.</span>

<span class="s">          For column data representing a bit field (&#39;X&#39; format), each bit</span>
<span class="s">          value in the field is output right-justified in a 21-character field</span>
<span class="s">          as 1 (for true) or 0 (for false).</span>

<span class="s">        - **cdfile:** Each line of the column definitions file provides the</span>
<span class="s">          definitions for one column in the table.  The line is broken up into</span>
<span class="s">          8, sixteen-character fields.  The first field provides the column</span>
<span class="s">          name (``TTYPEn``).  The second field provides the column format</span>
<span class="s">          (``TFORMn``).  The third field provides the display format</span>
<span class="s">          (``TDISPn``).  The fourth field provides the physical units</span>
<span class="s">          (``TUNITn``).  The fifth field provides the dimensions for a</span>
<span class="s">          multidimensional array (``TDIMn``).  The sixth field provides the</span>
<span class="s">          value that signifies an undefined value (``TNULLn``).  The seventh</span>
<span class="s">          field provides the scale factor (``TSCALn``).  The eighth field</span>
<span class="s">          provides the offset value (``TZEROn``).  A field value of ``&quot;&quot;`` is</span>
<span class="s">          used to represent the case where no value is provided.</span>

<span class="s">        - **hfile:** Each line of the header parameters file provides the</span>
<span class="s">          definition of a single HDU header card as represented by the card</span>
<span class="s">          image.</span>
<span class="s">      &quot;&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="BinTableHDU.dump"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.dump">[docs]</a>    <span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datafile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Dump the table HDU to a file in ASCII format.  The table may be dumped</span>
<span class="sd">        in three separate files, one containing column definitions, one</span>
<span class="sd">        containing header parameters, and one for table data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datafile : file path, file object or file-like object, optional</span>
<span class="sd">            Output data file.  The default is the root name of the</span>
<span class="sd">            fits file associated with this HDU appended with the</span>
<span class="sd">            extension ``.txt``.</span>

<span class="sd">        cdfile : file path, file object or file-like object, optional</span>
<span class="sd">            Output column definitions file.  The default is `None`, no</span>
<span class="sd">            column definitions output is produced.</span>

<span class="sd">        hfile : file path, file object or file-like object, optional</span>
<span class="sd">            Output header parameters file.  The default is `None`,</span>
<span class="sd">            no header parameters output is produced.</span>

<span class="sd">        clobber : bool</span>
<span class="sd">            Overwrite the output files if they exist.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The primary use for the `dump` method is to allow viewing and editing</span>
<span class="sd">        the table data and parameters in a standard text editor.</span>
<span class="sd">        The `load` method can be used to create a new table from the three</span>
<span class="sd">        plain text (ASCII) files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># check if the output files already exist</span>
        <span class="n">exist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="p">,</span> <span class="n">hfile</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">getsize</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">clobber</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Overwriting existing file &#39;</span><span class="si">%s</span><span class="s">&#39;.&quot;</span> <span class="o">%</span> <span class="n">f</span><span class="p">,</span>
                                      <span class="n">AstropyUserWarning</span><span class="p">)</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">exist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exist</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s">&#39;  &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot;File &#39;</span><span class="si">%s</span><span class="s">&#39; already exists.&quot;</span> <span class="o">%</span> <span class="n">f</span>
                                     <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">exist</span><span class="p">]))</span>

        <span class="c"># Process the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dump_data</span><span class="p">(</span><span class="n">datafile</span><span class="p">)</span>

        <span class="c"># Process the column definitions</span>
        <span class="k">if</span> <span class="n">cdfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_dump_coldefs</span><span class="p">(</span><span class="n">cdfile</span><span class="p">)</span>

        <span class="c"># Process the header parameters</span>
        <span class="k">if</span> <span class="n">hfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">tofile</span><span class="p">(</span><span class="n">hfile</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="n">endcard</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</div>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dump</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">dump</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">+=</span> <span class="n">_tdump_file_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">        &#39;</span><span class="p">)</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;:meth:`dump`&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="BinTableHDU.tdump"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.tdump">[docs]</a>    <span class="k">def</span> <span class="nf">tdump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datafile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clobber</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="p">,</span> <span class="n">hfile</span><span class="p">,</span> <span class="n">clobber</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="BinTableHDU.load"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.load">[docs]</a>    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
             <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a table from the input ASCII files.  The input is from up to</span>
<span class="sd">        three separate files, one containing column definitions, one containing</span>
<span class="sd">        header parameters, and one containing column data.</span>

<span class="sd">        The column definition and header parameters files are not required.</span>
<span class="sd">        When absent the column definitions and/or header parameters are taken</span>
<span class="sd">        from the header object given in the header argument; otherwise sensible</span>
<span class="sd">        defaults are inferred (though this mode is not recommended).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        datafile : file path, file object or file-like object</span>
<span class="sd">            Input data file containing the table data in ASCII format.</span>

<span class="sd">        cdfile : file path, file object, file-like object, optional</span>
<span class="sd">            Input column definition file containing the names,</span>
<span class="sd">            formats, display formats, physical units, multidimensional</span>
<span class="sd">            array dimensions, undefined values, scale factors, and</span>
<span class="sd">            offsets associated with the columns in the table.  If</span>
<span class="sd">            `None`, the column definitions are taken from the current</span>
<span class="sd">            values in this object.</span>

<span class="sd">        hfile : file path, file object, file-like object, optional</span>
<span class="sd">            Input parameter definition file containing the header</span>
<span class="sd">            parameter definitions to be associated with the table.  If</span>
<span class="sd">            `None`, the header parameter definitions are taken from</span>
<span class="sd">            the current values in this objects header.</span>

<span class="sd">        replace : bool</span>
<span class="sd">            When `True`, indicates that the entire header should be</span>
<span class="sd">            replaced with the contents of the ASCII file instead of</span>
<span class="sd">            just updating the current header.</span>

<span class="sd">        header : Header object</span>
<span class="sd">            When the cdfile and hfile are missing, use this Header object in</span>
<span class="sd">            the creation of the new table and HDU.  Otherwise this Header</span>
<span class="sd">            supercedes the keywords from hfile, which is only used to update</span>
<span class="sd">            values not present in this Header, unless ``replace=True`` in which</span>
<span class="sd">            this Header&#39;s values are completely replaced with the values from</span>
<span class="sd">            hfile.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The primary use for the `load` method is to allow the input of ASCII</span>
<span class="sd">        data that was edited in a standard text editor of the table data and</span>
<span class="sd">        parameters.  The `dump` method can be used to create the initial ASCII</span>
<span class="sd">        files.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Process the parameter file</span>
        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">hfile</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
                <span class="n">header</span> <span class="o">=</span> <span class="n">Header</span><span class="o">.</span><span class="n">fromtextfile</span><span class="p">(</span><span class="n">hfile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">header</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">Header</span><span class="o">.</span><span class="n">fromtextfile</span><span class="p">(</span><span class="n">hfile</span><span class="p">),</span> <span class="n">update</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                              <span class="n">update_first</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="n">coldefs</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c"># Process the column definitions file</span>
        <span class="k">if</span> <span class="n">cdfile</span><span class="p">:</span>
            <span class="n">coldefs</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_load_coldefs</span><span class="p">(</span><span class="n">cdfile</span><span class="p">)</span>

        <span class="c"># Process the data file</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">coldefs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coldefs</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">coldefs</span> <span class="o">=</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="c"># Create a new HDU using the supplied header and data</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">cls</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="n">hdu</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">coldefs</span>
        <span class="k">return</span> <span class="n">hdu</span>
</div>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">load</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">load</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">+=</span> <span class="n">_tdump_file_format</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">,</span> <span class="s">&#39;</span><span class="se">\n</span><span class="s">        &#39;</span><span class="p">)</span>

    <span class="n">load</span> <span class="o">=</span> <span class="nb">classmethod</span><span class="p">(</span><span class="n">load</span><span class="p">)</span>
    <span class="c"># Have to create a classmethod from this here instead of as a decorator;</span>
    <span class="c"># otherwise we can&#39;t update __doc__</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.1&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;:meth:`load`&#39;</span><span class="p">)</span>
    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="BinTableHDU.tcreate"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.BinTableHDU.tcreate">[docs]</a>    <span class="k">def</span> <span class="nf">tcreate</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hfile</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datafile</span><span class="p">,</span> <span class="n">cdfile</span><span class="p">,</span> <span class="n">hfile</span><span class="p">,</span> <span class="n">replace</span><span class="p">,</span> <span class="n">header</span><span class="p">)</span>
</div>
    <span class="k">def</span> <span class="nf">_dump_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the table data in the ASCII format read by BinTableHDU.load()</span>
<span class="sd">        to fileobj.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">fileobj</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">:</span>
            <span class="n">root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">name</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="n">root</span> <span class="o">+</span> <span class="s">&#39;.txt&#39;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">linewriter</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">writer</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="n">FITSTableDumpDialect</span><span class="p">)</span>

        <span class="c"># Process each row of the table and output one row at a time</span>
        <span class="k">def</span> <span class="nf">format_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">format</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">format</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">:</span>
                <span class="n">itemsize</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">format</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%-*s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">itemsize</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">format</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s">&#39;AllInteger&#39;</span><span class="p">]:</span>
                <span class="c"># output integer</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%21d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">val</span>
            <span class="k">elif</span> <span class="n">format</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s">&#39;Complex&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%21.15g</span><span class="s">+</span><span class="si">%.15g</span><span class="s">j&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">val</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">val</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">format</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">typecodes</span><span class="p">[</span><span class="s">&#39;Float&#39;</span><span class="p">]:</span>
                <span class="c"># output floating point</span>
                <span class="k">return</span> <span class="s">&#39;</span><span class="si">%#21.15g</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">val</span>

        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c"># the line for this row of the table</span>

            <span class="c"># Process each column of the row.</span>
            <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="c"># format of data in a variable length array</span>
                <span class="c"># where None means it is not a VLA:</span>
                <span class="n">vla_format</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">_convert_format</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
                    <span class="c"># P format means this is a variable length array so output</span>
                    <span class="c"># the length of the array for this row and set the format</span>
                    <span class="c"># for the VLA data</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;VLA_Length=&#39;</span><span class="p">)</span>
                    <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&#39;</span><span class="si">%-21d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">]))</span>
                    <span class="n">_</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">option</span> <span class="o">=</span> <span class="n">_parse_tformat</span><span class="p">(</span><span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
                    <span class="n">vla_format</span> <span class="o">=</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="n">option</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">vla_format</span><span class="p">:</span>
                    <span class="c"># Output the data for each element in the array</span>
                    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                        <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_value</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">vla_format</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># The column data is a single element</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">array_format</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span>
                    <span class="k">if</span> <span class="n">array_format</span> <span class="o">==</span> <span class="s">&#39;V&#39;</span><span class="p">:</span>
                        <span class="n">array_format</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">char</span>
                    <span class="k">if</span> <span class="n">array_format</span> <span class="o">==</span> <span class="s">&#39;S&#39;</span><span class="p">:</span>
                        <span class="n">array_format</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">char</span> <span class="o">==</span> <span class="s">&#39;V&#39;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">:</span>
                            <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">array_format</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">line</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">format_value</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">],</span>
                                    <span class="n">array_format</span><span class="p">))</span>
            <span class="n">linewriter</span><span class="o">.</span><span class="n">writerow</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_dump_coldefs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the column definition parameters in the ASCII format read by</span>
<span class="sd">        BinTableHDU.load() to fileobj.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s">&#39;w&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="c"># Process each column of the table and output the result to the</span>
        <span class="c"># file one at a time</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">column</span><span class="o">.</span><span class="n">format</span><span class="p">]</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;disp&#39;</span><span class="p">,</span> <span class="s">&#39;unit&#39;</span><span class="p">,</span> <span class="s">&#39;dim&#39;</span><span class="p">,</span> <span class="s">&#39;null&#39;</span><span class="p">,</span> <span class="s">&#39;bscale&#39;</span><span class="p">,</span> <span class="s">&#39;bzero&#39;</span><span class="p">]</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="p">[</span><span class="s">&#39;</span><span class="si">%-16s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">value</span> <span class="k">if</span> <span class="n">value</span> <span class="k">else</span> <span class="s">&#39;&quot;&quot;&#39;</span><span class="p">)</span>
                     <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">)]</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">line</span><span class="p">))</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">,</span> <span class="n">coldefs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the table data from the ASCII file output by BinTableHDU.dump().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">initialpos</span> <span class="o">=</span> <span class="n">fileobj</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>  <span class="c"># We&#39;ll be returning here later</span>
        <span class="n">linereader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="n">FITSTableDumpDialect</span><span class="p">)</span>

        <span class="c"># First we need to do some preprocessing on the file to find out how</span>
        <span class="c"># much memory we&#39;ll need to reserve for the table.  This is necessary</span>
        <span class="c"># even if we already have the coldefs in order to determine how many</span>
        <span class="c"># rows to reserve memory for</span>
        <span class="n">vla_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">recformats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">coldefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">recformats</span> <span class="o">=</span> <span class="n">coldefs</span><span class="o">.</span><span class="n">_recformats</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">coldefs</span><span class="o">.</span><span class="n">names</span>

        <span class="k">def</span> <span class="nf">update_recformats</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
            <span class="n">fitsformat</span> <span class="o">=</span> <span class="n">_scalar_to_format</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">recformat</span> <span class="o">=</span> <span class="n">_convert_format</span><span class="p">(</span><span class="n">fitsformat</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">idx</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">recformats</span><span class="p">):</span>
                <span class="n">recformats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">recformat</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">_cmp_recformats</span><span class="p">(</span><span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">recformat</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">recformat</span>

        <span class="c"># TODO: The handling of VLAs could probably be simplified a bit</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">linereader</span><span class="p">:</span>
            <span class="n">nrows</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">coldefs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;VLA_Length=&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
                        <span class="n">vla_length</span> <span class="o">=</span> <span class="n">vla_lengths</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">vla_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="n">vla_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vla_length</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="k">while</span> <span class="n">vla_length</span><span class="p">:</span>
                        <span class="n">update_recformats</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">col</span><span class="p">)</span>
                        <span class="n">vla_length</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
                        <span class="n">vla_lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
                    <span class="n">update_recformats</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">col</span><span class="p">)</span>
                    <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Update the recformats for any VLAs</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">length</span><span class="p">)</span> <span class="o">+</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">format_parser</span><span class="p">(</span><span class="n">recformats</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span>

        <span class="c"># TODO: In the future maybe enable loading a bit at a time so that we</span>
        <span class="c"># can convert from this format to an actual FITS file on disk without</span>
        <span class="c"># needing enough physical memory to hold the entire thing at once;</span>
        <span class="c"># new_table() could use a similar feature.</span>
        <span class="n">hdu</span> <span class="o">=</span> <span class="n">BinTableHDU</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">),</span>
                                       <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="c"># TODO: It seems to me a lot of this could/should be handled from</span>
        <span class="c"># within the FITS_rec class rather than here.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">hdu</span><span class="o">.</span><span class="n">data</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">vla_lengths</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">arr</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_arrays</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">dt</span> <span class="o">=</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="nb">len</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">length</span><span class="p">)):]</span>

                <span class="c"># NOTE: FormatQ not supported here; it&#39;s hard to determine</span>
                <span class="c"># whether or not it will be necessary to use a wider descriptor</span>
                <span class="c"># type. The function documentation will have to serve as a</span>
                <span class="c"># warning that this is not supported.</span>
                <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">_FormatP</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="n">length</span><span class="p">)</span>
                <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">_cache_field</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">_makep</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span>

        <span class="k">def</span> <span class="nf">format_value</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="c"># Special formatting for a couple particular data types</span>
            <span class="k">if</span> <span class="n">recformats</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="s">&#39;L&#39;</span><span class="p">]:</span>
                <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">recformats</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">==</span> <span class="n">FITS2NUMPY</span><span class="p">[</span><span class="s">&#39;M&#39;</span><span class="p">]:</span>
                <span class="c"># For some reason, in arrays/fields where numpy expects a</span>
                <span class="c"># complex it&#39;s not happy to take a string representation</span>
                <span class="c"># (though it&#39;s happy to do that in other contexts), so we have</span>
                <span class="c"># to convert the string representation for it:</span>
                <span class="k">return</span> <span class="nb">complex</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">val</span>

        <span class="c"># Jump back to the start of the data and create a new line reader</span>
        <span class="n">fileobj</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">initialpos</span><span class="p">)</span>
        <span class="n">linereader</span> <span class="o">=</span> <span class="n">csv</span><span class="o">.</span><span class="n">reader</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">dialect</span><span class="o">=</span><span class="n">FITSTableDumpDialect</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">linereader</span><span class="p">):</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;VLA_Length=&#39;</span><span class="p">:</span>
                    <span class="n">vla_len</span> <span class="o">=</span> <span class="n">vla_lengths</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">2</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">vla_len</span><span class="p">)</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">vla_len</span><span class="p">]</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">vla_len</span>
                <span class="k">elif</span> <span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="c"># This is an array column</span>
                    <span class="n">array_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">dtype</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">array_size</span><span class="p">)</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="n">array_size</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">slice_</span> <span class="o">=</span> <span class="bp">None</span>

                <span class="k">if</span> <span class="n">slice_</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="c"># This is a scalar row element</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">format_value</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">line</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span><span class="p">[:]</span> <span class="o">=</span> <span class="p">[</span><span class="n">format_value</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
                                              <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="n">slice_</span><span class="p">]]</span>

                <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_load_coldefs</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Read the table column definitions from the ASCII file output by</span>
<span class="sd">        BinTableHDU.dump().</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">close_file</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">fileobj</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileobj</span><span class="p">,</span> <span class="s">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">close_file</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="n">columns</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fileobj</span><span class="p">:</span>
            <span class="n">words</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;format&#39;</span><span class="p">,</span> <span class="s">&#39;disp&#39;</span><span class="p">,</span> <span class="s">&#39;unit&#39;</span><span class="p">,</span> <span class="s">&#39;dim&#39;</span><span class="p">]:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;null&#39;</span><span class="p">,</span> <span class="s">&#39;bscale&#39;</span><span class="p">,</span> <span class="s">&#39;bzero&#39;</span><span class="p">]:</span>
                <span class="n">word</span> <span class="o">=</span> <span class="n">words</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&#39;&quot;&quot;&#39;</span><span class="p">,</span> <span class="s">&#39;&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">word</span><span class="p">:</span>
                    <span class="n">word</span> <span class="o">=</span> <span class="n">_str_to_num</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">word</span>
            <span class="n">columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Column</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">close_file</span><span class="p">:</span>
            <span class="n">fileobj</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">ColDefs</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

</div>
<span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.4&#39;</span><span class="p">,</span>
            <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;:meth:`BinTableHDU.from_columns` for new BINARY &#39;</span>
                        <span class="s">&#39;tables or :meth:`TableHDU.from_columns` for new &#39;</span>
                        <span class="s">&#39;ASCII tables&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="new_table"><a class="viewcode-back" href="../../../../../io/fits/api/tables.html#astropy.io.fits.new_table">[docs]</a><span class="k">def</span> <span class="nf">new_table</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">tbtype</span><span class="o">=</span><span class="n">BinTableHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a new table from the input column definitions.</span>

<span class="sd">    Warning: Creating a new table using this method creates an in-memory *copy*</span>
<span class="sd">    of all the column arrays in the input.  This is because if they are</span>
<span class="sd">    separate arrays they must be combined into a single contiguous array.</span>

<span class="sd">    If the column data is already in a single contiguous array (such as an</span>
<span class="sd">    existing record array) it may be better to create a `BinTableHDU` instance</span>
<span class="sd">    directly.  See the Astropy documentation for more details.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    input : sequence of `Column` or a `ColDefs`</span>
<span class="sd">        The data to create a table from</span>

<span class="sd">    header : `Header` instance</span>
<span class="sd">        Header to be used to populate the non-required keywords</span>

<span class="sd">    nrows : int</span>
<span class="sd">        Number of rows in the new table</span>

<span class="sd">    fill : bool</span>
<span class="sd">        If `True`, will fill all cells with zeros or blanks.  If</span>
<span class="sd">        `False`, copy the data from input, undefined cells will still</span>
<span class="sd">        be filled with zeros/blanks.</span>

<span class="sd">    tbtype : str or type</span>
<span class="sd">        Table type to be created (`BinTableHDU` or `TableHDU`) or the class</span>
<span class="sd">        name as a string.  Currently only `BinTableHDU` and `TableHDU` (ASCII</span>
<span class="sd">        tables) are supported.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># tbtype defaults to classes now, but in all prior version of PyFITS it was</span>
    <span class="c"># a string, so we still support that use case as well</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tbtype</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">tbtype</span>
        <span class="n">tbtype</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Right now the string input must be one of &#39;TableHDU&#39; or &#39;BinTableHDU&#39;</span>
        <span class="c"># and nothing else, though we will allow this to be case insensitive</span>
        <span class="c"># This could be done more generically through the HDU registry, but my</span>
        <span class="c"># hope is to deprecate this function anyways so there&#39;s not much point</span>
        <span class="c"># in trying to make it more &quot;generic&quot;.</span>
        <span class="k">if</span> <span class="n">tbtype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;tablehdu&#39;</span><span class="p">:</span>
            <span class="n">cls</span> <span class="o">=</span> <span class="n">TableHDU</span>
        <span class="k">elif</span> <span class="n">tbtype</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s">&#39;bintablehdu&#39;</span><span class="p">:</span>
            <span class="n">cls</span> <span class="o">=</span> <span class="n">BinTableHDU</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;tbtype must be one of &#39;TableHDU&#39; or &quot;</span>
                             <span class="s">&quot;&#39;BinTableHDU&#39;&quot;</span><span class="p">)</span>

    <span class="c"># construct a table HDU of the requested type</span>
    <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">from_columns</span><span class="p">(</span><span class="nb">input</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="n">nrows</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>

</div>
<span class="nd">@contextlib.contextmanager</span>
<span class="k">def</span> <span class="nf">_binary_table_byte_swap</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Ensures that all the data of a binary FITS table (represented as a FITS_rec</span>
<span class="sd">    object) is in a big-endian byte order.  Columns are swapped in-place one</span>
<span class="sd">    at a time, and then returned to their previous byte order when this context</span>
<span class="sd">    manager exits.</span>

<span class="sd">    Because a new dtype is needed to represent the byte-swapped columns, the</span>
<span class="sd">    new dtype is temporarily applied as well.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span>

    <span class="n">names</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">formats</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">offsets</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">to_swap</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">byteorder</span> <span class="o">==</span> <span class="s">&#39;little&#39;</span><span class="p">:</span>
        <span class="n">swap_types</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s">&#39;=&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">swap_types</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;&lt;&#39;</span><span class="p">,)</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">orig_dtype</span><span class="o">.</span><span class="n">names</span><span class="p">):</span>
        <span class="n">field</span> <span class="o">=</span> <span class="n">_get_recarray_field</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="n">field_dtype</span><span class="p">,</span> <span class="n">field_offset</span> <span class="o">=</span> <span class="n">orig_dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">formats</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_dtype</span><span class="p">)</span>
        <span class="n">offsets</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_offset</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">chararray</span><span class="o">.</span><span class="n">chararray</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c"># only swap unswapped</span>
        <span class="c"># must use field_dtype.base here since for multi-element dtypes,</span>
        <span class="c"># the .str with be &#39;|V&lt;N&gt;&#39; where &lt;N&gt; is the total bytes per element</span>
        <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">field_dtype</span><span class="o">.</span><span class="n">base</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">swap_types</span><span class="p">:</span>
            <span class="n">to_swap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field</span><span class="p">)</span>
            <span class="c"># Override the dtype for this field in the new record dtype with</span>
            <span class="c"># the byteswapped version</span>
            <span class="n">formats</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">()</span>

        <span class="c"># deal with var length table</span>
        <span class="n">recformat</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">_recformats</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">recformat</span><span class="p">,</span> <span class="n">_FormatP</span><span class="p">):</span>
            <span class="n">coldata</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">field</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">coldata</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">chararray</span><span class="o">.</span><span class="n">chararray</span><span class="p">)</span> <span class="ow">and</span>
                        <span class="n">c</span><span class="o">.</span><span class="n">itemsize</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">swap_types</span><span class="p">):</span>
                    <span class="n">to_swap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">to_swap</span><span class="p">):</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">new_dtype</span> <span class="o">=</span> <span class="n">nh</span><span class="o">.</span><span class="n">realign_dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">formats</span><span class="p">))),</span>
                                 <span class="n">offsets</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">new_dtype</span>

    <span class="k">yield</span> <span class="n">data</span>

    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">to_swap</span><span class="p">:</span>
        <span class="n">arr</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">data</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">orig_dtype</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1. &nbsp;
    Last built 12 May 2016. <br/>
  </p>
</footer>
  </body>
</html>