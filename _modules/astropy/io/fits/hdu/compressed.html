<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.io.fits.hdu.compressed &mdash; Astropy v1.2.dev14978</title>
    
    <link rel="stylesheet" href="../../../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../../',
        VERSION:     '1.2.dev14978',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.2.dev14978" href="../../../../../index.html" />
    <link rel="up" title="Module code" href="../../../../index.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../../../index.html">Astropy v1.2.dev14978</a>
	 &raquo;
      </li>
      <li><a href="../../../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.io.fits.hdu.compressed</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see PYFITS.rst</span>

<span class="kn">import</span> <span class="nn">ctypes</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.base</span> <span class="kn">import</span> <span class="n">DELAYED</span><span class="p">,</span> <span class="n">ExtensionHDU</span><span class="p">,</span> <span class="n">BITPIX2DTYPE</span><span class="p">,</span> <span class="n">DTYPE2BITPIX</span>
<span class="kn">from</span> <span class="nn">.image</span> <span class="kn">import</span> <span class="n">ImageHDU</span>
<span class="kn">from</span> <span class="nn">.table</span> <span class="kn">import</span> <span class="n">BinTableHDU</span>
<span class="kn">from</span> <span class="nn">..card</span> <span class="kn">import</span> <span class="n">Card</span>
<span class="kn">from</span> <span class="nn">..column</span> <span class="kn">import</span> <span class="n">Column</span><span class="p">,</span> <span class="n">ColDefs</span><span class="p">,</span> <span class="n">TDEF_RE</span>
<span class="kn">from</span> <span class="nn">..column</span> <span class="kn">import</span> <span class="n">KEYWORD_NAMES</span> <span class="k">as</span> <span class="n">TABLE_KEYWORD_NAMES</span>
<span class="kn">from</span> <span class="nn">..fitsrec</span> <span class="kn">import</span> <span class="n">FITS_rec</span>
<span class="kn">from</span> <span class="nn">..header</span> <span class="kn">import</span> <span class="n">Header</span>
<span class="kn">from</span> <span class="nn">..util</span> <span class="kn">import</span> <span class="p">(</span><span class="n">_is_pseudo_unsigned</span><span class="p">,</span> <span class="n">_unsigned_zero</span><span class="p">,</span> <span class="n">_is_int</span><span class="p">,</span>
                    <span class="n">_get_array_mmap</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">....extern.six</span> <span class="kn">import</span> <span class="n">string_types</span><span class="p">,</span> <span class="n">iteritems</span>
<span class="kn">from</span> <span class="nn">....utils</span> <span class="kn">import</span> <span class="n">lazyproperty</span><span class="p">,</span> <span class="n">deprecated</span>
<span class="kn">from</span> <span class="nn">....utils.compat</span> <span class="kn">import</span> <span class="n">ignored</span>
<span class="kn">from</span> <span class="nn">....utils.exceptions</span> <span class="kn">import</span> <span class="p">(</span><span class="n">AstropyPendingDeprecationWarning</span><span class="p">,</span>
                                  <span class="n">AstropyUserWarning</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">..</span> <span class="kn">import</span> <span class="n">compression</span>
    <span class="n">COMPRESSION_SUPPORTED</span> <span class="o">=</span> <span class="n">COMPRESSION_ENABLED</span> <span class="o">=</span> <span class="bp">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">COMPRESSION_SUPPORTED</span> <span class="o">=</span> <span class="n">COMPRESSION_ENABLED</span> <span class="o">=</span> <span class="bp">False</span>


<span class="c"># Quantization dithering method constants; these are right out of fitsio.h</span>
<span class="n">NO_DITHER</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="n">SUBTRACTIVE_DITHER_1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">SUBTRACTIVE_DITHER_2</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">QUANTIZE_METHOD_NAMES</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">NO_DITHER</span><span class="p">:</span> <span class="s">&#39;NO_DITHER&#39;</span><span class="p">,</span>
    <span class="n">SUBTRACTIVE_DITHER_1</span><span class="p">:</span> <span class="s">&#39;SUBTRACTIVE_DITHER_1&#39;</span><span class="p">,</span>
    <span class="n">SUBTRACTIVE_DITHER_2</span><span class="p">:</span> <span class="s">&#39;SUBTRACTIVE_DITHER_2&#39;</span>
<span class="p">}</span>
<span class="n">DITHER_SEED_CLOCK</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">DITHER_SEED_CHECKSUM</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


<span class="c"># Default compression parameter values</span>
<span class="n">DEFAULT_COMPRESSION_TYPE</span> <span class="o">=</span> <span class="s">&#39;RICE_1&#39;</span>
<span class="n">DEFAULT_QUANTIZE_LEVEL</span> <span class="o">=</span> <span class="mf">16.</span>
<span class="n">DEFAULT_QUANTIZE_METHOD</span> <span class="o">=</span> <span class="n">NO_DITHER</span>
<span class="n">DEFAULT_DITHER_SEED</span> <span class="o">=</span> <span class="n">DITHER_SEED_CLOCK</span>
<span class="n">DEFAULT_HCOMP_SCALE</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">DEFAULT_HCOMP_SMOOTH</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">DEFAULT_BLOCK_SIZE</span> <span class="o">=</span> <span class="mi">32</span>
<span class="n">DEFAULT_BYTE_PIX</span> <span class="o">=</span> <span class="mi">4</span>

<span class="n">CMTYPE_ALIASES</span> <span class="o">=</span> <span class="p">{}</span>

<span class="c"># CFITSIO version-specific features</span>
<span class="k">if</span> <span class="n">COMPRESSION_SUPPORTED</span><span class="p">:</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">CFITSIO_SUPPORTS_GZIPDATA</span> <span class="o">=</span> <span class="n">compression</span><span class="o">.</span><span class="n">CFITSIO_VERSION</span> <span class="o">&gt;=</span> <span class="mf">3.28</span>
        <span class="n">CFITSIO_SUPPORTS_Q_FORMAT</span> <span class="o">=</span> <span class="n">compression</span><span class="o">.</span><span class="n">CFITSIO_VERSION</span> <span class="o">&gt;=</span> <span class="mf">3.35</span>
        <span class="k">if</span> <span class="n">compression</span><span class="o">.</span><span class="n">CFITSIO_VERSION</span> <span class="o">&gt;=</span> <span class="mf">3.35</span><span class="p">:</span>
            <span class="n">CMTYPE_ALIASES</span><span class="p">[</span><span class="s">&#39;RICE_ONE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s">&#39;RICE_1&#39;</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="c"># This generally shouldn&#39;t happen unless running setup.py in an</span>
        <span class="c"># environment where an old build of pyfits exists</span>
        <span class="n">CFITSIO_SUPPORTS_GZIPDATA</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">CFITSIO_SUPPORTS_Q_FORMAT</span> <span class="o">=</span> <span class="bp">True</span>


<span class="n">COMPRESSION_KEYWORDS</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;ZIMAGE&#39;</span><span class="p">,</span> <span class="s">&#39;ZCMPTYPE&#39;</span><span class="p">,</span> <span class="s">&#39;ZBITPIX&#39;</span><span class="p">,</span> <span class="s">&#39;ZNAXIS&#39;</span><span class="p">,</span>
                            <span class="s">&#39;ZMASKCMP&#39;</span><span class="p">,</span> <span class="s">&#39;ZSIMPLE&#39;</span><span class="p">,</span> <span class="s">&#39;ZTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;ZEXTEND&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">CompImageHeader</span><span class="p">(</span><span class="n">Header</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Header object for compressed image HDUs designed to keep the compression</span>
<span class="sd">    header and the underlying image header properly synchronized.</span>

<span class="sd">    This essentially wraps the image header, so that all values are read from</span>
<span class="sd">    and written to the image header.  However, updates to the image header will</span>
<span class="sd">    also update the table header where appropriate.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># TODO: The difficulty of implementing this screams a need to rewrite this</span>
    <span class="c"># module</span>

    <span class="n">_keyword_remaps</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;SIMPLE&#39;</span><span class="p">:</span> <span class="s">&#39;ZSIMPLE&#39;</span><span class="p">,</span> <span class="s">&#39;XTENSION&#39;</span><span class="p">:</span> <span class="s">&#39;ZTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;BITPIX&#39;</span><span class="p">:</span> <span class="s">&#39;ZBITPIX&#39;</span><span class="p">,</span>
        <span class="s">&#39;NAXIS&#39;</span><span class="p">:</span> <span class="s">&#39;ZNAXIS&#39;</span><span class="p">,</span> <span class="s">&#39;EXTEND&#39;</span><span class="p">:</span> <span class="s">&#39;ZEXTEND&#39;</span><span class="p">,</span> <span class="s">&#39;BLOCKED&#39;</span><span class="p">:</span> <span class="s">&#39;ZBLOCKED&#39;</span><span class="p">,</span>
        <span class="s">&#39;PCOUNT&#39;</span><span class="p">:</span> <span class="s">&#39;ZPCOUNT&#39;</span><span class="p">,</span> <span class="s">&#39;GCOUNT&#39;</span><span class="p">:</span> <span class="s">&#39;ZGCOUNT&#39;</span><span class="p">,</span> <span class="s">&#39;CHECKSUM&#39;</span><span class="p">:</span> <span class="s">&#39;ZHECKSUM&#39;</span><span class="p">,</span>
        <span class="s">&#39;DATASUM&#39;</span><span class="p">:</span> <span class="s">&#39;ZDATASUM&#39;</span>
    <span class="p">}</span>

    <span class="n">_zdef_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s">r&#39;(?P&lt;label&gt;^[Zz][a-zA-Z]*)(?P&lt;num&gt;[1-9][0-9 ]*$)?&#39;</span><span class="p">)</span>
    <span class="n">_compression_keywords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">_keyword_remaps</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
        <span class="p">[</span><span class="s">&#39;ZIMAGE&#39;</span><span class="p">,</span> <span class="s">&#39;ZCMPTYPE&#39;</span><span class="p">,</span> <span class="s">&#39;ZMASKCMP&#39;</span><span class="p">,</span> <span class="s">&#39;ZQUANTIZ&#39;</span><span class="p">,</span> <span class="s">&#39;ZDITHER0&#39;</span><span class="p">])</span>
    <span class="n">_indexed_compression_keywords</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s">&#39;ZNAXIS&#39;</span><span class="p">,</span> <span class="s">&#39;ZTILE&#39;</span><span class="p">,</span> <span class="s">&#39;ZNAME&#39;</span><span class="p">,</span> <span class="s">&#39;ZVAL&#39;</span><span class="p">])</span>
    <span class="c"># TODO: Once it place it should be possible to manage some of this through</span>
    <span class="c"># the schema system, but it&#39;s not quite ready for that yet.  Also it still</span>
    <span class="c"># makes more sense to change CompImageHDU to subclass ImageHDU :/</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table_header</span><span class="p">,</span> <span class="n">image_header</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">image_header</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">image_header</span> <span class="o">=</span> <span class="n">Header</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_cards</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">_cards</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_indices</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">_keyword_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rvkc_indices</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">_rvkc_indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_modified</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">_modified</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span> <span class="o">=</span> <span class="n">table_header</span>

    <span class="c"># We need to override and Header methods that can modify the header, and</span>
    <span class="c"># ensure that they sync with the underlying _table_header</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c"># This isn&#39;t pretty, but if the `key` is either an int or a tuple we</span>
        <span class="c"># need to figure out what keyword name that maps to before doing</span>
        <span class="c"># anything else; these checks will be repeated later in the</span>
        <span class="c"># super().__setitem__ call but I don&#39;t see another way around it</span>
        <span class="c"># without some major refactoring</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_slice</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_from_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># We don&#39;t want to specify and index otherwise, because that will</span>
            <span class="c"># break the behavior for new keywords and for commentary keywords</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_reserved_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>


        <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">remapped_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="p">[</span><span class="n">remapped_keyword</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c"># Else this will pass through to ._update</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_haswildcard</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
            <span class="c"># If given a slice pass that on to the superclass and bail out</span>
            <span class="c"># early; we only want to make updates to _table_header when given</span>
            <span class="c"># a key specifying a single keyword</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_from_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">keyword</span><span class="p">,</span> <span class="n">index</span> <span class="o">=</span> <span class="n">key</span><span class="p">,</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s">&quot;Keyword </span><span class="si">%r</span><span class="s"> not found.&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__delitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">remapped_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">remapped_keyword</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">index</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="p">[(</span><span class="n">remapped_keyword</span><span class="p">,</span> <span class="n">index</span><span class="p">)]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="p">[</span><span class="n">remapped_keyword</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bottom</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c"># This logic unfortunately needs to be duplicated from the base class</span>
        <span class="c"># in order to determine the keyword</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">card</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">()</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;The value appended to a Header must be either a keyword or &#39;</span>
                <span class="s">&#39;(keyword, value, [comment]) tuple; got: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">card</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_reserved_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="o">=</span><span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="n">useblanks</span><span class="p">,</span>
                                            <span class="n">bottom</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>

        <span class="n">remapped_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">remapped_keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="o">=</span><span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="n">useblanks</span><span class="p">,</span>
                                  <span class="n">bottom</span><span class="o">=</span><span class="n">bottom</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="c"># Determine condition to pass through to append</span>
            <span class="k">if</span> <span class="n">after</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">key</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_cards</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="o">*</span><span class="n">card</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">Card</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&#39;The value inserted into a Header must be either a keyword or &#39;</span>
                <span class="s">&#39;(keyword, value, [comment]) tuple; got: </span><span class="si">%r</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">card</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_reserved_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c"># Now the tricky part is to determine where to insert in the table</span>
        <span class="c"># header.  If given a numerical index we need to map that to the</span>
        <span class="c"># corresponding index in the table header.  Although rare, there may be</span>
        <span class="c"># cases where there is no mapping in which case we just try the same</span>
        <span class="c"># index</span>
        <span class="c"># NOTE: It is crucial that remapped_index in particular is figured out</span>
        <span class="c"># before the image header is modified</span>
        <span class="n">remapped_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">remapped_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">card</span><span class="o">.</span><span class="n">keyword</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="n">useblanks</span><span class="p">,</span>
                                            <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>

        <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">remapped_keyword</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">card</span><span class="o">.</span><span class="n">comment</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">remapped_index</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">useblanks</span><span class="o">=</span><span class="n">useblanks</span><span class="p">,</span>
                                  <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">):</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_reserved_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">Card</span><span class="o">.</span><span class="n">_commentary_keywords</span><span class="p">:</span>
            <span class="c"># Otherwise this will result in a duplicate insertion</span>
            <span class="k">return</span>

        <span class="n">remapped_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="o">.</span><span class="n">_update</span><span class="p">((</span><span class="n">remapped_keyword</span><span class="p">,)</span> <span class="o">+</span> <span class="n">card</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c"># Last piece needed (I think) for synchronizing with the real header</span>
    <span class="c"># This one is tricky since _relativeinsert calls insert</span>
    <span class="k">def</span> <span class="nf">_relativeinsert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="n">keyword</span> <span class="o">=</span> <span class="n">card</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_reserved_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c"># Now we have to figure out how to remap &#39;before&#39; and &#39;after&#39;</span>
        <span class="k">if</span> <span class="n">before</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">after</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">remapped_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_index</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remapped_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">after</span><span class="p">)</span>
            <span class="n">remapped_before</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">remapped_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_index</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">remapped_before</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">before</span><span class="p">)</span>
            <span class="n">remapped_after</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHeader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">before</span><span class="p">,</span>
                                                     <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">,</span>
                                                     <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

        <span class="n">remapped_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="n">card</span> <span class="o">=</span> <span class="n">Card</span><span class="p">(</span><span class="n">remapped_keyword</span><span class="p">,</span> <span class="n">card</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">card</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="o">.</span><span class="n">_relativeinsert</span><span class="p">(</span><span class="n">card</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="n">remapped_before</span><span class="p">,</span>
                                           <span class="n">after</span><span class="o">=</span><span class="n">remapped_after</span><span class="p">,</span>
                                           <span class="n">replace</span><span class="o">=</span><span class="n">replace</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_is_reserved_keyword</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">keyword</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="s">&#39;Keyword </span><span class="si">%r</span><span class="s"> is reserved for use by the FITS Tiled Image &#39;</span>
               <span class="s">&#39;Convention and will not be stored in the header for the &#39;</span>
               <span class="s">&#39;image being compressed.&#39;</span> <span class="o">%</span> <span class="n">keyword</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keyword</span> <span class="o">==</span> <span class="s">&#39;TFIELDS&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">TDEF_RE</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="n">TABLE_KEYWORD_NAMES</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">cls</span><span class="o">.</span><span class="n">_zdef_re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;label&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="n">num</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="s">&#39;num&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_indexed_compression_keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">True</span>
            <span class="k">elif</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">cls</span><span class="o">.</span><span class="n">_compression_keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">warn</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_remap_keyword</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="c"># Given a keyword that one might set on an image, remap that keyword to</span>
        <span class="c"># the name used for it in the COMPRESSED HDU header</span>
        <span class="c"># This is mostly just a lookup in _keyword_remaps, but needs handling</span>
        <span class="c"># for NAXISn keywords</span>

        <span class="n">is_naxisn</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">keyword</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;NAXIS&#39;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>
                <span class="n">is_naxisn</span> <span class="o">=</span> <span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">is_naxisn</span><span class="p">:</span>
            <span class="k">return</span> <span class="s">&#39;ZNAXIS</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">index</span>

        <span class="c"># If the keyword does not need to be remapped then just return the</span>
        <span class="c"># original keyword</span>
        <span class="k">return</span> <span class="n">cls</span><span class="o">.</span><span class="n">_keyword_remaps</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">keyword</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_remap_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="c"># Given an integer index into this header, map that to the index in the</span>
        <span class="c"># table header for the same card.  If the card doesn&#39;t exist in the</span>
        <span class="c"># table header (generally should *not* be the case) this will just</span>
        <span class="c"># return the same index</span>
        <span class="c"># This *does* also accept a keyword or (keyword, repeat) tuple and</span>
        <span class="c"># obtains the associated numerical index with self._cardindex</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="n">keyword</span><span class="p">,</span> <span class="n">repeat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_keyword_from_index</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="n">remapped_insert_keyword</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_remap_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">)</span>

        <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">IndexError</span><span class="p">,</span> <span class="ne">KeyError</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_table_header</span><span class="o">.</span><span class="n">_cardindex</span><span class="p">((</span><span class="n">remapped_insert_keyword</span><span class="p">,</span>
                                                 <span class="n">repeat</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">idx</span>


<span class="c"># TODO: Fix this class so that it doesn&#39;t actually inherit from BinTableHDU,</span>
<span class="c"># but instead has an internal BinTableHDU reference</span>
<div class="viewcode-block" id="CompImageHDU"><a class="viewcode-back" href="../../../../../io/fits/api/images.html#astropy.io.fits.CompImageHDU">[docs]</a><span class="k">class</span> <span class="nc">CompImageHDU</span><span class="p">(</span><span class="n">BinTableHDU</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compressed Image HDU class.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Maps deprecated keyword arguments to __init__ to their new names</span>
    <span class="n">DEPRECATED_KWARGS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">&#39;compressionType&#39;</span><span class="p">:</span> <span class="s">&#39;compression_type&#39;</span><span class="p">,</span> <span class="s">&#39;tileSize&#39;</span><span class="p">:</span> <span class="s">&#39;tile_size&#39;</span><span class="p">,</span>
        <span class="s">&#39;hcompScale&#39;</span><span class="p">:</span> <span class="s">&#39;hcomp_scale&#39;</span><span class="p">,</span> <span class="s">&#39;hcompSmooth&#39;</span><span class="p">:</span> <span class="s">&#39;hcomp_smooth&#39;</span><span class="p">,</span>
        <span class="s">&#39;quantizeLevel&#39;</span><span class="p">:</span> <span class="s">&#39;quantize_level&#39;</span>
    <span class="p">}</span>

    <span class="n">_manages_own_heap</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The calls to CFITSIO lay out the heap data in memory, and we write it out</span>
<span class="sd">    the same way CFITSIO organizes it.  In principle this would break if a user</span>
<span class="sd">    manually changes the underlying compressed data by hand, but there is no</span>
<span class="sd">    reason they would want to do that (and if they do that&#39;s their</span>
<span class="sd">    responsibility).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">compression_type</span><span class="o">=</span><span class="n">DEFAULT_COMPRESSION_TYPE</span><span class="p">,</span>
                 <span class="n">tile_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">hcomp_scale</span><span class="o">=</span><span class="n">DEFAULT_HCOMP_SCALE</span><span class="p">,</span>
                 <span class="n">hcomp_smooth</span><span class="o">=</span><span class="n">DEFAULT_HCOMP_SMOOTH</span><span class="p">,</span>
                 <span class="n">quantize_level</span><span class="o">=</span><span class="n">DEFAULT_QUANTIZE_LEVEL</span><span class="p">,</span>
                 <span class="n">quantize_method</span><span class="o">=</span><span class="n">DEFAULT_QUANTIZE_METHOD</span><span class="p">,</span>
                 <span class="n">dither_seed</span><span class="o">=</span><span class="n">DEFAULT_DITHER_SEED</span><span class="p">,</span>
                 <span class="n">do_not_scale_image_data</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">uint</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">scale_back</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array, optional</span>
<span class="sd">            Uncompressed image data</span>

<span class="sd">        header : Header instance, optional</span>
<span class="sd">            Header to be associated with the image; when reading the HDU from a</span>
<span class="sd">            file (data=DELAYED), the header read from the file</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            The ``EXTNAME`` value; if this value is `None`, then the name from</span>
<span class="sd">            the input image header will be used; if there is no name in the</span>
<span class="sd">            input image header then the default name ``COMPRESSED_IMAGE`` is</span>
<span class="sd">            used.</span>

<span class="sd">        compression_type : str, optional</span>
<span class="sd">            Compression algorithm: one of</span>
<span class="sd">            ``&#39;RICE_1&#39;``, ``&#39;RICE_ONE&#39;``, ``&#39;PLIO_1&#39;``, ``&#39;GZIP_1&#39;``,</span>
<span class="sd">            ``&#39;GZIP_2&#39;``, ``&#39;HCOMPRESS_1&#39;``</span>

<span class="sd">        tile_size : int, optional</span>
<span class="sd">            Compression tile sizes.  Default treats each row of image as a</span>
<span class="sd">            tile.</span>

<span class="sd">        hcomp_scale : float, optional</span>
<span class="sd">            HCOMPRESS scale parameter</span>

<span class="sd">        hcomp_smooth : float, optional</span>
<span class="sd">            HCOMPRESS smooth parameter</span>

<span class="sd">        quantize_level : float, optional</span>
<span class="sd">            Floating point quantization level; see note below</span>

<span class="sd">        quantize_method : int, optional</span>
<span class="sd">            Floating point quantization dithering method; can be either</span>
<span class="sd">            ``NO_DITHER`` (-1), ``SUBTRACTIVE_DITHER_1`` (1; default), or</span>
<span class="sd">            ``SUBTRACTIVE_DITHER_2`` (2); see note below</span>

<span class="sd">        dither_seed : int, optional</span>
<span class="sd">            Random seed to use for dithering; can be either an integer in the</span>
<span class="sd">            range 1 to 1000 (inclusive), ``DITHER_SEED_CLOCK`` (0; default), or</span>
<span class="sd">            ``DITHER_SEED_CHECKSUM`` (-1); see note below</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The astropy.io.fits package supports 2 methods of image compression:</span>

<span class="sd">            1) The entire FITS file may be externally compressed with the gzip</span>
<span class="sd">               or pkzip utility programs, producing a ``*.gz`` or ``*.zip``</span>
<span class="sd">               file, respectively.  When reading compressed files of this type,</span>
<span class="sd">               Astropy first uncompresses the entire file into a temporary file</span>
<span class="sd">               before performing the requested read operations.  The</span>
<span class="sd">               astropy.io.fits package does not support writing to these types</span>
<span class="sd">               of compressed files.  This type of compression is supported in</span>
<span class="sd">               the ``_File`` class, not in the `CompImageHDU` class.  The file</span>
<span class="sd">               compression type is recognized by the ``.gz`` or ``.zip`` file</span>
<span class="sd">               name extension.</span>

<span class="sd">            2) The `CompImageHDU` class supports the FITS tiled image</span>
<span class="sd">               compression convention in which the image is subdivided into a</span>
<span class="sd">               grid of rectangular tiles, and each tile of pixels is</span>
<span class="sd">               individually compressed.  The details of this FITS compression</span>
<span class="sd">               convention are described at the `FITS Support Office web site</span>
<span class="sd">               &lt;http://fits.gsfc.nasa.gov/registry/tilecompression.html&gt;`_.</span>
<span class="sd">               Basically, the compressed image tiles are stored in rows of a</span>
<span class="sd">               variable length array column in a FITS binary table.  The</span>
<span class="sd">               astropy.io.fits recognizes that this binary table extension</span>
<span class="sd">               contains an image and treats it as if it were an image</span>
<span class="sd">               extension.  Under this tile-compression format, FITS header</span>
<span class="sd">               keywords remain uncompressed.  At this time, Astropy does not</span>
<span class="sd">               support the ability to extract and uncompress sections of the</span>
<span class="sd">               image without having to uncompress the entire image.</span>

<span class="sd">        The astropy.io.fits package supports 3 general-purpose compression</span>
<span class="sd">        algorithms plus one other special-purpose compression technique that is</span>
<span class="sd">        designed for data masks with positive integer pixel values.  The 3</span>
<span class="sd">        general purpose algorithms are GZIP, Rice, and HCOMPRESS, and the</span>
<span class="sd">        special-purpose technique is the IRAF pixel list compression technique</span>
<span class="sd">        (PLIO).  The ``compression_type`` parameter defines the compression</span>
<span class="sd">        algorithm to be used.</span>

<span class="sd">        The FITS image can be subdivided into any desired rectangular grid of</span>
<span class="sd">        compression tiles.  With the GZIP, Rice, and PLIO algorithms, the</span>
<span class="sd">        default is to take each row of the image as a tile.  The HCOMPRESS</span>
<span class="sd">        algorithm is inherently 2-dimensional in nature, so the default in this</span>
<span class="sd">        case is to take 16 rows of the image per tile.  In most cases, it makes</span>
<span class="sd">        little difference what tiling pattern is used, so the default tiles are</span>
<span class="sd">        usually adequate.  In the case of very small images, it could be more</span>
<span class="sd">        efficient to compress the whole image as a single tile.  Note that the</span>
<span class="sd">        image dimensions are not required to be an integer multiple of the tile</span>
<span class="sd">        dimensions; if not, then the tiles at the edges of the image will be</span>
<span class="sd">        smaller than the other tiles.  The ``tile_size`` parameter may be</span>
<span class="sd">        provided as a list of tile sizes, one for each dimension in the image.</span>
<span class="sd">        For example a ``tile_size`` value of ``[100,100]`` would divide a 300 X</span>
<span class="sd">        300 image into 9 100 X 100 tiles.</span>

<span class="sd">        The 4 supported image compression algorithms are all &#39;lossless&#39; when</span>
<span class="sd">        applied to integer FITS images; the pixel values are preserved exactly</span>
<span class="sd">        with no loss of information during the compression and uncompression</span>
<span class="sd">        process.  In addition, the HCOMPRESS algorithm supports a &#39;lossy&#39;</span>
<span class="sd">        compression mode that will produce larger amount of image compression.</span>
<span class="sd">        This is achieved by specifying a non-zero value for the ``hcomp_scale``</span>
<span class="sd">        parameter.  Since the amount of compression that is achieved depends</span>
<span class="sd">        directly on the RMS noise in the image, it is usually more convenient</span>
<span class="sd">        to specify the ``hcomp_scale`` factor relative to the RMS noise.</span>
<span class="sd">        Setting ``hcomp_scale = 2.5`` means use a scale factor that is 2.5</span>
<span class="sd">        times the calculated RMS noise in the image tile.  In some cases it may</span>
<span class="sd">        be desirable to specify the exact scaling to be used, instead of</span>
<span class="sd">        specifying it relative to the calculated noise value.  This may be done</span>
<span class="sd">        by specifying the negative of the desired scale value (typically in the</span>
<span class="sd">        range -2 to -100).</span>

<span class="sd">        Very high compression factors (of 100 or more) can be achieved by using</span>
<span class="sd">        large ``hcomp_scale`` values, however, this can produce undesirable</span>
<span class="sd">        &#39;blocky&#39; artifacts in the compressed image.  A variation of the</span>
<span class="sd">        HCOMPRESS algorithm (called HSCOMPRESS) can be used in this case to</span>
<span class="sd">        apply a small amount of smoothing of the image when it is uncompressed</span>
<span class="sd">        to help cover up these artifacts.  This smoothing is purely cosmetic</span>
<span class="sd">        and does not cause any significant change to the image pixel values.</span>
<span class="sd">        Setting the ``hcomp_smooth`` parameter to 1 will engage the smoothing</span>
<span class="sd">        algorithm.</span>

<span class="sd">        Floating point FITS images (which have ``BITPIX`` = -32 or -64) usually</span>
<span class="sd">        contain too much &#39;noise&#39; in the least significant bits of the mantissa</span>
<span class="sd">        of the pixel values to be effectively compressed with any lossless</span>
<span class="sd">        algorithm.  Consequently, floating point images are first quantized</span>
<span class="sd">        into scaled integer pixel values (and thus throwing away much of the</span>
<span class="sd">        noise) before being compressed with the specified algorithm (either</span>
<span class="sd">        GZIP, RICE, or HCOMPRESS).  This technique produces much higher</span>
<span class="sd">        compression factors than simply using the GZIP utility to externally</span>
<span class="sd">        compress the whole FITS file, but it also means that the original</span>
<span class="sd">        floating point value pixel values are not exactly preserved.  When done</span>
<span class="sd">        properly, this integer scaling technique will only discard the</span>
<span class="sd">        insignificant noise while still preserving all the real information in</span>
<span class="sd">        the image.  The amount of precision that is retained in the pixel</span>
<span class="sd">        values is controlled by the ``quantize_level`` parameter.  Larger</span>
<span class="sd">        values will result in compressed images whose pixels more closely match</span>
<span class="sd">        the floating point pixel values, but at the same time the amount of</span>
<span class="sd">        compression that is achieved will be reduced.  Users should experiment</span>
<span class="sd">        with different values for this parameter to determine the optimal value</span>
<span class="sd">        that preserves all the useful information in the image, without</span>
<span class="sd">        needlessly preserving all the &#39;noise&#39; which will hurt the compression</span>
<span class="sd">        efficiency.</span>

<span class="sd">        The default value for the ``quantize_level`` scale factor is 16, which</span>
<span class="sd">        means that scaled integer pixel values will be quantized such that the</span>
<span class="sd">        difference between adjacent integer values will be 1/16th of the noise</span>
<span class="sd">        level in the image background.  An optimized algorithm is used to</span>
<span class="sd">        accurately estimate the noise in the image.  As an example, if the RMS</span>
<span class="sd">        noise in the background pixels of an image = 32.0, then the spacing</span>
<span class="sd">        between adjacent scaled integer pixel values will equal 2.0 by default.</span>
<span class="sd">        Note that the RMS noise is independently calculated for each tile of</span>
<span class="sd">        the image, so the resulting integer scaling factor may fluctuate</span>
<span class="sd">        slightly for each tile.  In some cases, it may be desirable to specify</span>
<span class="sd">        the exact quantization level to be used, instead of specifying it</span>
<span class="sd">        relative to the calculated noise value.  This may be done by specifying</span>
<span class="sd">        the negative of desired quantization level for the value of</span>
<span class="sd">        ``quantize_level``.  In the previous example, one could specify</span>
<span class="sd">        ``quantize_level = -2.0`` so that the quantized integer levels differ</span>
<span class="sd">        by 2.0.  Larger negative values for ``quantize_level`` means that the</span>
<span class="sd">        levels are more coarsely-spaced, and will produce higher compression</span>
<span class="sd">        factors.</span>

<span class="sd">        The quantization algorithm can also apply one of two random dithering</span>
<span class="sd">        methods in order to reduce bias in the measured intensity of background</span>
<span class="sd">        regions.  The default method, specified with the constant</span>
<span class="sd">        ``SUBTRACTIVE_DITHER_1`` adds dithering to the zero-point of the</span>
<span class="sd">        quantization array itself rather than adding noise to the actual image.</span>
<span class="sd">        The random noise is added on a pixel-by-pixel basis, so in order</span>
<span class="sd">        restore each pixel from its integer value to its floating point value</span>
<span class="sd">        it is necessary to replay the same sequence of random numbers for each</span>
<span class="sd">        pixel (see below).  The other method, ``SUBTRACTIVE_DITHER_2``, is</span>
<span class="sd">        exactly like the first except that before dithering any pixel with a</span>
<span class="sd">        floating point value of ``0.0`` is replaced with the special integer</span>
<span class="sd">        value ``-2147483647``.  When the image is uncompressed, pixels with</span>
<span class="sd">        this value are restored back to ``0.0`` exactly.  Finally, a value of</span>
<span class="sd">        ``NO_DITHER`` disables dithering entirely.</span>

<span class="sd">        As mentioned above, when using the subtractive dithering algorithm it</span>
<span class="sd">        is necessary to be able to generate a (pseudo-)random sequence of noise</span>
<span class="sd">        for each pixel, and replay that same sequence upon decompressing.  To</span>
<span class="sd">        facilitate this, a random seed between 1 and 10000 (inclusive) is used</span>
<span class="sd">        to seed a random number generator, and that seed is stored in the</span>
<span class="sd">        ``ZDITHER0`` keyword in the header of the compressed HDU.  In order to</span>
<span class="sd">        use that seed to generate the same sequence of random numbers the same</span>
<span class="sd">        random number generator must be used at compression and decompression</span>
<span class="sd">        time; for that reason the tiled image convention provides an</span>
<span class="sd">        implementation of a very simple pseudo-random number generator.  The</span>
<span class="sd">        seed itself can be provided in one of three ways, controllable by the</span>
<span class="sd">        ``dither_seed`` argument:  It may be specified manually, or it may be</span>
<span class="sd">        generated arbitrarily based on the system&#39;s clock</span>
<span class="sd">        (``DITHER_SEED_CLOCK``) or based on a checksum of the pixels in the</span>
<span class="sd">        image&#39;s first tile (``DITHER_SEED_CHECKSUM``).  The clock-based method</span>
<span class="sd">        is the default, and is sufficient to ensure that the value is</span>
<span class="sd">        reasonably &quot;arbitrary&quot; and that the same seed is unlikely to be</span>
<span class="sd">        generated sequentially.  The checksum method, on the other hand,</span>
<span class="sd">        ensures that the same seed is used every time for a specific image.</span>
<span class="sd">        This is particularly useful for software testing as it ensures that the</span>
<span class="sd">        same image will always use the same seed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">COMPRESSION_SUPPORTED</span><span class="p">:</span>
            <span class="c"># TODO: Raise a more specific Exception type</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;The astropy.io.fits.compression module is not &#39;</span>
                            <span class="s">&#39;available.  Creation of compressed image HDUs is &#39;</span>
                            <span class="s">&#39;disabled.&#39;</span><span class="p">)</span>

        <span class="n">compression_type</span> <span class="o">=</span> <span class="n">CMTYPE_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">compression_type</span><span class="p">,</span> <span class="n">compression_type</span><span class="p">)</span>

        <span class="c"># Handle deprecated keyword arguments</span>
        <span class="n">compression_opts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">oldarg</span><span class="p">,</span> <span class="n">newarg</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">DEPRECATED_KWARGS</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">oldarg</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Keyword argument </span><span class="si">%s</span><span class="s"> to </span><span class="si">%s</span><span class="s"> is pending &#39;</span>
                              <span class="s">&#39;deprecation; use </span><span class="si">%s</span><span class="s"> instead&#39;</span> <span class="o">%</span>
                              <span class="p">(</span><span class="n">oldarg</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">newarg</span><span class="p">),</span>
                              <span class="n">AstropyPendingDeprecationWarning</span><span class="p">)</span>
                <span class="n">compression_opts</span><span class="p">[</span><span class="n">newarg</span><span class="p">]</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">oldarg</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">oldarg</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compression_opts</span><span class="p">[</span><span class="n">newarg</span><span class="p">]</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">newarg</span><span class="p">]</span>
        <span class="c"># Include newer compression options that don&#39;t required backwards</span>
        <span class="c"># compatibility with deprecated spellings</span>
        <span class="n">compression_opts</span><span class="p">[</span><span class="s">&#39;quantize_method&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quantize_method</span>
        <span class="n">compression_opts</span><span class="p">[</span><span class="s">&#39;dither_seed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dither_seed</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="n">DELAYED</span><span class="p">:</span>
            <span class="c"># Reading the HDU from a file</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Create at least a skeleton HDU that matches the input</span>
            <span class="c"># header and data (if any were input)</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">)</span>

            <span class="c"># Store the input image data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>

            <span class="c"># Update the table header (_header) to the compressed</span>
            <span class="c"># image format and to match the input data (if any);</span>
            <span class="c"># Create the image header (_image_header) from the input</span>
            <span class="c"># image header (if any) and ensure it matches the input</span>
            <span class="c"># data; Create the initially empty table data array to</span>
            <span class="c"># hold the compressed data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_header_data</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">compression_opts</span><span class="p">)</span>

        <span class="c"># TODO: A lot of this should be passed on to an internal image HDU o</span>
        <span class="c"># something like that, see ticket #88</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_do_not_scale_image_data</span> <span class="o">=</span> <span class="n">do_not_scale_image_data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span> <span class="o">=</span> <span class="n">uint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scale_back</span> <span class="o">=</span> <span class="n">scale_back</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;ZNAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
                      <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;ZNAXIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))]</span>

        <span class="c"># store any scale factors from the table header</span>
        <span class="k">if</span> <span class="n">do_not_scale_image_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;BZERO&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">match_header</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">header</span><span class="p">):</span>
        <span class="n">card</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">card</span><span class="o">.</span><span class="n">keyword</span> <span class="o">!=</span> <span class="s">&#39;XTENSION&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="n">xtension</span> <span class="o">=</span> <span class="n">card</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xtension</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
            <span class="n">xtension</span> <span class="o">=</span> <span class="n">xtension</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">xtension</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&#39;BINTABLE&#39;</span><span class="p">,</span> <span class="s">&#39;A3DTABLE&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="s">&#39;ZIMAGE&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">header</span> <span class="ow">or</span> <span class="n">header</span><span class="p">[</span><span class="s">&#39;ZIMAGE&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">if</span> <span class="n">COMPRESSION_SUPPORTED</span> <span class="ow">and</span> <span class="n">COMPRESSION_ENABLED</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">COMPRESSION_SUPPORTED</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Failure matching header to a compressed image &#39;</span>
                          <span class="s">&#39;HDU: The compression module is not available.</span><span class="se">\n</span><span class="s">&#39;</span>
                          <span class="s">&#39;The HDU will be treated as a Binary Table HDU.&#39;</span><span class="p">,</span>
                          <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Compression is supported but disabled; just pass silently (#92)</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">_update_header_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_header</span><span class="p">,</span>
                            <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">compression_type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">tile_size</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">hcomp_scale</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">hcomp_smooth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">quantize_level</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">quantize_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                            <span class="n">dither_seed</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update the table header (`_header`) to the compressed</span>
<span class="sd">        image format and to match the input data (if any).  Create</span>
<span class="sd">        the image header (`_image_header`) from the input image</span>
<span class="sd">        header (if any) and ensure it matches the input</span>
<span class="sd">        data. Create the initially-empty table data array to hold</span>
<span class="sd">        the compressed data.</span>

<span class="sd">        This method is mainly called internally, but a user may wish to</span>
<span class="sd">        call this method after assigning new data to the `CompImageHDU`</span>
<span class="sd">        object that is of a different type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        image_header : Header instance</span>
<span class="sd">            header to be associated with the image</span>

<span class="sd">        name : str, optional</span>
<span class="sd">            the ``EXTNAME`` value; if this value is `None`, then the name from</span>
<span class="sd">            the input image header will be used; if there is no name in the</span>
<span class="sd">            input image header then the default name &#39;COMPRESSED_IMAGE&#39; is used</span>

<span class="sd">        compression_type : str, optional</span>
<span class="sd">            compression algorithm &#39;RICE_1&#39;, &#39;PLIO_1&#39;, &#39;GZIP_1&#39;, &#39;HCOMPRESS_1&#39;;</span>
<span class="sd">            if this value is `None`, use value already in the header; if no</span>
<span class="sd">            value already in the header, use &#39;RICE_1&#39;</span>

<span class="sd">        tile_size : sequence of int, optional</span>
<span class="sd">            compression tile sizes as a list; if this value is `None`, use</span>
<span class="sd">            value already in the header; if no value already in the header,</span>
<span class="sd">            treat each row of image as a tile</span>

<span class="sd">        hcomp_scale : float, optional</span>
<span class="sd">            HCOMPRESS scale parameter; if this value is `None`, use the value</span>
<span class="sd">            already in the header; if no value already in the header, use 1</span>

<span class="sd">        hcomp_smooth : float, optional</span>
<span class="sd">            HCOMPRESS smooth parameter; if this value is `None`, use the value</span>
<span class="sd">            already in the header; if no value already in the header, use 0</span>

<span class="sd">        quantize_level : float, optional</span>
<span class="sd">            floating point quantization level; if this value is `None`, use the</span>
<span class="sd">            value already in the header; if no value already in header, use 16</span>

<span class="sd">        quantize_method : int, optional</span>
<span class="sd">            floating point quantization dithering method; can be either</span>
<span class="sd">            NO_DITHER (-1), SUBTRACTIVE_DITHER_1 (1; default), or</span>
<span class="sd">            SUBTRACTIVE_DITHER_2 (2)</span>

<span class="sd">        dither_seed : int, optional</span>
<span class="sd">            random seed to use for dithering; can be either an integer in the</span>
<span class="sd">            range 1 to 1000 (inclusive), DITHER_SEED_CLOCK (0; default), or</span>
<span class="sd">            DITHER_SEED_CHECKSUM (-1)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">image_hdu</span> <span class="o">=</span> <span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span> <span class="o">=</span> <span class="n">CompImageHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_axes</span> <span class="o">=</span> <span class="n">image_hdu</span><span class="o">.</span><span class="n">_axes</span>
        <span class="k">del</span> <span class="n">image_hdu</span>

        <span class="c"># Determine based on the size of the input data whether to use the Q</span>
        <span class="c"># column format to store compressed data or the P format.</span>
        <span class="c"># The Q format is used only if the uncompressed data is larger than</span>
        <span class="c"># 4 GB.  This is not a perfect heuristic, as one can contrive an input</span>
        <span class="c"># array which, when compressed, the entire binary table representing</span>
        <span class="c"># the compressed data is larger than 4GB.  That said, this is the same</span>
        <span class="c"># heuristic used by CFITSIO, so this should give consistent results.</span>
        <span class="c"># And the cases where this heuristic is insufficient are extreme and</span>
        <span class="c"># almost entirely contrived corner cases, so it will do for now</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="n">huge_hdu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">nbytes</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">**</span> <span class="mi">32</span>

            <span class="k">if</span> <span class="n">huge_hdu</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">CFITSIO_SUPPORTS_Q_FORMAT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s">&quot;Astropy cannot compress images greater than 4 GB in size &quot;</span>
                    <span class="s">&quot;(</span><span class="si">%s</span><span class="s"> is </span><span class="si">%s</span><span class="s"> bytes) without CFITSIO &gt;= 3.35&quot;</span> <span class="o">%</span>
                    <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ver</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">nbytes</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">huge_hdu</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="c"># Update the extension name in the table header</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s">&#39;EXTNAME&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s">&#39;COMPRESSED_IMAGE&#39;</span>

        <span class="k">if</span> <span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
                             <span class="s">&#39;name of this binary table extension&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">]</span>

        <span class="c"># Set the compression type in the table header.</span>
        <span class="k">if</span> <span class="n">compression_type</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">compression_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;RICE_1&#39;</span><span class="p">,</span> <span class="s">&#39;GZIP_1&#39;</span><span class="p">,</span> <span class="s">&#39;PLIO_1&#39;</span><span class="p">,</span>
                                        <span class="s">&#39;HCOMPRESS_1&#39;</span><span class="p">]:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unknown compression type provided.  Default &#39;</span>
                              <span class="s">&#39;(</span><span class="si">%s</span><span class="s">) compression used.&#39;</span> <span class="o">%</span>
                              <span class="n">DEFAULT_COMPRESSION_TYPE</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
                <span class="n">compression_type</span> <span class="o">=</span> <span class="n">DEFAULT_COMPRESSION_TYPE</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZCMPTYPE&#39;</span><span class="p">,</span> <span class="n">compression_type</span><span class="p">,</span>
                             <span class="s">&#39;compression algorithm&#39;</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">compression_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;ZCMPTYPE&#39;</span><span class="p">,</span>
                                                <span class="n">DEFAULT_COMPRESSION_TYPE</span><span class="p">)</span>
            <span class="n">compression_type</span> <span class="o">=</span> <span class="n">CMTYPE_ALIASES</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">compression_type</span><span class="p">,</span>
                                                  <span class="n">compression_type</span><span class="p">)</span>

        <span class="c"># If the input image header had BSCALE/BZERO cards, then insert</span>
        <span class="c"># them in the table header.</span>

        <span class="k">if</span> <span class="n">image_header</span><span class="p">:</span>
            <span class="n">bzero</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;BZERO&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">bscale</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">after_keyword</span> <span class="o">=</span> <span class="s">&#39;EXTNAME&#39;</span>

            <span class="k">if</span> <span class="n">bscale</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="n">bscale</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after_keyword</span><span class="p">)</span>
                <span class="n">after_keyword</span> <span class="o">=</span> <span class="s">&#39;BSCALE&#39;</span>

            <span class="k">if</span> <span class="n">bzero</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BZERO&#39;</span><span class="p">,</span> <span class="n">bzero</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">after_keyword</span><span class="p">)</span>

            <span class="n">bitpix_comment</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span>
            <span class="n">naxis_comment</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bitpix_comment</span> <span class="o">=</span> <span class="s">&#39;data type of original image&#39;</span>
            <span class="n">naxis_comment</span> <span class="o">=</span> <span class="s">&#39;dimension of original image&#39;</span>

        <span class="c"># Set the label for the first column in the table</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TTYPE1&#39;</span><span class="p">,</span> <span class="s">&#39;COMPRESSED_DATA&#39;</span><span class="p">,</span> <span class="s">&#39;label for field 1&#39;</span><span class="p">,</span>
                         <span class="n">after</span><span class="o">=</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">)</span>

        <span class="c"># Set the data format for the first column.  It is dependent</span>
        <span class="c"># on the requested compression type.</span>

        <span class="k">if</span> <span class="n">compression_type</span> <span class="o">==</span> <span class="s">&#39;PLIO_1&#39;</span><span class="p">:</span>
            <span class="n">tform1</span> <span class="o">=</span> <span class="s">&#39;1QI&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PI&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tform1</span> <span class="o">=</span> <span class="s">&#39;1QB&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PB&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TFORM1&#39;</span><span class="p">,</span> <span class="n">tform1</span><span class="p">,</span>
                         <span class="s">&#39;data format of field: variable length array&#39;</span><span class="p">,</span>
                         <span class="n">after</span><span class="o">=</span><span class="s">&#39;TTYPE1&#39;</span><span class="p">)</span>

        <span class="c"># Create the first column for the table.  This column holds the</span>
        <span class="c"># compressed data.</span>
        <span class="n">col1</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TTYPE1&#39;</span><span class="p">],</span> <span class="n">format</span><span class="o">=</span><span class="n">tform1</span><span class="p">)</span>

        <span class="c"># Create the additional columns required for floating point</span>
        <span class="c"># data and calculate the width of the output table.</span>

        <span class="n">zbitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">zbitpix</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">quantize_level</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="c"># floating point image has &#39;COMPRESSED_DATA&#39;,</span>
            <span class="c"># &#39;UNCOMPRESSED_DATA&#39;, &#39;ZSCALE&#39;, and &#39;ZZERO&#39; columns (unless using</span>
            <span class="c"># lossless compression, per CFITSIO)</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="mi">4</span>

            <span class="c"># CFITSIO 3.28 and up automatically use the GZIP_COMPRESSED_DATA</span>
            <span class="c"># store floating point data that couldn&#39;t be quantized, instead</span>
            <span class="c"># of the UNCOMPRESSED_DATA column.  There&#39;s no way to control</span>
            <span class="c"># this behavior so the only way to determine which behavior will</span>
            <span class="c"># be employed is via the CFITSIO version</span>

            <span class="k">if</span> <span class="n">CFITSIO_SUPPORTS_GZIPDATA</span><span class="p">:</span>
                <span class="n">ttype2</span> <span class="o">=</span> <span class="s">&#39;GZIP_COMPRESSED_DATA&#39;</span>
                <span class="c"># The required format for the GZIP_COMPRESSED_DATA is actually</span>
                <span class="c"># missing from the standard docs, but CFITSIO suggests it</span>
                <span class="c"># should be 1PB, which is logical.</span>
                <span class="n">tform2</span> <span class="o">=</span> <span class="s">&#39;1QB&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PB&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># Q format is not supported for UNCOMPRESSED_DATA columns.</span>
                <span class="n">ttype2</span> <span class="o">=</span> <span class="s">&#39;UNCOMPRESSED_DATA&#39;</span>
                <span class="k">if</span> <span class="n">zbitpix</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                    <span class="n">tform2</span> <span class="o">=</span> <span class="s">&#39;1QB&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PB&#39;</span>
                <span class="k">elif</span> <span class="n">zbitpix</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                    <span class="n">tform2</span> <span class="o">=</span> <span class="s">&#39;1QI&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PI&#39;</span>
                <span class="k">elif</span> <span class="n">zbitpix</span> <span class="o">==</span> <span class="mi">32</span><span class="p">:</span>
                    <span class="n">tform2</span> <span class="o">=</span> <span class="s">&#39;1QJ&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PJ&#39;</span>
                <span class="k">elif</span> <span class="n">zbitpix</span> <span class="o">==</span> <span class="o">-</span><span class="mi">32</span><span class="p">:</span>
                    <span class="n">tform2</span> <span class="o">=</span> <span class="s">&#39;1QE&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PE&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tform2</span> <span class="o">=</span> <span class="s">&#39;1QD&#39;</span> <span class="k">if</span> <span class="n">huge_hdu</span> <span class="k">else</span> <span class="s">&#39;1PD&#39;</span>

            <span class="c"># Set up the second column for the table that will hold any</span>
            <span class="c"># uncompressable data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TTYPE2&#39;</span><span class="p">,</span> <span class="n">ttype2</span><span class="p">,</span> <span class="s">&#39;label for field 2&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TFORM1&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TFORM2&#39;</span><span class="p">,</span> <span class="n">tform2</span><span class="p">,</span>
                             <span class="s">&#39;data format of field: variable length array&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TTYPE2&#39;</span><span class="p">)</span>

            <span class="n">col2</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">ttype2</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="n">tform2</span><span class="p">)</span>

            <span class="c"># Set up the third column for the table that will hold</span>
            <span class="c"># the scale values for quantized data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TTYPE3&#39;</span><span class="p">,</span> <span class="s">&#39;ZSCALE&#39;</span><span class="p">,</span> <span class="s">&#39;label for field 3&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TFORM2&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TFORM3&#39;</span><span class="p">,</span> <span class="s">&#39;1D&#39;</span><span class="p">,</span>
                             <span class="s">&#39;data format of field: 8-byte DOUBLE&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TTYPE3&#39;</span><span class="p">)</span>
            <span class="n">col3</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TTYPE3&#39;</span><span class="p">],</span>
                          <span class="n">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFORM3&#39;</span><span class="p">])</span>

            <span class="c"># Set up the fourth column for the table that will hold</span>
            <span class="c"># the zero values for the quantized data.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TTYPE4&#39;</span><span class="p">,</span> <span class="s">&#39;ZZERO&#39;</span><span class="p">,</span> <span class="s">&#39;label for field 4&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TFORM3&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TFORM4&#39;</span><span class="p">,</span> <span class="s">&#39;1D&#39;</span><span class="p">,</span>
                             <span class="s">&#39;data format of field: 8-byte DOUBLE&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;TTYPE4&#39;</span><span class="p">)</span>
            <span class="n">after</span> <span class="o">=</span> <span class="s">&#39;TFORM4&#39;</span>
            <span class="n">col4</span> <span class="o">=</span> <span class="n">Column</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TTYPE4&#39;</span><span class="p">],</span>
                          <span class="n">format</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;TFORM4&#39;</span><span class="p">])</span>

            <span class="c"># Create the ColDefs object for the table</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">ColDefs</span><span class="p">([</span><span class="n">col1</span><span class="p">,</span> <span class="n">col2</span><span class="p">,</span> <span class="n">col3</span><span class="p">,</span> <span class="n">col4</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># default table has just one &#39;COMPRESSED_DATA&#39; column</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">after</span> <span class="o">=</span> <span class="s">&#39;TFORM1&#39;</span>

            <span class="c"># remove any header cards for the additional columns that</span>
            <span class="c"># may be left over from the previous data</span>
            <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;TTYPE2&#39;</span><span class="p">,</span> <span class="s">&#39;TFORM2&#39;</span><span class="p">,</span> <span class="s">&#39;TTYPE3&#39;</span><span class="p">,</span> <span class="s">&#39;TFORM3&#39;</span><span class="p">,</span> <span class="s">&#39;TTYPE4&#39;</span><span class="p">,</span>
                         <span class="s">&#39;TFORM4&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c"># Create the ColDefs object for the table</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">ColDefs</span><span class="p">([</span><span class="n">col1</span><span class="p">])</span>

        <span class="c"># Update the table header with the width of the table, the</span>
        <span class="c"># number of fields in the table, the indicator for a compressed</span>
        <span class="c"># image HDU, the data type of the image data and the number of</span>
        <span class="c"># dimensions in the image data array.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">,</span> <span class="n">cols</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">,</span>
                         <span class="s">&#39;width of table in bytes&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;TFIELDS&#39;</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="s">&#39;number of fields in each row&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZIMAGE&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="s">&#39;extension contains compressed image&#39;</span><span class="p">,</span>
                         <span class="n">after</span><span class="o">=</span><span class="n">after</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">,</span> <span class="n">zbitpix</span><span class="p">,</span>
                         <span class="n">bitpix_comment</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZIMAGE&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZNAXIS&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">],</span> <span class="n">naxis_comment</span><span class="p">,</span>
                         <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">)</span>

        <span class="c"># Strip the table header of all the ZNAZISn and ZTILEn keywords</span>
        <span class="c"># that may be left over from the previous data</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZNAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZTILE&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)]</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c"># Verify that any input tile size parameter is the appropriate</span>
        <span class="c"># size to match the HDU&#39;s data.</span>

        <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_size</span><span class="p">:</span>
            <span class="n">tile_size</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">naxis</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Provided tile size not appropriate for the data.  &#39;</span>
                          <span class="s">&#39;Default tile size will be used.&#39;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="n">tile_size</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c"># Set default tile dimensions for HCOMPRESS_1</span>

        <span class="k">if</span> <span class="n">compression_type</span> <span class="o">==</span> <span class="s">&#39;HCOMPRESS_1&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Hcompress minimum image dimension is &#39;</span>
                                 <span class="s">&#39;4 pixels&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">tile_size</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span> <span class="ow">or</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="c"># user specified tile size is too small</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Hcompress minimum tile dimension is &#39;</span>
                                     <span class="s">&#39;4 pixels&#39;</span><span class="p">)</span>
                <span class="n">major_dims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">ts</span> <span class="k">for</span> <span class="n">ts</span> <span class="ow">in</span> <span class="n">tile_size</span> <span class="k">if</span> <span class="n">ts</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">major_dims</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s">&#39;HCOMPRESS can only support 2-dimensional tile sizes.&#39;</span>
                        <span class="s">&#39;All but two of the tile_size dimensions must be set &#39;</span>
                        <span class="s">&#39;to 1.&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tile_size</span> <span class="ow">and</span> <span class="p">(</span><span class="n">tile_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c"># compress the whole image as a single tile</span>
                <span class="n">tile_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span>
                <span class="n">tile_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">naxis</span><span class="p">):</span>
                    <span class="c"># set all higher tile dimensions = 1</span>
                    <span class="n">tile_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">tile_size</span><span class="p">:</span>
                <span class="c"># The Hcompress algorithm is inherently 2D in nature, so the</span>
                <span class="c"># row by row tiling that is used for other compression</span>
                <span class="c"># algorithms is not appropriate.  If the image has less than 30</span>
                <span class="c"># rows, then the entire image will be compressed as a single</span>
                <span class="c"># tile.  Otherwise the tiles will consist of 16 rows of the</span>
                <span class="c"># image.  This keeps the tiles to a reasonable size, and it</span>
                <span class="c"># also includes enough rows to allow good compression</span>
                <span class="c"># efficiency.  It the last tile of the image happens to contain</span>
                <span class="c"># less than 4 rows, then find another tile size with between 14</span>
                <span class="c"># and 30 rows (preferably even), so that the last tile has at</span>
                <span class="c"># least 4 rows.</span>

                <span class="c"># 1st tile dimension is the row length of the image</span>
                <span class="n">tile_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">])</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">30</span><span class="p">:</span>
                    <span class="n">tile_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># look for another good tile dimension</span>
                    <span class="n">naxis2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">16</span><span class="p">,</span> <span class="mi">24</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">28</span><span class="p">,</span> <span class="mi">26</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="mi">18</span><span class="p">,</span> <span class="mi">14</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">naxis2</span> <span class="o">%</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">naxis2</span> <span class="o">%</span> <span class="n">dim</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
                            <span class="n">tile_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tile_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">naxis</span><span class="p">):</span>
                    <span class="c"># set all higher tile dimensions = 1</span>
                    <span class="n">tile_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="c"># check if requested tile size causes the last tile to have</span>
            <span class="c"># less than 4 pixels</span>

            <span class="n">remain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c"># 1st dimen</span>

            <span class="k">if</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">tile_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># try increasing tile size by 1</span>

                <span class="n">remain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Last tile along 1st dimension has &#39;</span>
                                     <span class="s">&#39;less than 4 pixels&#39;</span><span class="p">)</span>

            <span class="n">remain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>  <span class="c"># 2nd dimen</span>

            <span class="k">if</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">tile_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c"># try increasing tile size by 1</span>

                <span class="n">remain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">tile_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">remain</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">remain</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&#39;Last tile along 2nd dimension has &#39;</span>
                                     <span class="s">&#39;less than 4 pixels&#39;</span><span class="p">)</span>

        <span class="c"># Set up locations for writing the next cards in the header.</span>
        <span class="n">last_znaxis</span> <span class="o">=</span> <span class="s">&#39;ZNAXIS&#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">after1</span> <span class="o">=</span> <span class="s">&#39;ZNAXIS1&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">after1</span> <span class="o">=</span> <span class="s">&#39;ZNAXIS&#39;</span>

        <span class="c"># Calculate the number of rows in the output table and</span>
        <span class="c"># write the ZNAXISn and ZTILEn cards to the table header.</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="p">):</span>
            <span class="n">naxis</span> <span class="o">=</span> <span class="s">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">znaxis</span> <span class="o">=</span> <span class="s">&#39;ZNAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ztile</span> <span class="o">=</span> <span class="s">&#39;ZTILE&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tile_size</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">tile_size</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ts</span> <span class="o">=</span> <span class="n">tile_size</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ztile</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="c"># Default tile size</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">ts</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">ztile</span><span class="p">]</span>
                <span class="n">tile_size</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ts</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">nrows</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">ts</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nrows</span> <span class="o">*=</span> <span class="p">((</span><span class="n">axis</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">ts</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">image_header</span> <span class="ow">and</span> <span class="n">naxis</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">znaxis</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="n">naxis</span><span class="p">],</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">last_znaxis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">znaxis</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span>
                                 <span class="s">&#39;length of original image axis&#39;</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">last_znaxis</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">ztile</span><span class="p">,</span> <span class="n">ts</span><span class="p">,</span> <span class="s">&#39;size of tiles to be compressed&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="n">after1</span><span class="p">)</span>
            <span class="n">last_znaxis</span> <span class="o">=</span> <span class="n">znaxis</span>
            <span class="n">after1</span> <span class="o">=</span> <span class="n">ztile</span>

        <span class="c"># Set the NAXIS2 header card in the table hdu to the number of</span>
        <span class="c"># rows in the table.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">,</span> <span class="n">nrows</span><span class="p">,</span> <span class="s">&#39;number of rows in table&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">cols</span>

        <span class="c"># Set the compression parameters in the table header.</span>

        <span class="c"># First, setup the values to be used for the compression parameters</span>
        <span class="c"># in case none were passed in.  This will be either the value</span>
        <span class="c"># already in the table header for that parameter or the default</span>
        <span class="c"># value.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">zname</span> <span class="o">=</span> <span class="s">&#39;ZNAME&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">zname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">zval</span> <span class="o">=</span> <span class="s">&#39;ZVAL&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zname</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;NOISEBIT&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quantize_level</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">quantize_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zval</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zname</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;SCALE   &#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hcomp_scale</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">hcomp_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zval</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zname</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;SMOOTH  &#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">hcomp_smooth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">hcomp_smooth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zval</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">quantize_level</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">quantize_level</span> <span class="o">=</span> <span class="n">DEFAULT_QUANTIZE_LEVEL</span>

        <span class="k">if</span> <span class="n">hcomp_scale</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">hcomp_scale</span> <span class="o">=</span> <span class="n">DEFAULT_HCOMP_SCALE</span>

        <span class="k">if</span> <span class="n">hcomp_smooth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">hcomp_smooth</span> <span class="o">=</span> <span class="n">DEFAULT_HCOMP_SCALE</span>

        <span class="c"># Next, strip the table header of all the ZNAMEn and ZVALn keywords</span>
        <span class="c"># that may be left over from the previous data</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="n">zname</span> <span class="o">=</span> <span class="s">&#39;ZNAME&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">zname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">zval</span> <span class="o">=</span> <span class="s">&#39;ZVAL&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zname</span><span class="p">]</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">zval</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c"># Finally, put the appropriate keywords back based on the</span>
        <span class="c"># compression type.</span>

        <span class="n">after_keyword</span> <span class="o">=</span> <span class="s">&#39;ZCMPTYPE&#39;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">compression_type</span> <span class="o">==</span> <span class="s">&#39;RICE_1&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZNAME1&#39;</span><span class="p">,</span> <span class="s">&#39;BLOCKSIZE&#39;</span><span class="p">,</span> <span class="s">&#39;compression block size&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="n">after_keyword</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZVAL1&#39;</span><span class="p">,</span> <span class="n">DEFAULT_BLOCK_SIZE</span><span class="p">,</span> <span class="s">&#39;pixels per block&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZNAME1&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZNAME2&#39;</span><span class="p">,</span> <span class="s">&#39;BYTEPIX&#39;</span><span class="p">,</span>
                             <span class="s">&#39;bytes per pixel (1, 2, 4, or 8)&#39;</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZVAL1&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span><span class="p">:</span>
                <span class="n">bytepix</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">16</span><span class="p">:</span>
                <span class="n">bytepix</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bytepix</span> <span class="o">=</span> <span class="n">DEFAULT_BYTE_PIX</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZVAL2&#39;</span><span class="p">,</span> <span class="n">bytepix</span><span class="p">,</span>
                             <span class="s">&#39;bytes per pixel (1, 2, 4, or 8)&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZNAME2&#39;</span><span class="p">)</span>
            <span class="n">after_keyword</span> <span class="o">=</span> <span class="s">&#39;ZVAL2&#39;</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="n">compression_type</span> <span class="o">==</span> <span class="s">&#39;HCOMPRESS_1&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZNAME1&#39;</span><span class="p">,</span> <span class="s">&#39;SCALE&#39;</span><span class="p">,</span> <span class="s">&#39;HCOMPRESS scale factor&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="n">after_keyword</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZVAL1&#39;</span><span class="p">,</span> <span class="n">hcomp_scale</span><span class="p">,</span> <span class="s">&#39;HCOMPRESS scale factor&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZNAME1&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZNAME2&#39;</span><span class="p">,</span> <span class="s">&#39;SMOOTH&#39;</span><span class="p">,</span> <span class="s">&#39;HCOMPRESS smooth option&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZVAL1&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZVAL2&#39;</span><span class="p">,</span> <span class="n">hcomp_smooth</span><span class="p">,</span> <span class="s">&#39;HCOMPRESS smooth option&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZNAME2&#39;</span><span class="p">)</span>
            <span class="n">after_keyword</span> <span class="o">=</span> <span class="s">&#39;ZVAL2&#39;</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>   <span class="c"># floating point image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZNAME&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="s">&#39;NOISEBIT&#39;</span><span class="p">,</span>
                             <span class="s">&#39;floating point quantization level&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="n">after_keyword</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZVAL&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">quantize_level</span><span class="p">,</span>
                             <span class="s">&#39;floating point quantization level&#39;</span><span class="p">,</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZNAME&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>

            <span class="c"># Add the dither method and seed</span>
            <span class="k">if</span> <span class="n">quantize_method</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">quantize_method</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">NO_DITHER</span><span class="p">,</span> <span class="n">SUBTRACTIVE_DITHER_1</span><span class="p">,</span>
                                           <span class="n">SUBTRACTIVE_DITHER_2</span><span class="p">]:</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">QUANTIZE_METHOD_NAMES</span><span class="p">[</span><span class="n">DEFAULT_QUANTIZE_METHOD</span><span class="p">]</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&#39;Unknown quantization method provided.  &#39;</span>
                                  <span class="s">&#39;Default method (</span><span class="si">%s</span><span class="s">) used.&#39;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">quantize_method</span> <span class="o">=</span> <span class="n">DEFAULT_QUANTIZE_METHOD</span>

                <span class="k">if</span> <span class="n">quantize_method</span> <span class="o">==</span> <span class="n">NO_DITHER</span><span class="p">:</span>
                    <span class="n">zquantiz_comment</span> <span class="o">=</span> <span class="s">&#39;No dithering during quantization&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">zquantiz_comment</span> <span class="o">=</span> <span class="s">&#39;Pixel Quantization Algorithm&#39;</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZQUANTIZ&#39;</span><span class="p">,</span>
                                 <span class="n">QUANTIZE_METHOD_NAMES</span><span class="p">[</span><span class="n">quantize_method</span><span class="p">],</span>
                                 <span class="n">zquantiz_comment</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZVAL&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c"># If the ZQUANTIZ keyword is missing the default is to assume</span>
                <span class="c"># no dithering, rather than whatever DEFAULT_QUANTIZE_METHOD</span>
                <span class="c"># is set to</span>
                <span class="n">quantize_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;ZQUANTIZ&#39;</span><span class="p">,</span> <span class="n">NO_DITHER</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">quantize_method</span><span class="p">,</span> <span class="n">string_types</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">iteritems</span><span class="p">(</span><span class="n">QUANTIZE_METHOD_NAMES</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">v</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">quantize_method</span><span class="p">:</span>
                            <span class="n">quantize_method</span> <span class="o">=</span> <span class="n">k</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">quantize_method</span> <span class="o">=</span> <span class="n">NO_DITHER</span>

            <span class="k">if</span> <span class="n">quantize_method</span> <span class="o">==</span> <span class="n">NO_DITHER</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&#39;ZDITHER0&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="c"># If dithering isn&#39;t being used then there&#39;s no reason to</span>
                    <span class="c"># keep the ZDITHER0 keyword</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZDITHER0&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dither_seed</span><span class="p">:</span>
                    <span class="n">dither_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_dither_seed</span><span class="p">(</span><span class="n">dither_seed</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s">&#39;ZDITHER0&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="n">dither_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZDITHER0&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dither_seed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_dither_seed</span><span class="p">(</span>
                            <span class="n">DEFAULT_DITHER_SEED</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZDITHER0&#39;</span><span class="p">,</span> <span class="n">dither_seed</span><span class="p">,</span>
                                 <span class="s">&#39;dithering offset when quantizing floats&#39;</span><span class="p">,</span>
                                 <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZQUANTIZ&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">image_header</span><span class="p">:</span>
            <span class="c"># Move SIMPLE card from the image header to the</span>
            <span class="c"># table header as ZSIMPLE card.</span>

            <span class="k">if</span> <span class="s">&#39;SIMPLE&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZSIMPLE&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">],</span>
                                 <span class="n">before</span><span class="o">=</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">)</span>

            <span class="c"># Move EXTEND card from the image header to the</span>
            <span class="c"># table header as ZEXTEND card.</span>

            <span class="k">if</span> <span class="s">&#39;EXTEND&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZEXTEND&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;EXTEND&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;EXTEND&#39;</span><span class="p">])</span>

            <span class="c"># Move BLOCKED card from the image header to the</span>
            <span class="c"># table header as ZBLOCKED card.</span>

            <span class="k">if</span> <span class="s">&#39;BLOCKED&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZBLOCKED&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;BLOCKED&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;BLOCKED&#39;</span><span class="p">])</span>

            <span class="c"># Move XTENSION card from the image header to the</span>
            <span class="c"># table header as ZTENSION card.</span>

            <span class="c"># Since we only handle compressed IMAGEs, ZTENSION should</span>
            <span class="c"># always be IMAGE, even if the caller has passed in a header</span>
            <span class="c"># for some other type of extension.</span>
            <span class="k">if</span> <span class="s">&#39;XTENSION&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;IMAGE&#39;</span><span class="p">,</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;XTENSION&#39;</span><span class="p">],</span>
                                 <span class="n">before</span><span class="o">=</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">)</span>

            <span class="c"># Move PCOUNT and GCOUNT cards from image header to the table</span>
            <span class="c"># header as ZPCOUNT and ZGCOUNT cards.</span>

            <span class="k">if</span> <span class="s">&#39;PCOUNT&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZPCOUNT&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">],</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">last_znaxis</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;GCOUNT&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZGCOUNT&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">],</span>
                                 <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZPCOUNT&#39;</span><span class="p">)</span>

            <span class="c"># Move CHECKSUM and DATASUM cards from the image header to the</span>
            <span class="c"># table header as XHECKSUM and XDATASUM cards.</span>

            <span class="k">if</span> <span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZHECKSUM&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">])</span>

            <span class="k">if</span> <span class="s">&#39;DATASUM&#39;</span> <span class="ow">in</span> <span class="n">image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZDATASUM&#39;</span><span class="p">,</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">],</span>
                                 <span class="n">image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Move XTENSION card from the image header to the</span>
            <span class="c"># table header as ZTENSION card.</span>

            <span class="c"># Since we only handle compressed IMAGEs, ZTENSION should</span>
            <span class="c"># always be IMAGE, even if the caller has passed in a header</span>
            <span class="c"># for some other type of extension.</span>
            <span class="k">if</span> <span class="s">&#39;XTENSION&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;IMAGE&#39;</span><span class="p">,</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;XTENSION&#39;</span><span class="p">],</span>
                                 <span class="n">before</span><span class="o">=</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">)</span>

            <span class="c"># Move PCOUNT and GCOUNT cards from image header to the table</span>
            <span class="c"># header as ZPCOUNT and ZGCOUNT cards.</span>

            <span class="k">if</span> <span class="s">&#39;PCOUNT&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZPCOUNT&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">],</span>
                                 <span class="n">after</span><span class="o">=</span><span class="n">last_znaxis</span><span class="p">)</span>

            <span class="k">if</span> <span class="s">&#39;GCOUNT&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;ZGCOUNT&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="p">[</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">],</span>
                                 <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">],</span>
                                 <span class="n">after</span><span class="o">=</span><span class="s">&#39;ZPCOUNT&#39;</span><span class="p">)</span>

        <span class="c"># When we have an image checksum we need to ensure that the same</span>
        <span class="c"># number of blank cards exist in the table header as there were in</span>
        <span class="c"># the image header.  This allows those blank cards to be carried</span>
        <span class="c"># over to the image header when the hdu is uncompressed.</span>

        <span class="k">if</span> <span class="s">&#39;ZHECKSUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">required_blanks</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">()</span>
            <span class="n">image_blanks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">()</span>
            <span class="n">table_blanks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">required_blanks</span> <span class="o">-</span> <span class="n">image_blanks</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
                <span class="n">table_blanks</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">required_blanks</span> <span class="o">-</span> <span class="n">table_blanks</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;(refactor your code)&#39;</span><span class="p">,</span> <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<div class="viewcode-block" id="CompImageHDU.updateHeaderData"><a class="viewcode-back" href="../../../../../io/fits/api/images.html#astropy.io.fits.CompImageHDU.updateHeaderData">[docs]</a>    <span class="k">def</span> <span class="nf">updateHeaderData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">image_header</span><span class="p">,</span>
                         <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">compressionType</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">tileSize</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">hcompScale</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">hcompSmooth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                         <span class="n">quantizeLevel</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_header_data</span><span class="p">(</span><span class="n">image_header</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">compression_type</span><span class="o">=</span><span class="n">compressionType</span><span class="p">,</span>
                                 <span class="n">tile_size</span><span class="o">=</span><span class="n">tileSize</span><span class="p">,</span>
                                 <span class="n">hcomp_scale</span><span class="o">=</span><span class="n">hcompScale</span><span class="p">,</span>
                                 <span class="n">hcomp_smooth</span><span class="o">=</span><span class="n">hcompSmooth</span><span class="p">,</span>
                                 <span class="n">quantize_level</span><span class="o">=</span><span class="n">quantizeLevel</span><span class="p">)</span></div>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># The data attribute is the image data (not the table data).</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">compression</span><span class="o">.</span><span class="n">decompress_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data</span>

        <span class="c"># Scale the data if necessary</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_bzero</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bscale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">new_dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_for_bitpix</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">new_dtype</span><span class="p">)</span>

            <span class="n">zblank</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">if</span> <span class="s">&#39;ZBLANK&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">zblank</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span><span class="p">[</span><span class="s">&#39;ZBLANK&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="s">&#39;ZBLANK&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="n">zblank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZBLANK&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s">&#39;BLANK&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                    <span class="n">zblank</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;BLANK&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;int32&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">zblank</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">blanks</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">==</span> <span class="n">zblank</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span>

            <span class="k">if</span> <span class="n">zblank</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">blanks</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

        <span class="c"># Right out of _ImageBaseHDU.data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_header_scale_info</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data</span>

    <span class="nd">@data.setter</span>
    <span class="k">def</span> <span class="nf">data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span>
                <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&#39;CompImageHDU data has incorrect type:</span><span class="si">%s</span><span class="s">; &#39;</span>
                            <span class="s">&#39;dtype.fields = </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span>
                            <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">compressed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># First we will get the table data (the compressed</span>
        <span class="c"># data) from the file, if there is any.</span>
        <span class="n">compressed_data</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">BinTableHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">compressed_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">):</span>
            <span class="c"># Make sure not to use &#39;del self.data&#39; so we don&#39;t accidentally</span>
            <span class="c"># go through the self.data.fdel and close the mmap underlying</span>
            <span class="c"># the compressed_data array</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">compressed_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># This will actually set self.compressed_data with the</span>
            <span class="c"># pre-allocated space for the compression data; this is something I</span>
            <span class="c"># might do away with in the future</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_compressed_data</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span>

    <span class="nd">@compressed_data.deleter</span>
    <span class="k">def</span> <span class="nf">compressed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Deleting the compressed_data attribute has to be handled</span>
        <span class="c"># with a little care to prevent a reference leak</span>
        <span class="c"># First delete the ._coldefs attributes under it to break a possible</span>
        <span class="c"># reference cycle</span>
        <span class="k">if</span> <span class="s">&#39;compressed_data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;compressed_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">_coldefs</span>

            <span class="c"># Now go ahead and delete from self.__dict__; normally</span>
            <span class="c"># lazyproperty.__delete__ does this for us, but we can prempt it to</span>
            <span class="c"># do some additional cleanup</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;compressed_data&#39;</span><span class="p">]</span>

            <span class="c"># If this file was mmap&#39;d, numpy.memmap will hold open a file</span>
            <span class="c"># handle until the underlying mmap object is garbage-collected;</span>
            <span class="c"># since this reference leak can sometimes hang around longer than</span>
            <span class="c"># welcome go ahead and force a garbage collection</span>
            <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

    <span class="nd">@lazyproperty</span>
    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;the ``compressed_data`` attribute&#39;</span><span class="p">,</span>
                <span class="n">pending</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">compData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the image array--should be equivalent to ``self.data.shape``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Determine from the values read from the header</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_axes</span><span class="p">))</span>

    <span class="nd">@lazyproperty</span>
    <span class="k">def</span> <span class="nf">header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># The header attribute is the header for the image data.  It</span>
        <span class="c"># is not actually stored in the object dictionary.  Instead,</span>
        <span class="c"># the _image_header is stored.  If the _image_header attribute</span>
        <span class="c"># has already been defined we just return it.  If not, we must</span>
        <span class="c"># create it from the table header (the _header attribute).</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_image_header&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span>

        <span class="c"># Start with a copy of the table header.</span>
        <span class="n">image_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c"># Delete cards that are related to the table.  And move</span>
        <span class="c"># the values of those cards that relate to the image from</span>
        <span class="c"># their corresponding table cards.  These include</span>
        <span class="c"># ZBITPIX -&gt; BITPIX, ZNAXIS -&gt; NAXIS, and ZNAXISn -&gt; NAXISn.</span>
        <span class="c"># (Note: Used set here instead of list in case there are any duplicate</span>
        <span class="c"># keywords, which there may be in some pathological cases:</span>
        <span class="c"># https://github.com/astropy/astropy/issues/2750</span>
        <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">(</span><span class="n">image_header</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">CompImageHeader</span><span class="o">.</span><span class="n">_is_reserved_keyword</span><span class="p">(</span><span class="n">keyword</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
                <span class="k">del</span> <span class="n">image_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

        <span class="k">if</span> <span class="s">&#39;ZSIMPLE&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;SIMPLE&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZSIMPLE&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZSIMPLE&#39;</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s">&#39;ZTENSION&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZTENSION&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&#39;IMAGE&#39;</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;ZTENSION keyword in compressed &quot;</span>
                              <span class="s">&quot;extension != &#39;IMAGE&#39;&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;XTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;IMAGE&#39;</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZTENSION&#39;</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;XTENSION&#39;</span><span class="p">,</span> <span class="s">&#39;IMAGE&#39;</span><span class="p">,</span> <span class="n">before</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>


        <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BITPIX&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">],</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZBITPIX&#39;</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;NAXIS&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZNAXIS&#39;</span><span class="p">],</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZNAXIS&#39;</span><span class="p">],</span> <span class="n">before</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">last_naxis</span> <span class="o">=</span> <span class="s">&#39;NAXIS&#39;</span>
        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">image_header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]):</span>
            <span class="n">znaxis</span> <span class="o">=</span> <span class="s">&#39;ZNAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">naxis</span> <span class="o">=</span> <span class="n">znaxis</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">naxis</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="n">znaxis</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="n">znaxis</span><span class="p">],</span>
                             <span class="n">after</span><span class="o">=</span><span class="n">last_naxis</span><span class="p">)</span>
            <span class="n">last_naxis</span> <span class="o">=</span> <span class="n">naxis</span>

        <span class="c"># Delete any other spurious NAXISn keywords:</span>
        <span class="n">naxis</span> <span class="o">=</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">image_header</span><span class="p">[</span><span class="s">&#39;NAXIS?*&#39;</span><span class="p">]):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="mi">5</span><span class="p">:])</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">naxis</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">image_header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>

        <span class="c"># Although PCOUNT and GCOUNT are considered mandatory for IMAGE HDUs,</span>
        <span class="c"># ZPCOUNT and ZGCOUNT are optional, probably because for IMAGE HDUs</span>
        <span class="c"># their values are always 0 and 1 respectively</span>
        <span class="k">if</span> <span class="s">&#39;ZPCOUNT&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZPCOUNT&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZPCOUNT&#39;</span><span class="p">],</span>
                             <span class="n">after</span><span class="o">=</span><span class="n">last_naxis</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="n">last_naxis</span><span class="p">)</span>

        <span class="k">if</span> <span class="s">&#39;ZGCOUNT&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZGCOUNT&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZGCOUNT&#39;</span><span class="p">],</span>
                             <span class="n">after</span><span class="o">=</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;GCOUNT&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">after</span><span class="o">=</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s">&#39;ZEXTEND&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;EXTEND&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZEXTEND&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZEXTEND&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s">&#39;ZBLOCKED&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;BLOCKED&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZBLOCKED&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZBLOCKED&#39;</span><span class="p">])</span>

        <span class="c"># Move the ZHECKSUM and ZDATASUM cards to the image header</span>
        <span class="c"># as CHECKSUM and DATASUM</span>
        <span class="k">if</span> <span class="s">&#39;ZHECKSUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZHECKSUM&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZHECKSUM&#39;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s">&#39;ZDATASUM&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;DATASUM&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZDATASUM&#39;</span><span class="p">],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;ZDATASUM&#39;</span><span class="p">])</span>

        <span class="c"># Remove the EXTNAME card if the value in the table header</span>
        <span class="c"># is the default value of COMPRESSED_IMAGE.</span>
        <span class="k">if</span> <span class="p">(</span><span class="s">&#39;EXTNAME&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;COMPRESSED_IMAGE&#39;</span><span class="p">):</span>
            <span class="k">del</span> <span class="n">image_header</span><span class="p">[</span><span class="s">&#39;EXTNAME&#39;</span><span class="p">]</span>

        <span class="c"># Look to see if there are any blank cards in the table</span>
        <span class="c"># header.  If there are, there should be the same number</span>
        <span class="c"># of blank cards in the image header.  Add blank cards to</span>
        <span class="c"># the image header to make it so.</span>
        <span class="n">table_blanks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">()</span>
        <span class="n">image_blanks</span> <span class="o">=</span> <span class="n">image_header</span><span class="o">.</span><span class="n">_countblanks</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">table_blanks</span> <span class="o">-</span> <span class="n">image_blanks</span><span class="p">):</span>
            <span class="n">image_header</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>

        <span class="c"># Create the CompImageHeader that syncs with the table header, and save</span>
        <span class="c"># it off to self._image_header so it can be referenced later</span>
        <span class="c"># unambiguously</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span> <span class="o">=</span> <span class="n">CompImageHeader</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">,</span> <span class="n">image_header</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span>

    <span class="k">def</span> <span class="nf">_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Summarize the HDU: name, dimensions, and formats.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">class_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="o">.</span><span class="n">__name__</span>

        <span class="c"># if data is touched, use data info.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">_shape</span><span class="p">,</span> <span class="n">_format</span> <span class="o">=</span> <span class="p">(),</span> <span class="s">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c"># the shape will be in the order of NAXIS&#39;s which is the</span>
                <span class="c"># reverse of the numarray shape</span>
                <span class="n">_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">_format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span>
                <span class="n">_shape</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_shape</span><span class="p">)</span>
                <span class="n">_format</span> <span class="o">=</span> <span class="n">_format</span><span class="p">[</span><span class="n">_format</span><span class="o">.</span><span class="n">rfind</span><span class="p">(</span><span class="s">&#39;.&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>

        <span class="c"># if data is not touched yet, use header info.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_shape</span> <span class="o">=</span> <span class="p">()</span>

            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span><span class="p">]):</span>
                <span class="n">_shape</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;NAXIS&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)],)</span>

            <span class="n">_format</span> <span class="o">=</span> <span class="n">BITPIX2DTYPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]]</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">class_name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">),</span> <span class="n">_shape</span><span class="p">,</span>
                <span class="n">_format</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_compressed_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compress the image data so that it may be written to a file.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c"># Check to see that the image_header matches the image data</span>
        <span class="n">image_bitpix</span> <span class="o">=</span> <span class="n">DTYPE2BITPIX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">image_bitpix</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bitpix</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_header_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c"># TODO: This is copied right out of _ImageBaseHDU._writedata_internal;</span>
        <span class="c"># it would be cool if we could use an internal ImageHDU and use that to</span>
        <span class="c"># write to a buffer for compression or something. See ticket #88</span>
        <span class="c"># deal with unsigned integer 16, 32 and 64 data</span>
        <span class="n">old_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="k">if</span> <span class="n">_is_pseudo_unsigned</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="c"># Convert the unsigned array to signed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">-</span> <span class="n">_unsigned_zero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="s">&#39;=i</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="n">should_swap</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">should_swap</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">isnative</span>

        <span class="k">if</span> <span class="n">should_swap</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS2&#39;</span><span class="p">]</span>
            <span class="n">tbsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;NAXIS1&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">nrows</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;PCOUNT&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="s">&#39;THEAP&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;THEAP&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span> <span class="o">=</span> <span class="n">tbsize</span>

            <span class="c"># First delete the original compressed data, if it exists</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span>


            <span class="c"># Compress the data.</span>
            <span class="c"># The current implementation of compress_hdu assumes the empty</span>
            <span class="c"># compressed data table has already been initialized in</span>
            <span class="c"># self.compressed_data, and writes directly to it</span>
            <span class="c"># compress_hdu returns the size of the heap for the written</span>
            <span class="c"># compressed image table</span>
            <span class="n">heapsize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span> <span class="o">=</span> <span class="n">compression</span><span class="o">.</span><span class="n">compress_hdu</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># if data was byteswapped return it to its original order</span>
            <span class="k">if</span> <span class="n">should_swap</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">byteswap</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">old_data</span>

        <span class="c"># CFITSIO will write the compressed data in big-endian order</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s">&#39;&gt;&#39;</span><span class="p">)</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span>
        <span class="n">compressed_data</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">_theap</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span>
                                                 <span class="nb">type</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">rec</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span> <span class="o">=</span> <span class="n">compressed_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">FITS_rec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span><span class="o">.</span><span class="n">_coldefs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span><span class="o">.</span><span class="n">_heapoffset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_theap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span><span class="o">.</span><span class="n">_heapsize</span> <span class="o">=</span> <span class="n">heapsize</span>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span> <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;(refactor your code)&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="CompImageHDU.updateCompressedData"><a class="viewcode-back" href="../../../../../io/fits/api/images.html#astropy.io.fits.CompImageHDU.updateCompressedData">[docs]</a>    <span class="k">def</span> <span class="nf">updateCompressedData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_compressed_data</span><span class="p">()</span></div>

    <span class="nd">@deprecated</span><span class="p">(</span><span class="s">&#39;0.3&#39;</span><span class="p">,</span>
                <span class="n">alternative</span><span class="o">=</span><span class="s">&#39;(refactor your code; this function no &#39;</span>
                            <span class="s">&#39;longer does anything)&#39;</span><span class="p">)</span>
<div class="viewcode-block" id="CompImageHDU.updateHeader"><a class="viewcode-back" href="../../../../../io/fits/api/images.html#astropy.io.fits.CompImageHDU.updateHeader">[docs]</a>    <span class="k">def</span> <span class="nf">updateHeader</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="CompImageHDU.scale"><a class="viewcode-back" href="../../../../../io/fits/api/images.html#astropy.io.fits.CompImageHDU.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="s">&#39;old&#39;</span><span class="p">,</span> <span class="n">bscale</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">bzero</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Scale image data by using ``BSCALE`` and ``BZERO``.</span>

<span class="sd">        Calling this method will scale ``self.data`` and update the keywords of</span>
<span class="sd">        ``BSCALE`` and ``BZERO`` in ``self._header`` and ``self._image_header``.</span>
<span class="sd">        This method should only be used right before writing to the output</span>
<span class="sd">        file, as the data will be scaled and is therefore not very usable after</span>
<span class="sd">        the call.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        type : str, optional</span>
<span class="sd">            destination data type, use a string representing a numpy dtype</span>
<span class="sd">            name, (e.g. ``&#39;uint8&#39;``, ``&#39;int16&#39;``, ``&#39;float32&#39;`` etc.).  If is</span>
<span class="sd">            `None`, use the current data type.</span>

<span class="sd">        option : str, optional</span>
<span class="sd">            how to scale the data: if ``&quot;old&quot;``, use the original ``BSCALE``</span>
<span class="sd">            and ``BZERO`` values when the data was read/created. If</span>
<span class="sd">            ``&quot;minmax&quot;``, use the minimum and maximum of the data to scale.</span>
<span class="sd">            The option will be overwritten by any user-specified bscale/bzero</span>
<span class="sd">            values.</span>

<span class="sd">        bscale, bzero : int, optional</span>
<span class="sd">            user specified ``BSCALE`` and ``BZERO`` values.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c"># Determine the destination (numpy) data type</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="nb">type</span> <span class="o">=</span> <span class="n">BITPIX2DTYPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span><span class="p">]</span>
        <span class="n">_type</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

        <span class="c"># Determine how to scale the data</span>
        <span class="c"># bscale and bzero takes priority</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bscale</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">bzero</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">_scale</span> <span class="o">=</span> <span class="n">bscale</span>
            <span class="n">_zero</span> <span class="o">=</span> <span class="n">bzero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">option</span> <span class="o">==</span> <span class="s">&#39;old&#39;</span><span class="p">:</span>
                <span class="n">_scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bscale</span>
                <span class="n">_zero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bzero</span>
            <span class="k">elif</span> <span class="n">option</span> <span class="o">==</span> <span class="s">&#39;minmax&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                    <span class="n">_scale</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">_zero</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>
                    <span class="n">_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">flat</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">_type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>  <span class="c"># uint8 case</span>
                        <span class="n">_zero</span> <span class="o">=</span> <span class="n">_min</span>
                        <span class="n">_scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">_max</span> <span class="o">-</span> <span class="n">_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">**</span> <span class="mi">8</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_zero</span> <span class="o">=</span> <span class="p">(</span><span class="n">_max</span> <span class="o">+</span> <span class="n">_min</span><span class="p">)</span> <span class="o">/</span> <span class="mf">2.</span>

                        <span class="c"># throw away -2^N</span>
                        <span class="n">_scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">_max</span> <span class="o">-</span> <span class="n">_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">**</span> <span class="p">(</span><span class="mi">8</span> <span class="o">*</span> <span class="n">_type</span><span class="o">.</span><span class="n">bytes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c"># Do the scaling</span>
        <span class="k">if</span> <span class="n">_zero</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">+=</span> <span class="o">-</span><span class="n">_zero</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;BZERO&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_zero</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Delete from both headers</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">header</span><span class="p">[</span><span class="s">&#39;BZERO&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">_scale</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">/=</span> <span class="n">_scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;BSCALE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_scale</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">):</span>
                <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                    <span class="k">del</span> <span class="n">header</span><span class="p">[</span><span class="s">&#39;BSCALE&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">around</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">_type</span><span class="p">)</span>  <span class="c"># 0.7.7.1</span>

        <span class="c"># Update the BITPIX Card to match the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span> <span class="o">=</span> <span class="n">DTYPE2BITPIX</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;BZERO&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c"># Update BITPIX for the image header specifically</span>
        <span class="c"># TODO: Make this more clear by using self._image_header, but only once</span>
        <span class="c"># this has been fixed so that the _image_header attribute is guaranteed</span>
        <span class="c"># to be valid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span>

        <span class="c"># Update the table header to match the scaled data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_header_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>

        <span class="c"># Since the image has been manually scaled, the current</span>
        <span class="c"># bitpix/bzero/bscale now serve as the &#39;original&#39; scaling of the image,</span>
        <span class="c"># as though the original image has been completely replaced</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bzero</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bscale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span></div>

    <span class="k">def</span> <span class="nf">_prewriteto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checksum</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scale_back</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">BITPIX2DTYPE</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_bitpix</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_has_data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_compressed_data</span><span class="p">()</span>

            <span class="c"># Use methods in the superclass to update the header with</span>
            <span class="c"># scale/checksum keywords based on the data type of the image data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_update_uint_scale_keywords</span><span class="p">()</span>

            <span class="c"># Shove the image header and data into a new ImageHDU and use that</span>
            <span class="c"># to compute the image checksum</span>
            <span class="n">image_hdu</span> <span class="o">=</span> <span class="n">ImageHDU</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">)</span>
            <span class="n">image_hdu</span><span class="o">.</span><span class="n">_update_checksum</span><span class="p">(</span><span class="n">checksum</span><span class="p">)</span>
            <span class="k">if</span> <span class="s">&#39;CHECKSUM&#39;</span> <span class="ow">in</span> <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="c"># This will also pass through to the ZHECKSUM keyword and</span>
                <span class="c"># ZDATASUM keyword</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">,</span>
                                       <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">],</span>
                                       <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;CHECKSUM&#39;</span><span class="p">])</span>
            <span class="k">if</span> <span class="s">&#39;DATASUM&#39;</span> <span class="ow">in</span> <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_image_header</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s">&#39;DATASUM&#39;</span><span class="p">,</span> <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">],</span>
                                       <span class="n">image_hdu</span><span class="o">.</span><span class="n">header</span><span class="o">.</span><span class="n">comments</span><span class="p">[</span><span class="s">&#39;DATASUM&#39;</span><span class="p">])</span>
            <span class="c"># Store a temporary backup of self.data in a different attribute;</span>
            <span class="c"># see below</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_imagedata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

            <span class="c"># Now we need to perform an ugly hack to set the compressed data as</span>
            <span class="c"># the .data attribute on the HDU so that the call to _writedata</span>
            <span class="c"># handles it properly</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_prewriteto</span><span class="p">(</span><span class="n">checksum</span><span class="o">=</span><span class="n">checksum</span><span class="p">,</span>
                                                     <span class="n">inplace</span><span class="o">=</span><span class="n">inplace</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writeheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Bypasses `BinTableHDU._writeheader()` which updates the header with</span>
<span class="sd">        metadata about the data that is meaningless here; another reason</span>
<span class="sd">        why this class maybe shouldn&#39;t inherit directly from BinTableHDU...</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">ExtensionHDU</span><span class="o">.</span><span class="n">_writeheader</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_writedata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileobj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrap the basic ``_writedata`` method to restore the ``.data``</span>
<span class="sd">        attribute to the uncompressed image data in the case of an exception.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_writedata</span><span class="p">(</span><span class="n">fileobj</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="c"># Restore the .data attribute to its rightful value (if any)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s">&#39;_imagedata&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="s">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagedata</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_imagedata</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>

    <span class="k">def</span> <span class="nf">_close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CompImageHDU</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_close</span><span class="p">(</span><span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">)</span>

        <span class="c"># Also make sure to close access to the compressed data mmaps</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">closed</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data_loaded</span> <span class="ow">and</span>
                <span class="n">_get_array_mmap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">compressed_data</span>
            <span class="c"># Close off the deprected compData attribute as well if it has been</span>
            <span class="c"># used</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">compData</span>

    <span class="c"># TODO: This was copied right out of _ImageBaseHDU; get rid of it once we</span>
    <span class="c"># find a way to rewrite this class as either a subclass or wrapper for an</span>
    <span class="c"># ImageHDU</span>
    <span class="k">def</span> <span class="nf">_dtype_for_bitpix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine the dtype that the data should be converted to depending on</span>
<span class="sd">        the BITPIX value in the header, and possibly on the BSCALE value as</span>
<span class="sd">        well.  Returns None if there should not be any change.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bitpix</span>
        <span class="c"># Handle possible conversion to uints if enabled</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uint</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bscale</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bits</span><span class="p">,</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">((</span><span class="mi">16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint16&#39;</span><span class="p">)),</span>
                                <span class="p">(</span><span class="mi">32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint32&#39;</span><span class="p">)),</span>
                                <span class="p">(</span><span class="mi">64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;uint64&#39;</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">bitpix</span> <span class="o">==</span> <span class="n">bits</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bzero</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bits</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">dtype</span>

        <span class="k">if</span> <span class="n">bitpix</span> <span class="o">&gt;</span> <span class="mi">16</span><span class="p">:</span>  <span class="c"># scale integers to Float64</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;float64&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bitpix</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c"># scale integers to Float32</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s">&#39;float32&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_header_scale_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_do_not_scale_image_data</span> <span class="ow">and</span>
                <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orig_bzero</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orig_bscale</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;BSCALE&#39;</span><span class="p">,</span> <span class="s">&#39;BZERO&#39;</span><span class="p">]:</span>
                <span class="c"># Make sure to delete from both the image header and the table</span>
                <span class="c"># header; later this will be streamlined</span>
                <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">):</span>
                    <span class="k">with</span> <span class="n">ignored</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">):</span>
                        <span class="k">del</span> <span class="n">header</span><span class="p">[</span><span class="n">keyword</span><span class="p">]</span>
                        <span class="c"># Since _update_header_scale_info can, currently, be</span>
                        <span class="c"># called *after* _prewriteto(), replace these with</span>
                        <span class="c"># blank cards so the header size doesn&#39;t change</span>
                        <span class="n">header</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dtype_for_bitpix</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DTYPE2BITPIX</span><span class="p">[</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_bzero</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bscale</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_bitpix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="p">[</span><span class="s">&#39;BITPIX&#39;</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_generate_dither_seed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_int</span><span class="p">(</span><span class="n">seed</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Seed must be an integer&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">seed</span> <span class="o">&lt;=</span> <span class="mi">10000</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s">&quot;Seed for random dithering must be either between 1 and &quot;</span>
                <span class="s">&quot;10000 inclusive, 0 for autogeneration from the system &quot;</span>
                <span class="s">&quot;clock, or -1 for autogeneration from a checksum of the first &quot;</span>
                <span class="s">&quot;image tile (got </span><span class="si">%s</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="n">seed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">seed</span> <span class="o">==</span> <span class="n">DITHER_SEED_CHECKSUM</span><span class="p">:</span>
            <span class="c"># Determine the tile dimensions from the ZTILEn keywords</span>
            <span class="n">naxis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZNAXIS&#39;</span><span class="p">]</span>
            <span class="n">tile_dims</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="p">[</span><span class="s">&#39;ZTILE</span><span class="si">%d</span><span class="s">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
                         <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">naxis</span><span class="p">)]</span>
            <span class="n">tile_dims</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

            <span class="c"># Get the first tile by using the tile dimensions as the end</span>
            <span class="c"># indices of slices (starting from 0)</span>
            <span class="n">first_tile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">tile_dims</span><span class="p">)]</span>

            <span class="c"># The checksum algorithm used is literally just the sum of the bytes</span>
            <span class="c"># of the tile data (not its actual floating point values).  Integer</span>
            <span class="c"># overflow is irrelevant.</span>
            <span class="n">csum</span> <span class="o">=</span> <span class="n">first_tile</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="s">&#39;uint8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="c"># Since CFITSIO uses an unsigned long (which may be different on</span>
            <span class="c"># different platforms) go ahead and truncate the sum to its</span>
            <span class="c"># unsigned long value and take the result modulo 10000</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ctypes</span><span class="o">.</span><span class="n">c_ulong</span><span class="p">(</span><span class="n">csum</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">%</span> <span class="mi">10000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">seed</span> <span class="o">==</span> <span class="n">DITHER_SEED_CLOCK</span><span class="p">:</span>
            <span class="c"># This isn&#39;t exactly the same algorithm as CFITSIO, but that&#39;s okay</span>
            <span class="c"># since the result is meant to be arbitrary. The primary difference</span>
            <span class="c"># is that CFITSIO incorporates the HDU number into the result in</span>
            <span class="c"># the hopes of heading off the possibility of the same seed being</span>
            <span class="c"># generated for two HDUs at the same time.  Here instead we just</span>
            <span class="c"># add in the HDU object&#39;s id</span>
            <span class="k">return</span> <span class="p">((</span><span class="nb">sum</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">math</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()))</span> <span class="o">+</span> <span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span> <span class="o">%</span>
                    <span class="mi">10000</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">seed</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.5. &nbsp;
    Last built 29 Apr 2016. <br/>
  </p>
</footer>
  </body>
</html>