<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>astropy.convolution.convolve &mdash; Astropy v1.2.dev15003</title>
    
    <link rel="stylesheet" href="../../../_static/bootstrap-astropy.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.2.dev15003',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/sidebar.js"></script>
    <link rel="shortcut icon" href="../../../_static/astropy_logo.ico"/>
    <link rel="top" title="Astropy v1.2.dev15003" href="../../../index.html" />
    <link rel="up" title="Module code" href="../../index.html" />
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,600' rel='stylesheet' type='text/css'/>
<script type="text/javascript" src="../../../_static/copybutton.js"></script>


  </head>
  <body role="document">
<div class="topbar">
  <a class="brand" title="Documentation Home" href="../../../index.html"><span id="logotext1">astro</span><span id="logotext2">py</span><span id="logotext3">:docs</span></a>
  <ul>
    <li><a class="homelink" title="Astropy Homepage" href="http://www.astropy.org"></a></li>
    <li><a title="General Index" href="../../../genindex.html">Index</a></li>
    <li><a title="Module Index" href="../../../py-modindex.html">Modules</a></li>
    <li>
      
      
<form action="../../../search.html" method="get">
  <input type="text" name="q" placeholder="Search" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      
    </li>
  </ul>
</div>

<div class="related">
    <h3>Navigation</h3>
    <ul>
      <li>
	<a href="../../../index.html">Astropy v1.2.dev15003</a>
	 &raquo;
      </li>
      <li><a href="../../index.html" accesskey="U">Module code</a> &raquo;</li>
      
       
    </ul>
</div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for astropy.convolution.convolve</h1><div class="highlight"><pre>
<span class="c"># Licensed under a 3-clause BSD style license - see LICENSE.rst</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="p">(</span><span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span><span class="p">,</span>
                        <span class="n">unicode_literals</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="n">Kernel</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">,</span> <span class="n">MAX_NORMALIZATION</span>
<span class="kn">from</span> <span class="nn">..utils.exceptions</span> <span class="kn">import</span> <span class="n">AstropyUserWarning</span>
<span class="kn">from</span> <span class="nn">..utils.console</span> <span class="kn">import</span> <span class="n">human_file_size</span>

<span class="kn">from</span> <span class="nn">astropy</span> <span class="kn">import</span> <span class="n">units</span> <span class="k">as</span> <span class="n">u</span>


<span class="c"># Disabling all doctests in this module until a better way of handling warnings</span>
<span class="c"># in doctests can be determined</span>
<span class="n">__doctest_skip__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&#39;*&#39;</span><span class="p">]</span>


<div class="viewcode-block" id="convolve"><a class="viewcode-back" href="../../../api/astropy.convolution.convolve.html#astropy.convolution.convolve">[docs]</a><span class="k">def</span> <span class="nf">convolve</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
             <span class="n">normalize_kernel</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convolve an array with a kernel.</span>

<span class="sd">    This routine differs from `scipy.ndimage.convolve` because</span>
<span class="sd">    it includes a special treatment for ``NaN`` values. Rather than</span>
<span class="sd">    including ``NaN`` values in the array in the convolution calculation, which</span>
<span class="sd">    causes large ``NaN`` holes in the convolved array, ``NaN`` values are</span>
<span class="sd">    replaced with interpolated values using the kernel as an interpolation</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">        The array to convolve. This should be a 1, 2, or 3-dimensional array</span>
<span class="sd">        or a list or a set of nested lists representing a 1, 2, or</span>
<span class="sd">        3-dimensional array.</span>
<span class="sd">    kernel : `numpy.ndarray` or `~astropy.convolution.Kernel`</span>
<span class="sd">        The convolution kernel. The number of dimensions should match those</span>
<span class="sd">        for the array, and the dimensions should be odd in all directions.</span>
<span class="sd">    boundary : str, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>
<span class="sd">            * `None`</span>
<span class="sd">                Set the ``result`` values to zero where the kernel</span>
<span class="sd">                extends beyond the edge of the array (default).</span>
<span class="sd">            * &#39;fill&#39;</span>
<span class="sd">                Set values outside the array boundary to ``fill_value``.</span>
<span class="sd">            * &#39;wrap&#39;</span>
<span class="sd">                Periodic boundary that wrap to the other side of ``array``.</span>
<span class="sd">            * &#39;extend&#39;</span>
<span class="sd">                Set values outside the array to the nearest ``array``</span>
<span class="sd">                value.</span>
<span class="sd">    fill_value : float, optional</span>
<span class="sd">        The value to use outside the array when using ``boundary=&#39;fill&#39;``</span>
<span class="sd">    normalize_kernel : bool, optional</span>
<span class="sd">        Whether to normalize the kernel prior to convolving</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : `numpy.ndarray`</span>
<span class="sd">        An array with the same dimensions and as the input array,</span>
<span class="sd">        convolved with kernel.  The data type depends on the input</span>
<span class="sd">        array type.  If array is a floating point type, then the</span>
<span class="sd">        return array keeps the same data type, otherwise the type</span>
<span class="sd">        is ``numpy.float``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Masked arrays are not supported at this time.  The convolution</span>
<span class="sd">    is always done at ``numpy.float`` precision.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="kn">from</span> <span class="nn">.boundary_none</span> <span class="kn">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_none</span><span class="p">,</span>
                                <span class="n">convolve2d_boundary_none</span><span class="p">,</span>
                                <span class="n">convolve3d_boundary_none</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.boundary_extend</span> <span class="kn">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_extend</span><span class="p">,</span>
                                  <span class="n">convolve2d_boundary_extend</span><span class="p">,</span>
                                  <span class="n">convolve3d_boundary_extend</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.boundary_fill</span> <span class="kn">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_fill</span><span class="p">,</span>
                                <span class="n">convolve2d_boundary_fill</span><span class="p">,</span>
                                <span class="n">convolve3d_boundary_fill</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.boundary_wrap</span> <span class="kn">import</span> <span class="p">(</span><span class="n">convolve1d_boundary_wrap</span><span class="p">,</span>
                                <span class="n">convolve2d_boundary_wrap</span><span class="p">,</span>
                                <span class="n">convolve3d_boundary_wrap</span><span class="p">)</span>

    <span class="c"># The cython routines all need float type inputs (so, a particular</span>
    <span class="c"># bit size, endianness, etc.).  So we have to convert, which also</span>
    <span class="c"># has the effect of making copies so we don&#39;t modify the inputs.</span>
    <span class="c"># After this, the variables we work with will be array_internal, and</span>
    <span class="c"># kernel_internal.  However -- we do want to keep track of what type</span>
    <span class="c"># the input array was so we can cast the result to that at the end</span>
    <span class="c"># if it&#39;s a floating point type.  Don&#39;t bother with this for lists --</span>
    <span class="c"># just always push those as np.float.</span>
    <span class="c"># It is always necessary to make a copy of kernel (since it is modified),</span>
    <span class="c"># but, if we just so happen to be lucky enough to have the input array</span>
    <span class="c"># have exactly the desired type, we just alias to array_internal</span>

    <span class="c"># Check if kernel is kernel instance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="c"># Check if array is also kernel instance, if so convolve and</span>
        <span class="c"># return new kernel instance</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel1D</span><span class="p">):</span>
                <span class="n">new_array</span> <span class="o">=</span> <span class="n">convolve1d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">new_kernel</span> <span class="o">=</span> <span class="n">Kernel1D</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">new_array</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel2D</span><span class="p">):</span>
                <span class="n">new_array</span> <span class="o">=</span> <span class="n">convolve2d_boundary_fill</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">new_kernel</span> <span class="o">=</span> <span class="n">Kernel2D</span><span class="p">(</span><span class="n">array</span><span class="o">=</span><span class="n">new_array</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;Can&#39;t convolve 1D and 2D kernel.&quot;</span><span class="p">)</span>
            <span class="n">new_kernel</span><span class="o">.</span><span class="n">_separable</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">_separable</span> <span class="ow">and</span> <span class="n">array</span><span class="o">.</span><span class="n">_separable</span>
            <span class="n">new_kernel</span><span class="o">.</span><span class="n">_is_bool</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">new_kernel</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span>

    <span class="c"># Check that the arguments are lists or Numpy arrays</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">array_internal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">array_dtype</span> <span class="o">=</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c"># Note this won&#39;t copy if it doesn&#39;t have to -- which is okay</span>
        <span class="c"># because none of what follows modifies array_internal.  However,</span>
        <span class="c"># only numpy &gt; 1.7 has support for no-copy astype, so we use</span>
        <span class="c"># a try/except because astropy supports 1.5 and 1.6</span>
        <span class="n">array_dtype</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">array_internal</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">array_internal</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;array should be a list or a Numpy array&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="c"># Note this always makes a copy, since we will be modifying it</span>
        <span class="n">kernel_internal</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;kernel should be a list or a Numpy array&quot;</span><span class="p">)</span>

    <span class="c"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel_internal</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&#39;array and kernel have differing number of &#39;</span>
                        <span class="s">&#39;dimensions.&#39;</span><span class="p">)</span>

    <span class="c"># Because the Cython routines have to normalize the kernel on the fly, we</span>
    <span class="c"># explicitly normalize the kernel here, and then scale the image at the</span>
    <span class="c"># end if normalization was not requested.</span>
    <span class="n">kernel_sum</span> <span class="o">=</span> <span class="n">kernel_internal</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">kernel_sum</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span> <span class="ow">and</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The kernel can&#39;t be normalized, because its sum is &quot;</span>
                        <span class="s">&quot;close to zero. The sum of the given kernel is &lt; {0}&quot;</span>
                        <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">))</span>
    <span class="n">kernel_internal</span> <span class="o">/=</span> <span class="n">kernel_sum</span>

    <span class="k">if</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;cannot convolve 0-dimensional arrays&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_extend</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                                <span class="n">kernel_internal</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_fill</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_wrap</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve1d_boundary_none</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_extend</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                                <span class="n">kernel_internal</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_fill</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_wrap</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve2d_boundary_none</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array_internal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_extend</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                                <span class="n">kernel_internal</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_fill</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">,</span>
                                              <span class="nb">float</span><span class="p">(</span><span class="n">fill_value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_wrap</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">convolve3d_boundary_none</span><span class="p">(</span><span class="n">array_internal</span><span class="p">,</span>
                                              <span class="n">kernel_internal</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="bp">NotImplemented</span><span class="p">(</span><span class="s">&#39;convolve only supports 1, 2, and 3-dimensional &#39;</span>
                             <span class="s">&#39;arrays at this time&#39;</span><span class="p">)</span>

    <span class="c"># If normalization was not requested, we need to scale the array (since</span>
    <span class="c"># the kernel was normalized prior to convolution)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">kernel_sum</span>

    <span class="c"># Try to preserve the input type if it&#39;s a floating point type</span>
    <span class="k">if</span> <span class="n">array_dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s">&#39;f&#39;</span><span class="p">:</span>
        <span class="c"># Avoid making another copy if possible</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">array_dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span>

</div>
<div class="viewcode-block" id="convolve_fft"><a class="viewcode-back" href="../../../api/astropy.convolution.convolve_fft.html#astropy.convolution.convolve_fft">[docs]</a><span class="k">def</span> <span class="nf">convolve_fft</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">boundary</span><span class="o">=</span><span class="s">&#39;fill&#39;</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">return_fft</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">fft_pad</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">psf_pad</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                 <span class="n">interpolate_nan</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">quiet</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ignore_edge_zeros</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">min_wt</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">normalize_kernel</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">allow_huge</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                 <span class="n">fftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fftn</span><span class="p">,</span> <span class="n">ifftn</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftn</span><span class="p">,</span>
                 <span class="n">complex_dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convolve an ndarray with an nd-kernel.  Returns a convolved image with</span>
<span class="sd">    shape = array.shape.  Assumes kernel is centered.</span>

<span class="sd">    `convolve_fft` differs from `scipy.signal.fftconvolve` in a few ways:</span>

<span class="sd">    * It can treat ``NaN`` values as zeros or interpolate over them.</span>
<span class="sd">    * ``inf`` values are treated as ``NaN``</span>
<span class="sd">    * (optionally) It pads to the nearest 2^n size to improve FFT speed.</span>
<span class="sd">    * Its only valid ``mode`` is &#39;same&#39; (i.e., the same shape array is returned)</span>
<span class="sd">    * It lets you use your own fft, e.g.,</span>
<span class="sd">      `pyFFTW &lt;http://pypi.python.org/pypi/pyFFTW&gt;`_ or</span>
<span class="sd">      `pyFFTW3 &lt;http://pypi.python.org/pypi/PyFFTW3/0.2.1&gt;`_ , which can lead to</span>
<span class="sd">      performance improvements, depending on your system configuration.  pyFFTW3</span>
<span class="sd">      is threaded, and therefore may yield significant performance benefits on</span>
<span class="sd">      multi-core machines at the cost of greater memory requirements.  Specify</span>
<span class="sd">      the ``fftn`` and ``ifftn`` keywords to override the default, which is</span>
<span class="sd">      `numpy.fft.fft` and `numpy.fft.ifft`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : `numpy.ndarray`</span>
<span class="sd">          Array to be convolved with ``kernel``</span>
<span class="sd">    kernel : `numpy.ndarray`</span>
<span class="sd">          Will be normalized if ``normalize_kernel`` is set.  Assumed to be</span>
<span class="sd">          centered (i.e., shifts may result if your kernel is asymmetric)</span>
<span class="sd">    boundary : {&#39;fill&#39;, &#39;wrap&#39;}, optional</span>
<span class="sd">        A flag indicating how to handle boundaries:</span>

<span class="sd">            * &#39;fill&#39;: set values outside the array boundary to fill_value</span>
<span class="sd">              (default)</span>
<span class="sd">            * &#39;wrap&#39;: periodic boundary</span>

<span class="sd">    interpolate_nan : bool, optional</span>
<span class="sd">        The convolution will be re-weighted assuming ``NaN`` values are meant to be</span>
<span class="sd">        ignored, not treated as zero.  If this is off, all ``NaN`` values will be</span>
<span class="sd">        treated as zero.</span>
<span class="sd">    ignore_edge_zeros : bool, optional</span>
<span class="sd">        Ignore the zero-pad-created zeros.  This will effectively decrease</span>
<span class="sd">        the kernel area on the edges but will not re-normalize the kernel.</span>
<span class="sd">        This parameter may result in &#39;edge-brightening&#39; effects if you&#39;re using</span>
<span class="sd">        a normalized kernel</span>
<span class="sd">    min_wt : float, optional</span>
<span class="sd">        If ignoring ``NaN`` / zeros, force all grid points with a weight less than</span>
<span class="sd">        this value to ``NaN`` (the weight of a grid point with *no* ignored</span>
<span class="sd">        neighbors is 1.0).</span>
<span class="sd">        If ``min_wt`` is zero, then all zero-weight points will be set to zero</span>
<span class="sd">        instead of ``NaN`` (which they would be otherwise, because 1/0 = nan).</span>
<span class="sd">        See the examples below</span>
<span class="sd">    normalize_kernel : function or boolean, optional</span>
<span class="sd">        If specified, this is the function to divide kernel by to normalize it.</span>
<span class="sd">        e.g., ``normalize_kernel=np.sum`` means that kernel will be modified to be:</span>
<span class="sd">        ``kernel = kernel / np.sum(kernel)``.  If True, defaults to</span>
<span class="sd">        ``normalize_kernel = np.sum``.</span>

<span class="sd">    Other Parameters</span>
<span class="sd">    ----------------</span>
<span class="sd">    fft_pad : bool, optional</span>
<span class="sd">        Default on.  Zero-pad image to the nearest 2^n.  With</span>
<span class="sd">        ``boundary=&#39;wrap&#39;``, this will be disabled.</span>
<span class="sd">    psf_pad : bool, optional</span>
<span class="sd">        Zero-pad image to be at least the sum of the image sizes to avoid</span>
<span class="sd">        edge-wrapping when smoothing.  This is enabled by default with</span>
<span class="sd">        ``boundary=&#39;fill&#39;``, but it can be overridden with a boolean option.</span>
<span class="sd">        ``boundary=&#39;wrap&#39;`` and ``psf_pad=True`` are not compatible.</span>
<span class="sd">    crop : bool, optional</span>
<span class="sd">        Default on.  Return an image of the size of the largest input image.</span>
<span class="sd">        If the images are asymmetric in opposite directions, will return the</span>
<span class="sd">        largest image in both directions.</span>
<span class="sd">        For example, if an input image has shape [100,3] but a kernel with shape</span>
<span class="sd">        [6,6] is used, the output will be [100,6].</span>
<span class="sd">    return_fft : bool, optional</span>
<span class="sd">        Return the fft(image)*fft(kernel) instead of the convolution (which is</span>
<span class="sd">        ifft(fft(image)*fft(kernel))).  Useful for making PSDs.</span>
<span class="sd">    fftn, ifftn : functions, optional</span>
<span class="sd">        The fft and inverse fft functions.  Can be overridden to use your own</span>
<span class="sd">        ffts, e.g. an fftw3 wrapper or scipy&#39;s fftn, e.g.</span>
<span class="sd">        ``fftn=scipy.fftpack.fftn``</span>
<span class="sd">    complex_dtype : np.complex, optional</span>
<span class="sd">        Which complex dtype to use.  `numpy` has a range of options, from 64 to</span>
<span class="sd">        256.</span>
<span class="sd">    quiet : bool, optional</span>
<span class="sd">        Silence warning message about NaN interpolation</span>
<span class="sd">    allow_huge : bool, optional</span>
<span class="sd">        Allow huge arrays in the FFT?  If False, will raise an exception if the</span>
<span class="sd">        array or kernel size is &gt;1 GB</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError:</span>
<span class="sd">        If the array is bigger than 1 GB after padding, will raise this exception</span>
<span class="sd">        unless allow_huge is True</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    convolve : Convolve is a non-fft version of this code.  It is more</span>
<span class="sd">               memory efficient and for small kernels can be faster.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    default : ndarray</span>
<span class="sd">        **array** convolved with ``kernel``.</span>
<span class="sd">        If ``return_fft`` is set, returns fft(**array**) * fft(``kernel``).</span>
<span class="sd">        If crop is not set, returns the image, but with the fft-padded size</span>
<span class="sd">        instead of the input size</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">        With psf_pad=True and a large PSF, the resulting data can become very</span>
<span class="sd">        large and consume a lot of memory.  See Issue</span>
<span class="sd">        https://github.com/astropy/astropy/pull/4366 for further detail.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [1, 1, 1])</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1])</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 0, 3], [0, 1, 0])</span>
<span class="sd">    array([ 1.,  0.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, 2, 3], [1])</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], interpolate_nan=True)</span>
<span class="sd">    ...</span>
<span class="sd">    array([ 1.,  0.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [0, 1, 0], interpolate_nan=True,</span>
<span class="sd">    ...              min_wt=1e-8)</span>
<span class="sd">    array([ 1.,  nan,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], interpolate_nan=True)</span>
<span class="sd">    array([ 1.,  4.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], interpolate_nan=True,</span>
<span class="sd">    ...               normalize_kernel=True, ignore_edge_zeros=True)</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &gt;&gt;&gt; import scipy.fftpack  # optional - requires scipy</span>
<span class="sd">    &gt;&gt;&gt; convolve_fft([1, np.nan, 3], [1, 1, 1], interpolate_nan=True,</span>
<span class="sd">    ...               normalize_kernel=True, ignore_edge_zeros=True,</span>
<span class="sd">    ...               fftn=scipy.fftpack.fft, ifftn=scipy.fftpack.ifft)</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c"># Checking copied from convolve.py - however, since FFTs have real &amp;</span>
    <span class="c"># complex components, we change the types.  Only the real part will be</span>
    <span class="c"># returned! Note that this always makes a copy.</span>
    <span class="c"># Check kernel is kernel instance</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">array</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">Kernel</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Can&#39;t convolve two kernels. Use convolve() instead.&quot;</span><span class="p">)</span>

    <span class="c"># Convert array dtype to complex</span>
    <span class="c"># and ensure that list inputs become arrays</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">)</span>

    <span class="c"># Check that the number of dimensions is compatible</span>
    <span class="k">if</span> <span class="n">array</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Image and kernel must have same number of &quot;</span>
                         <span class="s">&quot;dimensions&quot;</span><span class="p">)</span>

    <span class="n">arrayshape</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">kernshape</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span>

    <span class="n">array_size_B</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">complex_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span>
    <span class="k">if</span> <span class="n">array_size_B</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">GB</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Size Error: Arrays will be </span><span class="si">%s</span><span class="s">.  Use &quot;</span>
                         <span class="s">&quot;allow_huge=True to override this exception.&quot;</span>
                         <span class="o">%</span> <span class="n">human_file_size</span><span class="p">(</span><span class="n">array_size_B</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

    <span class="c"># mask catching - masks must be turned into NaNs for use later</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
        <span class="n">array</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">is_masked</span><span class="p">(</span><span class="n">kernel</span><span class="p">):</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">mask</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">kernel</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="c"># NaN and inf catching</span>
    <span class="n">nanmaskarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nanmaskkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">interpolate_nan</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quiet</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nanmaskarray</span><span class="p">)</span> <span class="ow">or</span>
                                               <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nanmaskkernel</span><span class="p">))):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;NOT ignoring NaN values even though they are present &quot;</span>
                      <span class="s">&quot; (they are treated as 0)&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">normalize_kernel</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s">&quot;The kernel can&#39;t be normalized, because its sum is &quot;</span>
                            <span class="s">&quot;close to zero. The sum of the given kernel is &lt; {0}&quot;</span>
                            <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mf">1.</span> <span class="o">/</span> <span class="n">MAX_NORMALIZATION</span><span class="p">))</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">normalize_kernel</span><span class="p">:</span>
        <span class="c"># try this.  If a function is not passed, the code will just crash... I</span>
        <span class="c"># think type checking would be better but PEPs say otherwise...</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span> <span class="o">/</span> <span class="n">normalize_kernel</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-8</span><span class="p">:</span>
            <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kernel_is_normalized</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;Kernel is not normalized, therefore &quot;</span>
                              <span class="s">&quot;ignore_edge_zeros and interpolate_nan will be &quot;</span>
                              <span class="s">&quot;ignored.&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">boundary</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;The convolve_fft version of boundary=None is &quot;</span>
                      <span class="s">&quot;equivalent to the convolve boundary=&#39;fill&#39;.  There is &quot;</span>
                      <span class="s">&quot;no FFT equivalent to convolve&#39;s &quot;</span>
                      <span class="s">&quot;zero-if-kernel-leaves-boundary&quot;</span><span class="p">,</span> <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">psf_pad</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">psf_pad</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">fft_pad</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fft_pad</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;fill&#39;</span><span class="p">:</span>
        <span class="c"># create a boundary region at least as large as the kernel</span>
        <span class="k">if</span> <span class="n">psf_pad</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s">&quot;psf_pad was set to {0}, which overrides the &quot;</span>
                          <span class="s">&quot;boundary=&#39;fill&#39; setting.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">psf_pad</span><span class="p">),</span>
                          <span class="n">AstropyUserWarning</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">psf_pad</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">fft_pad</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># default is &#39;True&#39; according to the docstring</span>
            <span class="n">fft_pad</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;wrap&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;With boundary=&#39;wrap&#39;, psf_pad cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">psf_pad</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;With boundary=&#39;wrap&#39;, fft_pad cannot be enabled.&quot;</span><span class="p">)</span>
        <span class="n">fft_pad</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c"># force zero; it should not be used</span>
    <span class="k">elif</span> <span class="n">boundary</span> <span class="o">==</span> <span class="s">&#39;extend&#39;</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s">&quot;The &#39;extend&#39; option is not implemented &quot;</span>
                                  <span class="s">&quot;for fft-based convolution&quot;</span><span class="p">)</span>

    <span class="c"># find ideal size (power of 2) for fft.</span>
    <span class="c"># Can add shapes because they are tuples</span>
    <span class="k">if</span> <span class="n">fft_pad</span><span class="p">:</span> <span class="c"># default=True</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span> <span class="c"># default=False</span>
            <span class="c"># add the dimensions and then take the max (bigger)</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">))))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># add the shape lists (max of a list of length 4) (smaller)</span>
            <span class="c"># also makes the shapes square</span>
            <span class="n">fsize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">arrayshape</span> <span class="o">+</span> <span class="n">kernshape</span><span class="p">)))</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">fsize</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">ndim</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">psf_pad</span><span class="p">:</span>
            <span class="c"># just add the biggest dimensions</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">kernshape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span><span class="p">])</span>
                                 <span class="k">for</span> <span class="n">imsh</span><span class="p">,</span> <span class="n">kernsh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)])</span>

    <span class="c"># perform a second check after padding</span>
    <span class="n">array_size_C</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span> <span class="o">*</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">complex_dtype</span><span class="p">)</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span>
    <span class="k">if</span> <span class="n">array_size_C</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">*</span><span class="n">u</span><span class="o">.</span><span class="n">GB</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">allow_huge</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Size Error: Arrays will be </span><span class="si">%s</span><span class="s">.  Use &quot;</span>
                         <span class="s">&quot;allow_huge=True to override this exception.&quot;</span>
                         <span class="o">%</span> <span class="n">human_file_size</span><span class="p">(</span><span class="n">array_size_C</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">byte</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>

    <span class="c"># For future reference, this can be used to predict &quot;almost exactly&quot;</span>
    <span class="c"># how much *additional* memory will be used.</span>
    <span class="c"># size * (array + kernel + kernelfft + arrayfft +</span>
    <span class="c">#         (kernel*array)fft +</span>
    <span class="c">#         optional(weight image + weight_fft + weight_ifft) +</span>
    <span class="c">#         optional(returned_fft))</span>
    <span class="c">#total_memory_used_GB = (np.product(newshape)*np.dtype(complex_dtype).itemsize</span>
    <span class="c">#                        * (5 + 3*((interpolate_nan or ignore_edge_zeros) and kernel_is_normalized))</span>
    <span class="c">#                        + (1 + (not return_fft)) *</span>
    <span class="c">#                          np.product(arrayshape)*np.dtype(complex_dtype).itemsize</span>
    <span class="c">#                        + np.product(arrayshape)*np.dtype(bool).itemsize</span>
    <span class="c">#                        + np.product(kernshape)*np.dtype(bool).itemsize)</span>
    <span class="c">#                        ) / 1024.**3</span>

    <span class="c"># separate each dimension by the padding size...  this is to determine the</span>
    <span class="c"># appropriate slice size to get back to the input dimensions</span>
    <span class="n">arrayslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">kernslices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="p">(</span><span class="n">newdimsize</span><span class="p">,</span> <span class="n">arraydimsize</span><span class="p">,</span> <span class="n">kerndimsize</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">arrayshape</span><span class="p">,</span> <span class="n">kernshape</span><span class="p">)):</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">newdimsize</span> <span class="o">-</span> <span class="p">(</span><span class="n">newdimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">arrayslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">arraydimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">arraydimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>
        <span class="n">kernslices</span> <span class="o">+=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">center</span> <span class="o">-</span> <span class="n">kerndimsize</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
                             <span class="n">center</span> <span class="o">+</span> <span class="p">(</span><span class="n">kerndimsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">arrayshape</span><span class="p">):</span>
        <span class="n">bigarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">fill_value</span>
        <span class="n">bigarray</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">array</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigarray</span> <span class="o">=</span> <span class="n">array</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">newshape</span> <span class="o">==</span> <span class="n">kernshape</span><span class="p">):</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigkernel</span><span class="p">[</span><span class="n">kernslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigkernel</span> <span class="o">=</span> <span class="n">kernel</span>

    <span class="n">arrayfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigarray</span><span class="p">)</span>
    <span class="c"># need to shift the kernel so that, e.g., [0,0,1,0] -&gt; [1,0,0,0] = unity</span>
    <span class="n">kernfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifftshift</span><span class="p">(</span><span class="n">bigkernel</span><span class="p">))</span>
    <span class="n">fftmult</span> <span class="o">=</span> <span class="n">arrayfft</span> <span class="o">*</span> <span class="n">kernfft</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kernel_is_normalized</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ignore_edge_zeros</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bigimwt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">complex_dtype</span><span class="p">)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">nanmaskarray</span> <span class="o">*</span> <span class="n">interpolate_nan</span>
        <span class="n">wtfft</span> <span class="o">=</span> <span class="n">fftn</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">)</span>
        <span class="c"># I think this one HAS to be normalized (i.e., the weights can&#39;t be</span>
        <span class="c"># computed with a non-normalized kernel)</span>
        <span class="n">wtfftmult</span> <span class="o">=</span> <span class="n">wtfft</span> <span class="o">*</span> <span class="n">kernfft</span> <span class="o">/</span> <span class="n">kernel</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">wtsm</span> <span class="o">=</span> <span class="n">ifftn</span><span class="p">(</span><span class="n">wtfftmult</span><span class="p">)</span>
        <span class="c"># need to re-zero weights outside of the image (if it is padded, we</span>
        <span class="c"># still don&#39;t weight those regions)</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span> <span class="o">=</span> <span class="n">wtsm</span><span class="o">.</span><span class="n">real</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span>
        <span class="c"># curiously, at the floating-point limit, can get slightly negative numbers</span>
        <span class="c"># they break the min_wt=0 &quot;flag&quot; and must therefore be removed</span>
        <span class="n">bigimwt</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigimwt</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">fftmult</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="c"># this check should be unnecessary; call it an insanity check</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Encountered NaNs in convolve.  This is disallowed.&quot;</span><span class="p">)</span>

    <span class="c"># restore NaNs in original image (they were modified inplace earlier)</span>
    <span class="c"># We don&#39;t have to worry about masked arrays - if input was masked, it was</span>
    <span class="c"># copied</span>
    <span class="n">array</span><span class="p">[</span><span class="n">nanmaskarray</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">kernel</span><span class="p">[</span><span class="n">nanmaskkernel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">if</span> <span class="n">return_fft</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fftmult</span>

    <span class="k">if</span> <span class="n">interpolate_nan</span> <span class="ow">or</span> <span class="n">ignore_edge_zeros</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span> <span class="o">/</span> <span class="n">bigimwt</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">bigimwt</span><span class="p">):</span>
            <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">&lt;</span> <span class="n">min_wt</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">if</span> <span class="n">min_wt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">rifft</span><span class="p">[</span><span class="n">bigimwt</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rifft</span> <span class="o">=</span> <span class="p">(</span><span class="n">ifftn</span><span class="p">(</span><span class="n">fftmult</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">crop</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">rifft</span><span class="p">[</span><span class="n">arrayslices</span><span class="p">]</span><span class="o">.</span><span class="n">real</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">rifft</span><span class="o">.</span><span class="n">real</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Page Contents</h3>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
<footer class="footer">
  <p class="pull-right"> &nbsp;
    <a href="#">Back to Top</a></p>
  <p>
    &copy; Copyright 2011-2016, The Astropy Developers.<br/>
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.3.1. &nbsp;
    Last built 12 May 2016. <br/>
  </p>
</footer>
  </body>
</html>